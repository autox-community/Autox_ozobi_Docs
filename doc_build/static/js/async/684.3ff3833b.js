"use strict";(self.webpackChunkrepress_demo=self.webpackChunkrepress_demo||[]).push([["684"],{9594:function(e,l,a){a.r(l),a.d(l,{default:()=>r});var n=a(2676),i=a(453);function s(e){let l=Object.assign({h1:"h1",a:"a",div:"div",p:"p",code:"code",pre:"pre",h2:"h2",ul:"ul",li:"li"},(0,i.ah)(),e.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(l.h1,{id:"timers",children:["Timers",(0,n.jsx)(l.a,{className:"header-anchor","aria-hidden":"true",href:"#timers",children:"#"})]}),"\n",(0,n.jsxs)(l.div,{className:"rspress-directive tip",children:[(0,n.jsx)(l.div,{className:"rspress-directive-title",children:"稳定性: 稳定"}),(0,n.jsx)(l.div,{className:"rspress-directive-content",children:"\n"})]}),"\n",(0,n.jsx)(l.p,{children:"timers 模块暴露了一个全局的 API，用于在某个未来时间段调用调度函数。"}),"\n",(0,n.jsx)(l.p,{children:"因为定时器函数是全局的，所以使用该 API 无需调用 timers.XXXXX"}),"\n",(0,n.jsxs)(l.p,{children:["Auto.js 中的计时器函数实现了与 Web 浏览器提供的定时器类似的 API，除了它使用了一个不同的内部实现，它是基于 ",(0,n.jsx)(l.code,{children:"Android Looper-Handler"})," 消息循环机制构建的。其实现机制与 Node.js 比较相似。"]}),"\n",(0,n.jsx)(l.p,{children:'例如，要在 5 秒后发出消息"hello":'}),"\n",(0,n.jsx)(l.pre,{children:(0,n.jsx)(l.code,{className:"language-js",children:'setTimeout(function () {\n    toast("hello");\n}, 5000);\n'})}),"\n",(0,n.jsx)(l.p,{children:"需要注意的是，这些定时器仍然是单线程的。如果脚本主体有耗时操作或死循环，则设定的定时器不能被及时执行，例如："}),"\n",(0,n.jsx)(l.pre,{children:(0,n.jsx)(l.code,{className:"language-js",children:'setTimeout(function () {\n    //这里的语句会在15秒后执行而不是5秒后\n    toast("hello");\n}, 5000);\n//暂停10秒\nsleep(10000);\n'})}),"\n",(0,n.jsx)(l.p,{children:"再如："}),"\n",(0,n.jsx)(l.pre,{children:(0,n.jsx)(l.code,{className:"language-js",children:'setTimeout(function () {\n    //这里的语句永远不会被执行\n    toast("hello");\n}, 5000);\n//死循环\nwhile (true);\n'})}),"\n",(0,n.jsxs)(l.h2,{id:"setintervalcallback-delay-args",children:["setInterval(callback, delay[, ...args])",(0,n.jsx)(l.a,{className:"header-anchor","aria-hidden":"true",href:"#setintervalcallback-delay-args",children:"#"})]}),"\n",(0,n.jsxs)(l.ul,{children:["\n",(0,n.jsxs)(l.li,{children:[(0,n.jsx)(l.code,{children:"callback"})," {Function} 当定时器到点时要调用的函数。"]}),"\n",(0,n.jsxs)(l.li,{children:[(0,n.jsx)(l.code,{children:"delay"})," {number} 调用 callback 之前要等待的毫秒数。"]}),"\n",(0,n.jsxs)(l.li,{children:[(0,n.jsx)(l.code,{children:"...args"})," {any} 当调用 callback 时要传入的可选参数。"]}),"\n"]}),"\n",(0,n.jsx)(l.p,{children:"预定每隔 delay 毫秒重复执行的 callback。 返回一个用于 clearInterval() 的 id。"}),"\n",(0,n.jsx)(l.p,{children:"当 delay 小于 0 时，delay 会被设为 0。"}),"\n",(0,n.jsxs)(l.h2,{id:"settimeoutcallback-delay-args",children:["setTimeout(callback, delay[, ...args])",(0,n.jsx)(l.a,{className:"header-anchor","aria-hidden":"true",href:"#settimeoutcallback-delay-args",children:"#"})]}),"\n",(0,n.jsxs)(l.ul,{children:["\n",(0,n.jsxs)(l.li,{children:[(0,n.jsx)(l.code,{children:"callback"})," {Function} 当定时器到点时要调用的函数。"]}),"\n",(0,n.jsxs)(l.li,{children:[(0,n.jsx)(l.code,{children:"delay"})," {number} 调用 callback 之前要等待的毫秒数。"]}),"\n",(0,n.jsxs)(l.li,{children:[(0,n.jsx)(l.code,{children:"...args"})," {any} 当调用 callback 时要传入的可选参数。"]}),"\n"]}),"\n",(0,n.jsx)(l.p,{children:"预定在 delay 毫秒之后执行的单次 callback。 返回一个用于 clearTimeout() 的 id。"}),"\n",(0,n.jsx)(l.p,{children:"callback 可能不会精确地在 delay 毫秒被调用。 Auto.js 不能保证回调被触发的确切时间，也不能保证它们的顺序。 回调会在尽可能接近所指定的时间上调用。"}),"\n",(0,n.jsx)(l.p,{children:"当 delay 小于 0 时，delay 会被设为 0。"}),"\n",(0,n.jsxs)(l.h2,{id:"setimmediatecallback-args",children:["setImmediate(callback[, ...args])",(0,n.jsx)(l.a,{className:"header-anchor","aria-hidden":"true",href:"#setimmediatecallback-args",children:"#"})]}),"\n",(0,n.jsxs)(l.ul,{children:["\n",(0,n.jsxs)(l.li,{children:[(0,n.jsx)(l.code,{children:"callback"})," {Function} 在 Looper 循环的当前回合结束时要调用的函数。"]}),"\n",(0,n.jsxs)(l.li,{children:[(0,n.jsx)(l.code,{children:"...args"})," {any} 当调用 callback 时要传入的可选参数。"]}),"\n"]}),"\n",(0,n.jsx)(l.p,{children:"预定立即执行的 callback，它是在 I/O 事件的回调之后被触发。 返回一个用于 clearImmediate() 的 id。"}),"\n",(0,n.jsx)(l.p,{children:"当多次调用 setImmediate() 时，callback 函数会按照它们被创建的顺序依次执行。 每次事件循环迭代都会处理整个回调队列。 如果一个立即定时器是被一个正在执行的回调排入队列的，则该定时器直到下一次事件循环迭代才会被触发。"}),"\n",(0,n.jsx)(l.p,{children:"setImmediate()、setInterval() 和 setTimeout() 方法每次都会返回表示预定的计时器的 id。 它们可用于取消定时器并防止触发。"}),"\n",(0,n.jsxs)(l.h2,{id:"clearintervalid",children:["clearInterval(id)",(0,n.jsx)(l.a,{className:"header-anchor","aria-hidden":"true",href:"#clearintervalid",children:"#"})]}),"\n",(0,n.jsxs)(l.ul,{children:["\n",(0,n.jsxs)(l.li,{children:[(0,n.jsx)(l.code,{children:"id"})," {number} 一个 setInterval() 返回的 id。"]}),"\n"]}),"\n",(0,n.jsx)(l.p,{children:"取消一个由 setInterval() 创建的循环定时任务。"}),"\n",(0,n.jsx)(l.p,{children:"例如："}),"\n",(0,n.jsx)(l.pre,{children:(0,n.jsx)(l.code,{className:"language-js",children:'//每5秒就发出一次hello\nvar id = setInterval(function () {\n    toast("hello");\n}, 5000);\n//1分钟后取消循环\nsetTimeout(function () {\n    clearInterval(id);\n}, 60 * 1000);\n'})}),"\n",(0,n.jsxs)(l.h2,{id:"cleartimeoutid",children:["clearTimeout(id)",(0,n.jsx)(l.a,{className:"header-anchor","aria-hidden":"true",href:"#cleartimeoutid",children:"#"})]}),"\n",(0,n.jsxs)(l.ul,{children:["\n",(0,n.jsxs)(l.li,{children:[(0,n.jsx)(l.code,{children:"id"})," {number} 一个 setTimeout() 返回的 id。"]}),"\n"]}),"\n",(0,n.jsx)(l.p,{children:"取消一个由 setTimeout() 创建的定时任务。"}),"\n",(0,n.jsxs)(l.h2,{id:"clearimmediateid",children:["clearImmediate(id)",(0,n.jsx)(l.a,{className:"header-anchor","aria-hidden":"true",href:"#clearimmediateid",children:"#"})]}),"\n",(0,n.jsxs)(l.ul,{children:["\n",(0,n.jsxs)(l.li,{children:[(0,n.jsx)(l.code,{children:"id"})," {number} 一个 setImmediate() 返回的 id。"]}),"\n"]}),"\n",(0,n.jsx)(l.p,{children:"取消一个由 setImmediate() 创建的 Immediate 对象。"})]})}function d(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:l}=Object.assign({},(0,i.ah)(),e.components);return l?(0,n.jsx)(l,{...e,children:(0,n.jsx)(s,{...e})}):s(e)}let r=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["v1%2F%E5%9F%BA%E7%A1%80%2Ftimers.md"]={toc:[{text:"setInterval(callback, delay[, ...args])",id:"setintervalcallback-delay-args",depth:2},{text:"setTimeout(callback, delay[, ...args])",id:"settimeoutcallback-delay-args",depth:2},{text:"setImmediate(callback[, ...args])",id:"setimmediatecallback-args",depth:2},{text:"clearInterval(id)",id:"clearintervalid",depth:2},{text:"clearTimeout(id)",id:"cleartimeoutid",depth:2},{text:"clearImmediate(id)",id:"clearimmediateid",depth:2}],title:"Timers",headingTitle:"Timers",frontmatter:{}}}}]);