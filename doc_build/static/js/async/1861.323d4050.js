"use strict";(self.webpackChunkrepress_demo=self.webpackChunkrepress_demo||[]).push([["1861"],{8826:function(n,r,e){e.r(r),e.d(r,{default:()=>i});var s=e(2676),c=e(453);function d(n){let r=Object.assign({h1:"h1",a:"a",p:"p",blockquote:"blockquote",code:"code",pre:"pre",h2:"h2",ul:"ul",li:"li"},(0,c.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(r.h1,{id:"线程安全",children:["线程安全",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#线程安全",children:"#"})]}),"\n",(0,s.jsx)(r.p,{children:"线程安全问题是一个相对专业的编程问题，本章节只提供给有需要的用户。"}),"\n",(0,s.jsx)(r.p,{children:"引用维基百科的解释："}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"线程安全是编程中的术语，指某个函数、函数库在多线程环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成。"}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:'在 Auto.js 中，线程间变量在符合 JavaScript 变量作用域规则的前提下是共享的，例如全局变量在所有线程都能访问，并且保证他们在所有线程的可见性。但是，不保证任何操作的原子性。例如经典的自增"i++"将不是原子性操作。'}),"\n",(0,s.jsxs)(r.p,{children:["Rhino 和 Auto.js 提供了一些简单的设施来解决简单的线程安全问题，如锁",(0,s.jsx)(r.code,{children:"threads.lock()"}),", 函数同步锁",(0,s.jsx)(r.code,{children:"sync()"}),", 整数原子变量",(0,s.jsx)(r.code,{children:"threads.atomic()"}),"等。"]}),"\n",(0,s.jsxs)(r.p,{children:["例如，对于多线程共享下的整数的自增操作(自增操作会导致问题，是因为自增操作实际上为",(0,s.jsx)(r.code,{children:"i = i + 1"}),"，也就是先读取 i 的值, 把他加 1, 再赋值给 i, 如果两个线程同时进行自增操作，可能出现 i 的值只增加了 1 的情况)，应该使用",(0,s.jsx)(r.code,{children:"threads.atomic()"}),"函数来新建一个整数原子变量，或者使用锁",(0,s.jsx)(r.code,{children:"threads.lock()"}),"来保证操作的原子性，或者用",(0,s.jsx)(r.code,{children:"sync()"}),"来增加同步锁。"]}),"\n",(0,s.jsx)(r.p,{children:"线程不安全的代码如下："}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-js",children:"var i = 0;\r\nthreads.start(function () {\r\n    while (true) {\r\n        log(i++);\r\n    }\r\n});\r\nwhile (true) {\r\n    log(i++);\r\n}\n"})}),"\n",(0,s.jsx)(r.p,{children:"此段代码运行后打开日志，可以看到日志中有重复的值出现。"}),"\n",(0,s.jsxs)(r.p,{children:["使用",(0,s.jsx)(r.code,{children:"threads.atomic()"}),"的线程安全的代码如下:"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-js",children:"//atomic返回的对象保证了自增的原子性\r\nvar i = threads.atomic();\r\nthreads.start(function () {\r\n    while (true) {\r\n        log(i.getAndIncrement());\r\n    }\r\n});\r\nwhile (true) {\r\n    log(i.getAndIncrement());\r\n}\n"})}),"\n",(0,s.jsx)(r.p,{children:"或者:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-js",children:"//锁保证了操作的原子性\r\nvar lock = threads.lock();\r\nvar i = 0;\r\nthreads.start(function () {\r\n    while (true) {\r\n        lock.lock();\r\n        log(i++);\r\n        lock.unlock();\r\n    }\r\n});\r\nwhile (true) {\r\n    lock.lock();\r\n    log(i++);\r\n    lock.unlock();\r\n}\n"})}),"\n",(0,s.jsx)(r.p,{children:"或者:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-js",children:"//sync函数会把里面的函数加上同步锁，使得在同一时刻最多只能有一个线程执行这个函数\r\nvar i = 0;\r\nvar getAndIncrement = sync(function () {\r\n    return i++;\r\n});\r\nthreads.start(function () {\r\n    while (true) {\r\n        log(getAndIncrement());\r\n    }\r\n});\r\nwhile (true) {\r\n    log(getAndIncrement());\r\n}\n"})}),"\n",(0,s.jsxs)(r.p,{children:["另外，数组 Array 不是线程安全的，如果有这种复杂的需求，请用 Android 和 Java 相关 API 来实现。例如",(0,s.jsx)(r.code,{children:"CopyOnWriteList"}),", ",(0,s.jsx)(r.code,{children:"Vector"}),"等都是代替数组的线程安全的类，用于不同的场景。例如:"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-js",children:'var nums = new java.util.Vector();\r\nnums.add(123);\r\nnums.add(456);\r\ntoast("长度为" + nums.size());\r\ntoast("第一个元素为" + nums.get(0));\n'})}),"\n",(0,s.jsxs)(r.p,{children:["但很明显的是，这些类不像数组那样简便易用，也不能使用诸如",(0,s.jsx)(r.code,{children:"slice()"}),"之类的方便的函数。在未来可能会加入线程安全的数组来解决这个问题。当然您也可以为每个数组的操作加锁来解决线程安全问题："]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-js",children:'var nums = [];\r\nvar numsLock = threads.lock();\r\nthreads.start(function () {\r\n    //向数组添加元素123\r\n    numsLock.lock();\r\n    nums.push(123);\r\n    log("线程: %s, 数组: %s", threads.currentThread(), nums);\r\n    numsLock.unlock();\r\n});\r\n\r\nthreads.start(function () {\r\n    //向数组添加元素456\r\n    numsLock.lock();\r\n    nums.push(456);\r\n    log("线程: %s, 数组: %s", threads.currentThread(), nums);\r\n    numsLock.unlock();\r\n});\r\n\r\n//删除数组最后一个元素\r\nnumsLock.lock();\r\nnums.pop();\r\nlog("线程: %s, 数组: %s", threads.currentThread(), nums);\r\nnumsLock.unlock();\n'})}),"\n",(0,s.jsxs)(r.h2,{id:"syncfunc",children:["sync(func)",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#syncfunc",children:"#"})]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"func"})," {Function} 函数"]}),"\n",(0,s.jsx)(r.li,{children:"返回 {Function}"}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"给函数 func 加上同步锁并作为一个新函数返回。"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-js",children:"var i = 0;\r\nfunction add(x) {\r\n    i += x;\r\n}\r\n\r\nvar syncAdd = sync(add);\r\nsyncAdd(10);\r\ntoast(i);\n"})})]})}function l(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}=Object.assign({},(0,c.ah)(),n.components);return r?(0,s.jsx)(r,{...n,children:(0,s.jsx)(d,{...n})}):d(n)}let i=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["v1%2F%E9%AB%98%E7%BA%A7%2Fthreads%2F%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8.md"]={toc:[{text:"sync(func)",id:"syncfunc",depth:2}],title:"线程安全",headingTitle:"线程安全",frontmatter:{}}}}]);