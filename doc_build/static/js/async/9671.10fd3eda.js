"use strict";(self.webpackChunkrepress_demo=self.webpackChunkrepress_demo||[]).push([["9671"],{438:function(n,r,e){e.r(r),e.d(r,{default:()=>a});var s=e(2676),t=e(453);function c(n){let r=Object.assign({h1:"h1",a:"a",p:"p",code:"code",pre:"pre"},(0,t.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(r.h1,{id:"线程通信",children:["线程通信",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#线程通信",children:"#"})]}),"\n",(0,s.jsxs)(r.p,{children:["Auto.js 提供了一些简单的设施来支持简单的线程通信。",(0,s.jsx)(r.code,{children:"threads.disposable()"}),"用于一个线程等待另一个线程的(一次性)结果，同时",(0,s.jsx)(r.code,{children:"Lock.newCondition()"}),"提供了 Condition 对象用于一般的线程通信(await, signal)。另外，",(0,s.jsx)(r.code,{children:"events"}),"模块也可以用于线程通信，通过指定",(0,s.jsx)(r.code,{children:"EventEmiiter"}),"的回调执行的线程来实现。"]}),"\n",(0,s.jsxs)(r.p,{children:["使用",(0,s.jsx)(r.code,{children:"threads.disposable()"}),'可以简单地等待和获取某个线程的执行结果。例如要等待某个线程计算"1+.....+10000":']}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-js",children:'var sum = threads.disposable();\r\n//启动子线程计算\r\nthreads.start(function () {\r\n    var s = 0;\r\n    //从1加到10000\r\n    for (var i = 1; i <= 10000; i++) {\r\n        s += i;\r\n    }\r\n    //通知主线程接收结果\r\n    sum.setAndNotify(s);\r\n});\r\n//blockedGet()用于等待结果\r\ntoast("sum = " + sum.blockedGet());\n'})}),"\n",(0,s.jsxs)(r.p,{children:["如果上述代码用",(0,s.jsx)(r.code,{children:"Condition"}),"实现："]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-js",children:'//新建一个锁\r\nvar lock = threads.lock();\r\n//新建一个条件，即"计算完成"\r\nvar complete = lock.newCondition();\r\nvar sum = 0;\r\nthreads.start(function () {\r\n    //从1加到10000\r\n    for (var i = 1; i <= 10000; i++) {\r\n        sum += i;\r\n    }\r\n    //通知主线程接收结果\r\n    lock.lock();\r\n    complete.signal();\r\n    lock.unlock();\r\n});\r\n//等待计算完成\r\nlock.lock();\r\ncomplete.await();\r\nlock.unlock();\r\n//打印结果\r\ntoast("sum = " + sum);\n'})}),"\n",(0,s.jsxs)(r.p,{children:["如果上诉代码用",(0,s.jsx)(r.code,{children:"events"}),"模块实现："]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-js",children:'//新建一个emitter, 并指定回调执行的线程为当前线程\r\nvar sum = events.emitter(threads.currentThread());\r\nthreads.start(function () {\r\n    var s = 0;\r\n    //从1加到10000\r\n    for (var i = 1; i <= 10000; i++) {\r\n        s += i;\r\n    }\r\n    //发送事件result通知主线程接收结果\r\n    sum.emit("result", s);\r\n});\r\nsum.on("result", function (s) {\r\n    toastLog("sum = " + s + ", 当前线程: " + threads.currentThread());\r\n});\n'})}),"\n",(0,s.jsxs)(r.p,{children:["有关线程的其他问题，例如生产者消费者等问题，请用 Java 相关方法解决，例如",(0,s.jsx)(r.code,{children:"java.util.concurrent.BlockingQueue"}),"。"]})]})}function i(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}=Object.assign({},(0,t.ah)(),n.components);return r?(0,s.jsx)(r,{...n,children:(0,s.jsx)(c,{...n})}):c(n)}let a=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["v1%2F%E9%AB%98%E7%BA%A7%2Fthreads%2F%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1.md"]={toc:[],title:"线程通信",headingTitle:"线程通信",frontmatter:{}}}}]);