"use strict";(self.webpackChunkrepress_demo=self.webpackChunkrepress_demo||[]).push([["6231"],{6943:function(e,n,r){r.r(n),r.d(n,{default:()=>t});var l=r(2676),s=r(453);function i(e){let n=Object.assign({h1:"h1",a:"a",p:"p",div:"div",h2:"h2",pre:"pre",code:"code",ul:"ul",li:"li",h3:"h3"},(0,s.ah)(),e.components);return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsxs)(n.h1,{id:"rxjs",children:["rxjs",(0,l.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#rxjs",children:"#"})]}),"\n",(0,l.jsx)(n.p,{children:"v6.5.5 新增"}),"\n",(0,l.jsxs)(n.div,{className:"rspress-directive tip",children:[(0,l.jsx)(n.div,{className:"rspress-directive-title",children:"稳定性: 稳定"}),(0,l.jsx)(n.div,{className:"rspress-directive-content",children:"\n"})]}),"\n",(0,l.jsxs)(n.p,{children:["RxJS 是一个通过使用可观察序列来编写","异步","和基于事件的程序的库。 它提供了一个核心类型，可观察对象，卫星类型（观察者、调度器、主体）和受 Array 方法启发的运算符（map、filter、reduce、every 等），以允许将异步事件作为集合处理。"]}),"\n",(0,l.jsxs)(n.p,{children:["使用前请先阅读",(0,l.jsx)(n.a,{href:"https://rx.nodejs.cn/guide/overview",target:"_blank",rel:"noopener noreferrer",children:"中文文档"}),"理解概念，这里只介绍一些常用方法。"]}),"\n",(0,l.jsxs)(n.h2,{id:"例子",children:["例子",(0,l.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#例子",children:"#"})]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:'"ui";\nlet { fromEvent } = require("rxjs");\nui.layout(\n    <vertical padding="16">\n        <button id="y" text="普通按钮" w="auto" />\n        <vertical id="box"></vertical>\n    </vertical>\n);\n//从按钮的点击事件创建一个可观察对象\nlet ob = fromEvent(ui.y, "click");\nlet box = ui.box;\n//订阅这个对象\nob.subscribe(() => {\n    ui.inflate(<text text="1234"></text>, box, true);\n});\n'})}),"\n",(0,l.jsxs)(n.p,{children:["很多时候我们不希望这个按钮触发的太快，使用纯 js 就需要添加额外的变量用于判断，使用 rxjs 只需要添加一个",(0,l.jsx)(n.code,{children:"throttleTime"}),"操作符"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:'"ui";\nlet { fromEvent, throttleTime } = require("rxjs");\nui.layout(\n    <vertical padding="16">\n        <button id="y" text="普通按钮" w="auto" />\n        <vertical id="box"></vertical>\n    </vertical>\n);\n//从按钮的点击事件创建一个可观察对象\nlet ob = fromEvent(ui.y, "click").pipe(throttleTime(1000));\nlet box = ui.box;\n//订阅这个对象\nob.subscribe(() => {\n    ui.inflate(<text text="1234"></text>, box, true);\n});\n'})}),"\n",(0,l.jsx)(n.p,{children:"可以将大部分采用回调、事件、Promise 的 api 转换成 Observable"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:'//回调\nlet { bindCallback } = require("rxjs");\n\nlet httpGet = bindCallback(http.get);\n\nhttpGet("https://m.baidu.com", {}).subscribe({\n    next: (res, err) => {\n        console.log("body:", res.body.string().length);\n    },\n    complete() {\n        console.log("done");\n    },\n});\n//事件\nfromEvent(events, "exit").subscribe({\n    next() {\n        console.log("event on exit");\n    },\n});\n//Promise\nfrom(Promise.delay(1000)).subscribe({\n    next: () => {\n        console.log("Promise res");\n    },\n    complete() {\n        console.log("done");\n    },\n});\n'})}),"\n",(0,l.jsxs)(n.h2,{id:"创建操作符",children:["创建操作符",(0,l.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#创建操作符",children:"#"})]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"of(...args)"})," 将参数转换为可观察的序列。"]}),"\n"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:'let { of } = require("rxjs");\nof(10, 20, 30).subscribe({\n    next: (value) => console.log("next:", value),\n    error: (err) => console.log("error:", err),\n    complete: () => console.log("the end"),\n});\n// Outputs\n// next: 10\n// next: 20\n// next: 30\n// the end\n'})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"from(input,scheduler?)"})," 从数组、类数组对象、Promise、可迭代对象或类 Observable 对象创建 Observable。"]}),"\n"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:'let { from } = require("rxjs");\nconst array = [10, 20, 30];\nconst result = from(array);\nresult.subscribe((x) => console.log(x));\n// Logs:\n// 10\n// 20\n// 30\n'})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"fromEvent(target,eventName,options?)"})," 创建一个 Observable，它发出来自给定事件目标的特定类型的事件。"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"intervallink(period=0,period=asyncScheduler)"})," 创建一个 Observable，该 Observable 在指定的时间间隔内每隔指定的时间间隔发出序列号"]}),"\n",(0,l.jsx)(n.li,{}),"\n"]}),"\n",(0,l.jsxs)(n.h2,{id:"调度器",children:["调度器",(0,l.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#调度器",children:"#"})]}),"\n",(0,l.jsx)(n.p,{children:"rxjs 中内置了几种调度器，其中最常用的是 asyncScheduler，这是多数处理异步操作符使用的默认调度器，在 autox 环境中，只支持 asyncScheduler 调度器。"}),"\n",(0,l.jsxs)(n.h3,{id:"autox-特有的调度器",children:["autox 特有的调度器",(0,l.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#autox-特有的调度器",children:"#"})]}),"\n",(0,l.jsx)(n.p,{children:"v6.5.6 新增\n由于 autox 中存在比较复杂的多线程环境，处理 ui 和阻塞操作时经常需要切换线程，因此为此库添加了几个特殊的调度器简化这些操作\n需要使用以下方式导入"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:'let { ioScheduler, uiScheduler, mainScheduler, workScheduler, newSingleScheduler } = require("rxjs/ext");\n'})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"uiScheduler"})," 在 ui 线程中运行"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"mainScheduler"})," 在脚本主线程中运行，若是 ui 脚本则和",(0,l.jsx)(n.code,{children:"uiScheduler"}),"一致"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"newSingleScheduler()"})," ","这是一个函数","，创建一个独立的线程作为调度器，使用完毕后需要调用",(0,l.jsx)(n.code,{children:"recycle"}),"回收资源"]}),"\n"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:'let { from } = require("rxjs");\nlet { newSingleScheduler } = require("rxjs/ext");\nlet t = newSingleScheduler();\nfrom([1, 2, 3], t).subscribe({\n    next: (v) => {\n        console.log(v);\n        console.log(threads.currentThread());\n    },\n    complete() {\n        t.recycle();\n    },\n});\n'})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"workScheduler"})," 在一个默认的线程池中运行，用于处理密集计算操作。\n","注意:"," 此调度器是不安全的，由于并发问题，只能配合 fromEvent 这样永远不会'结束'的 Observable 来使用，下面这个示例就不会按预期执行"]}),"\n"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:'let { from } = require("rxjs");\nlet { workScheduler } = require("rxjs/ext");\nfrom([1, 2, 3], workScheduler).subscribe((v) => {\n    log(v); //可能看到0-3个输出，且是乱序的\n});\n'})}),"\n",(0,l.jsx)(n.p,{children:"原因在于 Observable 执行 complete 或 error 后再调用 next 产生的值将被忽略，就算 next 调用在 complete 前面，通过此调度器可能会导致 next 真正执行时在 complete 后面，此外某些操作符在这个调度器下也会工作异常。"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"ioScheduler"})," 和",(0,l.jsx)(n.code,{children:"workScheduler"}),"类似，区别在于每次触发会生成一个新线程来运行，比较耗费资源，适用于 io 操作等长时间阻塞任务"]}),"\n"]}),"\n",(0,l.jsxs)(n.h3,{id:"例子-1",children:["例子",(0,l.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#例子-1",children:"#"})]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:'"ui";\nlet { fromEvent, scan, map, observeOn, throttleTime } = require("rxjs");\nlet { ioScheduler, uiScheduler, mainScheduler, workScheduler, newSingleScheduler } = require("rxjs/ext");\nui.layout(\n    <vertical padding="16">\n        <button id="y" text="普通按钮" w="auto" />\n        <vertical id="box"></vertical>\n    </vertical>\n);\n//从按钮的点击事件创建一个可观察对象\nlet ob = fromEvent(ui.y, "click");\nlet box = ui.box;\n//订阅这个对象\nob.pipe(\n    scan((a) => a + 1, 0),\n    //转到线程池调度器\n    observeOn(workScheduler),\n    map((v) => {\n        //模拟一些阻塞耗时任务\n        sleep(1000);\n        return v;\n    }),\n    //回到ui调度器\n    observeOn(uiScheduler)\n).subscribe((v) => {\n    ui.inflate(<text text={"已计算: 第" + v + "次"}></text>, box, true);\n});\n'})})]})}function c(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(i,{...e})}):i(e)}let t=c;c.__RSPRESS_PAGE_META={},c.__RSPRESS_PAGE_META["v1%2Fnpm%E6%A8%A1%E5%9D%97%2Frxjs.md"]={toc:[{text:"例子",id:"例子",depth:2},{text:"创建操作符",id:"创建操作符",depth:2},{text:"调度器",id:"调度器",depth:2},{text:"autox 特有的调度器",id:"autox-特有的调度器",depth:3},{text:"例子",id:"例子-1",depth:3}],title:"rxjs",headingTitle:"rxjs",frontmatter:{}}}}]);