[{"id":0,"title":"介绍页面","content":"#","routePath":"/guides/introduction","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":2,"title":"","content":"","routePath":"/v1/CrewCard","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":3,"title":"","content":"","routePath":"/v1/crewList","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":4,"title":"关于本文档","content":"#\n\n文档使用 Markdown 编写，Rspress 生成。\n\n\nAPI 稳定性#\n\n由于 AutoX.js 处于活跃的更新和开发状态，API 可能随时有变动，我们用 稳定性 来标记模块、函数的稳定性。\n\n这些标记包括：\n\n稳定性: 弃用\n\n弃用的函数、模块或特性， 在未来的更新中将很快会被移除或更改。应该在脚本中移除对这些函数的使用，以免后续出现意料之外的问题。\n\n稳定性: 实验\n\n实验性的函数、模块或特性， 在未来的更新中可能会更改或移除。应该谨慎使用这些函数或模块，或者仅用作临时或试验用途。\n\n稳定性: 稳定\n\n稳定的函数、模块或特性， 在未来的更新中这些模块已有的函数一般不会被更改，会保证后向兼容性。\n\n\n如何阅读本文档#\n\n先看一个例子，下面是 基于控件的操作 的章节中 input 函数的部分说明。\n\n\ninput([i, ]text)#\n\n * i {number} 表示要输入的为第 i + 1 个输入框\n * text {string} 要输入的文本\n\ninput表示函数名，([i, ]text)表示要传入两个参数：i, text。[i, ]表示i是可选参数，即i可有可无.\n\n下方是函数说明，i表示参数名称，{number}表示参数i的类型为数值，表示要输入...是对参数i的详细说明\n\n\n\n\n\n我们再看第二个例子。图片和图色处理中 detectsColor 函数的部分说明。\n\n\nimages.detectsColor(image, color, x, y[, threshold = 16, algorithm = \"diff\"])#\n\n * image {Image} 图片\n * color {number} | {string} 要检测的颜色\n * x {number} 要检测的位置横坐标\n * y {number} 要检测的位置纵坐标\n * threshold {number} 颜色相似度临界值，默认为 16。取值范围为 0~255。\n * algorithm {string} 颜色匹配算法，包括:\n   * equal: 相等匹配，只有与给定颜色 color 完全相等时才匹配。\n   * diff: 差值匹配。与给定颜色的 R、G、B 差的绝对值之和小于 threshold 时匹配。\n   * rgb: rgb 欧拉距离相似度。与给定颜色 color 的 rgb 欧拉距离小于等于 threshold 时匹配。\n   * rgb: 加权 rgb 欧拉距离匹配(LAB Delta E)。\n   * hs: hs 欧拉距离匹配。hs 为 HSV 空间的色调值。\n\nthreshold = 16表示如果不指定该参数，则 threshold 的值为16\n\n\n\n\n\n调用有可选参数及默认值的函数时请不要写上方括号和等于号。","routePath":"/v1/documentation","lang":"","toc":[{"text":"API 稳定性","id":"api-稳定性","depth":2,"charIndex":33},{"text":"如何阅读本文档","id":"如何阅读本文档","depth":2,"charIndex":311},{"text":"input([i, ]text)","id":"inputi-text","depth":2,"charIndex":362},{"text":"images.detectsColor(image, color, x, y[, threshold = 16, algorithm = \"diff\"])","id":"imagesdetectscolorimage-color-x-y-threshold--16-algorithm--diff","depth":2,"charIndex":606}],"domain":"","frontmatter":{},"version":""},{"id":5,"title":"Buffer","content":"#\n\nv6.4.0 新增\n\n稳定性: 稳定\n\n\nnode 中 Buffer 的实现，使用文档见 node 文档，下方是 autox 中特有的内容 这个模块全局可用，因此不必\n\n\n\n\nBuffer.prototype.getBytes()#\n\n返回 buffer 内部 ArrayBuffer 所对应的 java 字节数组\n\n\n\n\nBuffer.fromBytes(byteArr)#\n\n * byteArr {[]} java 字节数组\n\n从字节数组创建一个 buffer，其内容是原数据的拷贝。","routePath":"/v1/npm模块/buffer","lang":"","toc":[{"text":"Buffer.prototype.getBytes()","id":"bufferprototypegetbytes","depth":2,"charIndex":90},{"text":"Buffer.fromBytes(byteArr)","id":"bufferfrombytesbytearr","depth":2,"charIndex":164}],"domain":"","frontmatter":{},"version":""},{"id":6,"title":"cheerio","content":"#\n\nv6.3.9 新增\n\n稳定性: 稳定\n\n\n这是一个用于解析和生成 html/xml 的库，使用方法请参阅官方网站，该模块不会自动加载，如需使用\n\n\n\n这里简单介绍一下在 autojs 中的用途。\n\n当你有一个变量，想让它的内容嵌入到 ui 界面中时你可能会这么做\n\n\n\n这 3 种方法无论哪种都有些缺陷，第一种变量不是全局的则会报错，第二种字符串不能包含特殊字符，否则解析 xml\n时报错，第三种调用安卓方法有一定的性能问题，且不够灵活。\n\n使用cheerio则可以像这样处理:\n\n\n\n高级的用法还可以将 xml 组件化，列表生成等","routePath":"/v1/npm模块/cheerio","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":7,"title":"event-stream","content":"#\n\nv6.4.0 新增\n\n稳定性: 稳定\n\n\n来自 npm 模块 event-stream，如需使用，请用\n\n\n\n该模块用于便捷的创建流，完整说明见项目主页 可读流:\n\n\n\n转换流:\n\n\n\n可写流:\n\n\n\n例子:\n\n\n\n例子 2（配合 io 流使用）:\n\n","routePath":"/v1/npm模块/event-stream","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":8,"title":"events","content":"#\n\nv6.4.0 新增\n\n稳定性: 稳定\n\n\nnode 中 events 的实现，如需使用，请用\n\n","routePath":"/v1/npm模块/events","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":9,"title":"Lodash","content":"#\n\nv6.5.2 新增\n\n稳定性: 稳定\n\n\nLodash 是一个一致性、模块化、高性能的 JavaScript 实用工具库，使用方法请参阅中文文档，该模块不会自动加载，请使用以下方法导入\n\n","routePath":"/v1/npm模块/lodash","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":10,"title":"rxjs","content":"#\n\nv6.5.5 新增\n\n稳定性: 稳定\n\n\nRxJS 是一个通过使用可观察序列来编写异步和基于事件的程序的库。 它提供了一个核心类型，可观察对象，卫星类型（观察者、调度器、主体）和受 Array\n方法启发的运算符（map、filter、reduce、every 等），以允许将异步事件作为集合处理。\n\n使用前请先阅读中文文档理解概念，这里只介绍一些常用方法。\n\n\n例子#\n\n\n\n很多时候我们不希望这个按钮触发的太快，使用纯 js 就需要添加额外的变量用于判断，使用 rxjs 只需要添加一个throttleTime操作符\n\n\n\n可以将大部分采用回调、事件、Promise 的 api 转换成 Observable\n\n\n\n\n创建操作符#\n\n * of(...args) 将参数转换为可观察的序列。\n\n\n\n * from(input,scheduler?) 从数组、类数组对象、Promise、可迭代对象或类 Observable 对象创建 Observable。\n\n\n\n * fromEvent(target,eventName,options?) 创建一个 Observable，它发出来自给定事件目标的特定类型的事件。\n * intervallink(period=0,period=asyncScheduler) 创建一个 Observable，该 Observable\n   在指定的时间间隔内每隔指定的时间间隔发出序列号\n * \n\n\n调度器#\n\nrxjs 中内置了几种调度器，其中最常用的是 asyncScheduler，这是多数处理异步操作符使用的默认调度器，在 autox 环境中，只支持\nasyncScheduler 调度器。\n\n\nautox 特有的调度器#\n\nv6.5.6 新增 由于 autox 中存在比较复杂的多线程环境，处理 ui 和阻塞操作时经常需要切换线程，因此为此库添加了几个特殊的调度器简化这些操作\n需要使用以下方式导入\n\n\n\n * uiScheduler 在 ui 线程中运行\n * mainScheduler 在脚本主线程中运行，若是 ui 脚本则和uiScheduler一致\n * newSingleScheduler() 这是一个函数，创建一个独立的线程作为调度器，使用完毕后需要调用recycle回收资源\n\n\n\n * workScheduler 在一个默认的线程池中运行，用于处理密集计算操作。 注意: 此调度器是不安全的，由于并发问题，只能配合 fromEvent\n   这样永远不会'结束'的 Observable 来使用，下面这个示例就不会按预期执行\n\n\n\n原因在于 Observable 执行 complete 或 error 后再调用 next 产生的值将被忽略，就算 next 调用在 complete\n前面，通过此调度器可能会导致 next 真正执行时在 complete 后面，此外某些操作符在这个调度器下也会工作异常。\n\n * ioScheduler 和workScheduler类似，区别在于每次触发会生成一个新线程来运行，比较耗费资源，适用于 io 操作等长时间阻塞任务\n\n\n例子#\n\n","routePath":"/v1/npm模块/rxjs","lang":"","toc":[{"text":"例子","id":"例子","depth":2,"charIndex":183},{"text":"创建操作符","id":"创建操作符","depth":2,"charIndex":312},{"text":"调度器","id":"调度器","depth":2,"charIndex":622},{"text":"autox 特有的调度器","id":"autox-特有的调度器","depth":3,"charIndex":724},{"text":"例子","id":"例子-1","depth":3,"charIndex":1320}],"domain":"","frontmatter":{},"version":""},{"id":11,"title":"stream","content":"#\n\nv6.4.0 新增\n\n稳定性: 稳定\n\n\n注意: 这个模块是异步的，使用此模块请勿阻塞线程 该模块不会自动加载，如需使用，请用\n\n\n\n使用方法参考 node 文档中 stream，下方是一些 autox 中特有的内容\n\n\nstream.fromInputStream(inputStream[,options])#\n\n * inputStream {InputStream} java 输入流\n * options {object} 选项,详细见 node 文档\n\n将 java 流转为 Readable 可读流，为提高处理速度，默认的缓冲区大小被设为 64kb，io 操作由内部 io 线程处理\n\n\nstream.fromOutputStream(outputStream[,options])#\n\n * outputStream {OutputStream} java 输出流\n * options {object} 选项,详细见 node 文档\n\n将 java 流转为 Writable 可写流，为提高处理速度，默认的缓冲区大小被设为 64kb，io 操作由内部 io 线程处理\n\n\nstream.createFileReadStream(path[,bufferSize])#\n\n * path {String} 文件路径\n * bufferSize {Number} 缓冲区大小，默认 256k\n\n从文件创建一个可读流\n\n\nstream.createFileWriteStream(path[,bufferSize])#\n\n * path {String} 文件路径\n * bufferSize {Number} 缓冲区大小，默认 256k\n\n从文件创建一个可写流","routePath":"/v1/npm模块/stream","lang":"","toc":[{"text":"stream.fromInputStream(inputStream[,options])","id":"streamfrominputstreaminputstreamoptions","depth":2,"charIndex":113},{"text":"stream.fromOutputStream(outputStream[,options])","id":"streamfromoutputstreamoutputstreamoptions","depth":2,"charIndex":303},{"text":"stream.createFileReadStream(path[,bufferSize])","id":"streamcreatefilereadstreampathbuffersize","depth":2,"charIndex":497},{"text":"stream.createFileWriteStream(path[,bufferSize])","id":"streamcreatefilewritestreampathbuffersize","depth":2,"charIndex":619}],"domain":"","frontmatter":{},"version":""},{"id":12,"title":"参与共建","content":"INFO\n\n\n船员名单#\n\n--------------------------------------------------------------------------------\n\n上船\n\n\n为魔改充电（需加入 QQ 群: 1014521824）#\n\n备注可以留下想说的话，或者反馈bug，期待的功能等等，通过船员名单进行展示\n\n充电的时候可以备注本次支持的开发者、版本或指定功能\n\n(若无备注默认为当前最新版本，且电量由当前版本开发者平分)\n\n充电信息会进行公开展示，有问题可以在QQ群反馈\n\n\n综述#\n\nNOTE\n\n我本着没事找事的原则，在 Autoxjs v6.5.8 的基础上进行魔改(2024-10-01)，并将项目命名为\nAutoxjs_v6_ozobi（Autoxx.js??）。\n\n欢迎更多开发者参与这个项目的维护与升级。\n\n这篇文档里有加密相关的内容可能和实际运行情况有冲突，我会逐步完善更新，程序代码，尽可能保持一致。\n\nAutoX.js 使用 JavaScript 作为脚本语言，目前使用 Rhino 1.7.13 作为脚本引擎，支持 ES5 与部分 ES6 特性。\n\n * 学习 AutoX.js 的 API 之前，建议先学习 JavaScript 的基本语法。\n * 如果想要在电脑上开发 AutoX.js，可以使用 VSCode 以及 AutoX.js 插件。\n * 如果想要使用 TypeScript 来开发，目前有开发者公布了一个 相关工具。\n\n\nAutoX.js 下载地址#\n\n在 Github Releases 下载\n\n\nAutoX.js 的功能#\n\n * AutoX.js 项目工程化：结合 webpack vscode 插件，开发、编译、打包、部署、混淆、加密一体化 文档资料\n * vscode 插件右键，自动提示操作等 下载地址\n * vscode 自动补全、方法注释等 文档资料\n * 修复众多 bug，升级到 5.0.1 ,合并打包插件，升级配置文件等功能\n * 建设论坛、提供 交流社区\n * 建设应用商店\n * 提供更好的 SDK 封装\n * 支持 WebSocket\n\n\n模块#\n\n本文档的章节大致上是以模块来划分的，总体上可以分成\"自动操作\"类模块（控件操作、触摸模拟、按键模拟等）和其他类模块（设备、应用、界面等）。\n\n\"自动操作\"的部分又可以大致分为 基于控件 和 基于坐标 的操作。\n\n基于坐标的操作是通过指定具体的屏幕坐标，进行点击，例如 click(100, 200)\n等，这种方式在游戏类脚本中比较有可行性，结合找图找色、坐标放缩功能也能达到较好的兼容性。但是，这种方式对于一般软件脚本不是很高效，而且需要安卓 7.0 以上或\nroot 权限才能执行。\n\n软件类脚本（例如：批量添加联系人、自动提取短信验证码等等）我们推荐采用基于控件的模拟操作，结合通知、按键等达成更好的工作流。\n\n其他模块主要包括：\n\n * app: 应用。启动应用，卸载应用，使用应用查看、编辑文件、访问网页，发送应用间广播等。\n * console: 控制台。记录运行的日志、错误、信息等。\n * device: 设备。获取设备屏幕宽高、系统版本等信息，控制设备音量、亮度等。\n * engines: 脚本引擎。用于启动其他脚本。\n * events: 事件与监听。按键监听，通知监听，触摸监听等。\n * floaty: 悬浮窗。用于显示自定义的悬浮窗。\n * files: 文件系统。文件创建、获取信息、读写。\n * http: HTTP。发送 HTTP 请求，例如 GET, POST 等。\n * websocket: websocket 客户端、服务器端，可以进行主动推送消息\n * images, colors: 图片和图色处理。截图，剪切图片，找图找色，读取保存图片等。\n * keys: 按键模拟。比如音量键、Home 键模拟等。\n * shell: Shell 命令。\n * threads: 多线程支持。\n * ui: UI 界面。用于显示自定义的 UI 界面，和用户交互。\n\n除此之外，AutoX.js 内置了对 Promise 的支持。\n\n\n参与共建#\n\n软件源码\n\n文档源码\n\n本文档更新稍有滞后，某些模块文档并没写完，希望有开发者共同参与维护！\n\n不用担心你不懂，我们可以讨论交流!\n\n欢迎大家 PR ，共同参与开源！","routePath":"/v1/overview","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":13,"title":"Q & A","content":"#\n\n\n如何定时运行脚本#\n\n点击脚本右边的菜单按钮->更多->定时任务即可定时运行脚本，但是必须保持Auto.js后台运行(自启动白名单、电源管理白名单等)。同时，可以在脚本的开头使用de\nvice.wakeUp()来唤醒屏幕；但是，Auto.js没有解锁屏幕的功能，因此难以在有锁屏密码的设备上达到效果。\n\n\n定时任务如何获取外部参数#\n\n如果一个脚本是用intent\"启动\"的，比如定时任务中的特定事件（网络状态变化等）触发而启动的，则可以通过engines.myEngine().execArgv\n.intent获取启动的intent，从而获取外部参数。\n\n\n如何把图片和脚本一起打包，或者打包多个脚本#\n\n如果除了单脚本以外还有其他脚本、图片、音乐等资源一起打包，则需要使用项目功能。\n\n点击Auto.js的\"+\"号，选择项目，填写项目名称、包名等信息以后，点击\"√\"即可新建一个项目。可以在项目中放多个脚本、模块、资源文件，点击项目工具栏的apk\n打包图标即可打包一个项目，点击工具栏可以重新配置项目。\n\n例如，主脚本要读取同一文件夹下的图片1.png，再执行找图，则可以通过images.read(\"./1.png\")来读取，其中\"./1.png\"表示同一目录1.\npng图片；ui中的图片控件要引用同一文件夹的2.png图片则为<img\nsrc=\"file://2.png\"/>。Auto.js内置的函数和模块都支持相对路径，但是，其他情况则需要使用files.path()函数来把相对路径转换为绝\n对路径。\n\n\n如何使打包的应用不显示主界面#\n\n需要使用项目功能。新建项目后，修改项目下的project.json文件，增加以下条目：\n\n\n\n例如：\n\n\n\n\"launchConfig\"表示启动配置，\"hideLogs\"表示隐藏日志。\n\n参见项目与项目配置。\n\n\nAuto.js自带的模块和函数中没有的功能如何实现#\n\n由于Auto.js支持直接调用Android的API，对于Auto.js没有内置的函数，可以直接通过修改Android代码为JavaScript代码实现。例如旋\n转图片的Android代码为：\n\n\n\n转换为JavaScript的代码后为：\n\n\n\n有关调用 Android 和 Java 的 API 的更多信息，参见 Work with Java。","routePath":"/v1/qa","lang":"","toc":[{"text":"如何定时运行脚本","id":"如何定时运行脚本","depth":2,"charIndex":3},{"text":"定时任务如何获取外部参数","id":"定时任务如何获取外部参数","depth":2,"charIndex":156},{"text":"如何把图片和脚本一起打包，或者打包多个脚本","id":"如何把图片和脚本一起打包或者打包多个脚本","depth":2,"charIndex":283},{"text":"如何使打包的应用不显示主界面","id":"如何使打包的应用不显示主界面","depth":2,"charIndex":664},{"text":"Auto.js自带的模块和函数中没有的功能如何实现","id":"autojs自带的模块和函数中没有的功能如何实现","depth":2,"charIndex":788}],"domain":"","frontmatter":{},"version":""},{"id":14,"title":"进阶: 意图Intent","content":"APP#\n\n该模块提供一系列函数，用于使用其他应用、与其他应用交互。例如发送意图、打开文件、发送邮件等。\n\n同时提供了方便的进阶函数 startActivity 和 sendBroadcast ，用他们可完成app模块没有内置的和其他应用的交互。\n\n\napp.versionCode#\n\n * return {number}\n\n当前软件版本号，整数值。例如160, 256等。\n\n如果在Auto.js中运行则为Auto.js的版本号；在打包的软件中则为打包软件的版本号。\n\n\n\n\napp.versionName#\n\n * return {string}\n\n当前软件的版本名称，例如\"3.0.0 Beta\"。\n\n如果在Auto.js中运行则为Auto.js的版本名称；在打包的软件中则为打包软件的版本名称。\n\n\n\n\napp.autojs.versionCode#\n\n * return {number}\n\nAuto.js版本号，整数值。例如160, 256等。\n\n\napp.autojs.versionName#\n\n * return {string}\n\nAuto.js版本名称，例如\"3.0.0 Beta\"。\n\n\napp.launchApp(appName)#\n\n * appName {string} 应用名称\n\n通过应用名称启动应用。如果该名称对应的应用不存在，则返回false; 否则返回true。如果该名称对应多个应用，则只启动其中某一个。\n\n该函数也可以作为全局函数使用。\n\n\n\n\napp.launch(packageName)#\n\n * packageName {string} 应用包名\n\n通过应用包名启动应用。如果该包名对应的应用不存在，则返回false；否则返回true。\n\n该函数也可以作为全局函数使用。\n\n\n\n\napp.launchPackage(packageName)#\n\n * packageName {string} 应用包名\n\n相当于app.launch(packageName)。\n\n\napp.getPackageName(appName)#\n\n * appName {string} 应用名称\n\n获取应用名称对应的已安装的应用的包名，如果该找不到该应用，返回 null 。如果该名称对应多个应用，则只返回其中某一个的包名。\n\n该函数也可以作为全局函数使用。\n\n\n\n\napp.getAppName(packageName)#\n\n * packageName {string} 应用包名\n\n获取应用包名对应的已安装的应用的名称。如果该找不到该应用，返回null。\n\n该函数也可以作为全局函数使用。\n\n\n\n\napp.openAppSetting(packageName)#\n\n * packageName {string} 应用包名\n * return {Boolean}\n\n打开应用的详情页(设置页)。如果找不到该应用，返回false; 否则返回true。\n\n该函数也可以作为全局函数使用。\n\n\napp.viewFile(path)#\n\n * path {string} 文件路径\n\n用其他应用查看文件。文件不存在的情况由查看文件的应用处理。\n\n如果找不出可以查看该文件的应用，则抛出ActivityNotException。\n\n\n\n\napp.editFile(path)#\n\n * path {string} 文件路径\n\n用其他应用编辑文件。文件不存在的情况由编辑文件的应用处理。\n\n如果找不出可以编辑该文件的应用，则抛出ActivityNotException。\n\n\n\n\napp.uninstall(packageName)#\n\n * packageName {string} 应用包名\n\n卸载应用。执行后会会弹出卸载应用的提示框。如果该包名的应用未安装，由应用卸载程序处理，可能弹出\"未找到应用\"的提示。\n\n\n\n\napp.openUrl(url)#\n\n * url {string} 网站的Url，如果不以\"http://\"或\"https://\"开头则默认是\"http://\"。\n\n用浏览器打开网站url。\n\n如果没有安装浏览器应用，则抛出ActivityNotException。\n\n\napp.sendEmail(options)#\n\n * options {Object} 发送邮件的参数。包括:\n   * email {string} | {Array} 收件人的邮件地址。如果有多个收件人，则用字符串数组表示\n   * cc {string} | {Array} 抄送收件人的邮件地址。如果有多个抄送收件人，则用字符串数组表示\n   * bcc {string} | {Array} 密送收件人的邮件地址。如果有多个密送收件人，则用字符串数组表示\n   * subject {string} 邮件主题(标题)\n   * text {string} 邮件正文\n   * attachment {string} 附件的路径。\n\n根据选项options调用邮箱应用发送邮件。这些选项均是可选的。\n\n如果没有安装邮箱应用，则抛出ActivityNotException。\n\n\n\n\napp.startActivity(name)#\n\n * name {string} 活动名称，可选的值为:\n   * console 日志界面\n   * settings 设置界面\n\n启动Auto.js的特定界面。该函数在Auto.js内运行则会打开Auto.js内的界面，在打包应用中运行则会打开打包应用的相应界面。\n\n\n\n\n进阶: 意图Intent#\n\nIntent(意图) 是一个消息传递对象，您可以使用它从其他应用组件请求操作。尽管 Intent\n可以通过多种方式促进组件之间的通信，但其基本用例主要包括以下三个：\n\n * 启动活动(Activity)： Activity\n   表示应用中的一个\"屏幕\"。例如应用主入口都是一个Activity，应用的功能通常也以Activity的形式独立，例如微信的主界面、朋友圈、聊天窗口都是不同\n   的Activity。通过将 Intent 传递给 startActivity()，您可以启动新的 Activity 实例。Intent 描述了要启动的\n   Activity，并携带了任何必要的数据。\n\n * 启动服务(Service)： Service 是一个不使用用户界面而在后台执行操作的组件。通过将 Intent 传递给\n   startService()，您可以启动服务执行一次性操作（例如，下载文件）。Intent 描述了要启动的服务，并携带了任何必要的数据。\n\n * 传递广播： 广播是任何应用均可接收的消息。系统将针对系统事件（例如：系统启动或设备开始充电时）传递各种广播。通过将 Intent 传递给\n   sendBroadcast()、sendOrderedBroadcast() 或 sendStickyBroadcast()，您可以将广播传递给其他应用。\n\n本模块提供了构建Intent的函数(app.intent()), 启动Activity的函数app.startActivity(),\n发送广播的函数app.sendBroadcast()。\n\n使用这些方法可以用来方便的调用其他应用。例如直接打开某个QQ号的个人卡片页，打开某个QQ号的聊天窗口等。\n\n\n\n\napp.intent(options)#\n\n[v4.1.0新增]\n\n * options {Object} 选项，包括：\n   \n   * action {string}\n     意图的Action，指意图要完成的动作，是一个字符串常量，比如\"android.intent.action.SEND\"。当action以\"androi\n     d.intent.action\"开头时，可以省略前缀，直接用\"SEND\"代替。参见Actions。\n   \n   * type {string} 意图的MimeType，表示和该意图直接相关的数据的类型，表示比如\"text/plain\"为纯文本类型。\n   \n   * data {string} 意图的Data，表示和该意图直接相关的数据，是一个Uri, 可以是文件路径或者Url等。例如要打开一个文件,\n     action为\"android.intent.action.VIEW\", data为\"file:///sdcard/1.txt\"。\n   \n   * category {Array} 意图的类别。比较少用。参见Categories。\n   \n   * packageName {string} 目标包名\n   \n   * className {string} 目标Activity或Service等组件的名称\n   \n   * extras {Object}\n     以键值对构成的这个Intent的Extras(额外信息)。提供该意图的其他信息，例如发送邮件时的邮件标题、邮件正文。参见Extras。\n   \n   * flags {Array} intent的标识，字符串数组，例如[\"activity_new_task\",\n     \"grant_read_uri_permission\"]。参见Flags。\n   \n   * root {Boolea} 是否以root权限启动、发送该intent。使用该参数后，不能使用`context.\n\n根据选项，构造一个意图Intent对象。\n\n例如：\n\n\n\n需要注意的是，除非应用专门暴露Activity出来，否则在没有root权限的情况下使用intent是无法跳转到特定Activity、应用的特定界面的。例如我们能\n通过Intent跳转到QQ的分享界面，是因为QQ对外暴露了分享的Activity；而在没有root权限的情况下，我们无法通过intent跳转到QQ的设置界面，因\n为QQ并没有暴露这个Activity。\n\n但如果有root权限，则在intent的参数加上\"root\": true即可。例如使用root权限跳转到Auto.js的设置界面为：\n\n\n\n另外，关于intent的参数如何获取的问题，一些intent是意外发现并且在网络中传播的（例如跳转QQ聊天窗口是因为QQ给网页提供了跳转到客服QQ的方法），如果\n要自己获取活动的intent的参数，可以通过例如\"intent记录\"，\"隐式启动\"等应用拦截内部intent或者查询暴露的intent。其中拦截内部intent\n需要XPosed框架，或者可以通过反编译等手段获取参数。总之，没有简单直接的方法。\n\n更多信息，请百度安卓Intent或参考Android指南: Intent。\n\n\napp.startActivity(options)#\n\n * options {Object} 选项\n\n根据选项构造一个Intent，并启动该Activity。\n\n\n\n\napp.sendBroadcast(options)#\n\n * options {Object} 选项\n\n根据选项构造一个Intent，并发送该广播。\n\n\napp.startService(options)#\n\n * options {Object} 选项\n\n根据选项构造一个Intent，并启动该服务。\n\n\napp.sendBroadcast(name)#\n\n[v4.1.0新增]\n\n * name {string} 特定的广播名称，包括：\n   * inspect_layout_hierarchy 布局层次分析\n   * inspect_layout_bounds 布局范围\n\n发送以上特定名称的广播可以触发Auto.js的布局分析，方便脚本调试。这些广播在Auto.js发送才有效，在打包的脚本上运行将没有任何效果。\n\n\n\n\napp.intentToShell(options)#\n\n[v4.1.0新增]\n\n * options {Object} 选项\n\n根据选项构造一个Intent，转换为对应的shell的intent命令的参数。\n\n例如:\n\n\n\n参见intent参数的规范。\n\n\napp.parseUri(uri)#\n\n[v4.1.0新增]\n\n * uri {string} 一个代表Uri的字符串，例如\"file:///sdcard/1.txt\", \"https://www.autojs.org\"\n * return {Uri} 一个代表Uri的对象，参见android.net.Uri。\n\n解析uri字符串并返回相应的Uri对象。即使Uri格式错误，该函数也会返回一个Uri对象，但之后如果访问该对象的scheme,\npath等值可能因解析失败而返回null。\n\n需要注意的是，在高版本Android上，由于系统限制直接在Uri暴露文件的绝对路径，因此如果uri字符串是文件file://...，返回的Uri会是诸如cont\nent://...的形式。\n\n\napp.getUriForFile(path)#\n\n[v4.1.0新增]\n\n * path {string} 文件路径，例如\"/sdcard/1.txt\"\n * return {Uri} 一个指向该文件的Uri的对象，参见android.net.Uri。\n\n从一个文件路径创建一个uri对象。需要注意的是，在高版本Android上，由于系统限制直接在Uri暴露文件的绝对路径，因此返回的Uri会是诸如content:/\n/...的形式。","routePath":"/v1/基础/app","lang":"","toc":[{"text":"app.versionCode","id":"appversioncode","depth":2,"charIndex":125},{"text":"app.versionName","id":"appversionname","depth":2,"charIndex":239},{"text":"app.autojs.versionCode","id":"appautojsversioncode","depth":2,"charIndex":356},{"text":"app.autojs.versionName","id":"appautojsversionname","depth":2,"charIndex":431},{"text":"app.launchApp(appName)","id":"applaunchappappname","depth":2,"charIndex":506},{"text":"app.launch(packageName)","id":"applaunchpackagename","depth":2,"charIndex":645},{"text":"app.launchPackage(packageName)","id":"applaunchpackagepackagename","depth":2,"charIndex":766},{"text":"app.getPackageName(appName)","id":"appgetpackagenameappname","depth":2,"charIndex":859},{"text":"app.getAppName(packageName)","id":"appgetappnamepackagename","depth":2,"charIndex":1000},{"text":"app.openAppSetting(packageName)","id":"appopenappsettingpackagename","depth":2,"charIndex":1118},{"text":"app.viewFile(path)","id":"appviewfilepath","depth":2,"charIndex":1263},{"text":"app.editFile(path)","id":"appeditfilepath","depth":2,"charIndex":1383},{"text":"app.uninstall(packageName)","id":"appuninstallpackagename","depth":2,"charIndex":1503},{"text":"app.openUrl(url)","id":"appopenurlurl","depth":2,"charIndex":1625},{"text":"app.sendEmail(options)","id":"appsendemailoptions","depth":2,"charIndex":1762},{"text":"app.startActivity(name)","id":"appstartactivityname","depth":2,"charIndex":2158},{"text":"app.intent(options)","id":"appintentoptions","depth":2,"charIndex":3079},{"text":"app.startActivity(options)","id":"appstartactivityoptions","depth":2,"charIndex":4463},{"text":"app.sendBroadcast(options)","id":"appsendbroadcastoptions","depth":2,"charIndex":4549},{"text":"app.startService(options)","id":"appstartserviceoptions","depth":2,"charIndex":4627},{"text":"app.sendBroadcast(name)","id":"appsendbroadcastname","depth":2,"charIndex":4704},{"text":"app.intentToShell(options)","id":"appintenttoshelloptions","depth":2,"charIndex":4916},{"text":"app.parseUri(uri)","id":"appparseuriuri","depth":2,"charIndex":5046},{"text":"app.getUriForFile(path)","id":"appgeturiforfilepath","depth":2,"charIndex":5388}],"domain":"","frontmatter":{},"version":""},{"id":15,"title":"Console","content":"#\n\n稳定性: 稳定\n\n\n控制台模块提供了一个和 Web 浏览器中相似的用于调试的控制台。用于输出一些调试信息、中间结果等。 console\n模块中的一些函数也可以直接作为全局函数使用，例如 log, print 等。\n\n\nconsole.show(autoHide)#\n\n * autoHide {boolean} 是否自动隐藏，默认 false 当程序结束的时候是否自动隐藏控制\n   显示控制台。这会显示一个控制台的悬浮窗(需要悬浮窗权限)。\n\n\n\n\nconsole.hide()#\n\n隐藏控制台悬浮窗。\n\n\nconsole.clear()#\n\n清空控制台。\n\n\nconsole.log([data][, ...args])#\n\n * data {any}\n * ...args {any}\n\n打印到控制台，并带上换行符。 可以传入多个参数，第一个参数作为主要信息，其他参数作为类似于 printf(3) 中的代替值（参数都会传给\nutil.format()）。\n\n\n\n详见 util.format()。\n\n该函数也可以作为全局函数使用。\n\n\nconsole.verbose([data][, ...args])#\n\n * data {any}\n * ...args {any}\n\n与 console.log 类似，但输出结果以灰色字体显示。输出优先级低于 log，用于输出观察性质的信息。\n\n\nconsole.info([data][, ...args])#\n\n * data {any}\n * ...args {any}\n\n与 console.log 类似，但输出结果以绿色字体显示。输出优先级高于 log, 用于输出重要信息。\n\n\nconsole.warn([data][, ...args])#\n\n * data {any}\n * ...args {any}\n\n与 console.log 类似，但输出结果以蓝色字体显示。输出优先级高于 info, 用于输出警告信息。\n\n\nconsole.error([data][, ...args])#\n\n * data {any}\n * ...args {any}\n\n与 console.log 类似，但输出结果以红色字体显示。输出优先级高于 warn, 用于输出错误信息。\n\n\nconsole.assert(value, message)#\n\n * value {any} 要断言的布尔值\n * message {string} value 为 false 时要输出的信息\n\n断言。如果 value 为 false 则输出错误信息 message 并停止脚本运行。\n\n\n\n\nconsole.time([label])#\n\n[v4.1.0 新增]\n\n * label {String} 计时器标签，可省略\n\n启动一个计时器，用以计算一个操作的持续时间。 计时器由一个唯一的 label 标识。 若label重复，则会覆盖上一个同名label的计时器。 以同名\nlabel调用 console.timeEnd() 来停止计时器，并以毫秒为单位将持续时间输出到控制台。\n\n\nconsole.timeEnd(label)#\n\n[v4.1.0 新增]\n\n * label {String} 计时器标签\n\n停止之前通过调用 console.time() 启动的定时器，并打印结果到控制台。 调用 console.timeEnd()\n后定时器会被删除。如果不存在标签指定的定时器则会打印 NaNms。\n\n\n\n\nconsole.trace([data][, ...args])#\n\n[v4.1.0 新增]\n\n * data {any}\n * ...args {any}\n\n与 console.log 类似，同时会打印出调用这个函数所在的调用栈信息（即当前运行的文件、行数等信息）。\n\n\n\n\nconsole.input(data[, ...args])#\n\n * data {any}\n * ...args {any}\n\n与console.log一样输出信息，并在控制台显示输入框等待输入。按控制台的确认按钮后会将输入的字符串用eval计算后返回。\n\n部分机型可能会有控制台不显示输入框的情况，属于 bug。\n\n例如：\n\n\n\n\nconsole.rawInput(data[, ...args])#\n\n * data {any}\n * ...args {any}\n\n与 console.log 一样输出信息，并在控制台显示输入框等待输入。按控制台的确认按钮后会将输入的字符串直接返回。\n\n部分机型可能会有控制台不显示输入框的情况，属于 bug。\n\n例如：\n\n\n\n\nconsole.setSize(w, h)#\n\n * w {number} 宽度\n * h {number} 高度\n\n设置控制台的大小，单位像素。\n\n\n\n\nconsole.setPosition(x, y)#\n\n * x {number} 横坐标\n * y {number} 纵坐标\n\n设置控制台的位置，单位像素。\n\n\n\n\nconsole.setGlobalLogConfig(config)#\n\n[v4.1.0 新增]\n\n * config {Object} 日志配置，可选的项有：\n   * file {string} 日志文件路径，将会把日志写入该文件中\n   * maxFileSize {number} 最大文件大小，单位字节，默认为 512 * 1024 (512KB)\n   * rootLevel {string} 写入的日志级别，默认为\"ALL\"（所有日志），可以为\"OFF\"(关闭), \"DEBUG\", \"INFO\",\n     \"WARN\", \"ERROR\", \"FATAL\"等。\n   * maxBackupSize {number} 日志备份文件最大数量，默认为 5\n   * filePattern {string} 日志写入格式，参见PatternLayout\n\n设置日志保存的路径和配置。例如把日志保存到\"/sdcard/1.txt\":\n\n\n\n\nprint(text)#\n\n * text {string} | {Object} 要打印到控制台的信息\n\n相当于log(text)。\n\n\nconsole.setTitle(title,color,size)#\n\n[v4.2.5 新增]\n\n * title {string} 标题\n * color {string} 颜色值 #AARRGGBB\n * size {number} 标题高度，字号会随高度变化，单位是 dp\n\n设置标题名称，字体颜色，标题栏高度\n\n\n\n\nconsole.setLogSize(size)#\n\n[v4.2.5 新增]\n\n * size {number} 字号大小，单位是 dp 或 sp 20 以内比较合适\n   \n   设置 log 字号大小\n\n需要在显示控制台之后才能设置，否则空指针\n\n\n\n\nconsole.setCanInput(can)#\n\n[v4.2.5 新增]\n\n * can {boolean} true 或 false 可以输入或不可以输入\n\n控制 console 是否可以输入文字\n\n\n\n\nconsole.setBackgroud(color)#\n\n[v4.2.5 新增]\n\n * color {string} 颜色值 #AARRGGBB\n\n设置 console 背景色,需要在显示控制台之后才能设置，否则空指针\n\n\n\n\nconsole.setMaxLines(maxLines);#\n\n[v5.0.2 新增]\n\n * maxLines {number} 最大行数 如 10 行 设置 console 显示最大行数，默认-1，不限 ，超出行数系统会清空，从 0 开始显示\n   不限制，显示列表过长，android 内存又不足，系统会回收 console 的引用，即 console 将不显示。\n\n\n\n\nconsole.setBackground()#","routePath":"/v1/基础/console","lang":"","toc":[{"text":"console.show(autoHide)","id":"consoleshowautohide","depth":2,"charIndex":111},{"text":"console.hide()","id":"consolehide","depth":2,"charIndex":228},{"text":"console.clear()","id":"consoleclear","depth":2,"charIndex":257},{"text":"console.log([data][, ...args])","id":"consolelogdata-args","depth":2,"charIndex":284},{"text":"console.verbose([data][, ...args])","id":"consoleverbosedata-args","depth":2,"charIndex":474},{"text":"console.info([data][, ...args])","id":"consoleinfodata-args","depth":2,"charIndex":600},{"text":"console.warn([data][, ...args])","id":"consolewarndata-args","depth":2,"charIndex":721},{"text":"console.error([data][, ...args])","id":"consoleerrordata-args","depth":2,"charIndex":843},{"text":"console.assert(value, message)","id":"consoleassertvalue-message","depth":2,"charIndex":966},{"text":"console.time([label])","id":"consoletimelabel","depth":2,"charIndex":1114},{"text":"console.timeEnd(label)","id":"consoletimeendlabel","depth":2,"charIndex":1311},{"text":"console.trace([data][, ...args])","id":"consoletracedata-args","depth":2,"charIndex":1475},{"text":"console.input(data[, ...args])","id":"consoleinputdata-args","depth":2,"charIndex":1614},{"text":"console.rawInput(data[, ...args])","id":"consolerawinputdata-args","depth":2,"charIndex":1782},{"text":"console.setSize(w, h)","id":"consolesetsizew-h","depth":2,"charIndex":1949},{"text":"console.setPosition(x, y)","id":"consolesetpositionx-y","depth":2,"charIndex":2027},{"text":"console.setGlobalLogConfig(config)","id":"consolesetgloballogconfigconfig","depth":2,"charIndex":2111},{"text":"print(text)","id":"printtext","depth":2,"charIndex":2538},{"text":"console.setTitle(title,color,size)","id":"consolesettitletitlecolorsize","depth":2,"charIndex":2608},{"text":"console.setLogSize(size)","id":"consolesetlogsizesize","depth":2,"charIndex":2772},{"text":"console.setCanInput(can)","id":"consolesetcaninputcan","depth":2,"charIndex":2901},{"text":"console.setBackgroud(color)","id":"consolesetbackgroudcolor","depth":2,"charIndex":3007},{"text":"console.setMaxLines(maxLines);","id":"consolesetmaxlinesmaxlines","depth":2,"charIndex":3123},{"text":"console.setBackground()","id":"consolesetbackground","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":16,"title":"基于坐标的触摸模拟","content":"#\n\n稳定性: 稳定\n\n\n本章节介绍了一些使用坐标进行点击、滑动的函数。这些函数有的需要安卓 7.0 以上，有的需要 root 权限。\n\n要获取要点击的位置的坐标，可以在开发者选项中开启\"指针位置\"。\n\n基于坐标的脚本通常会有分辨率的问题，这时可以通过setScreenMetrics()函数来进行自动坐标放缩。这个函数会影响本章节的所有点击、长按、滑动等函数。通\n过设定脚本设计时的分辨率，使得脚本在其他分辨率下自动放缩坐标。\n\n控件和坐标也可以相互结合。一些控件是无法点击的(clickable 为 false), 无法通过.click()函数来点击，这时如果安卓版本在 7.0\n以上或者有 root 权限，就可以通过以下方式来点击：\n\n","routePath":"/v1/基础/coordinatesBasedAutomation/about","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":17,"title":"RootAutomator","content":"#\n\n稳定性: 稳定\n\n\nRootAutomator 是一个使用 root 权限来模拟触摸的对象，用它可以完成触摸与多点触摸，并且这些动作的执行没有延迟。\n\n一个脚本中最好只存在一个 RootAutomator，并且保证脚本结束退出他。可以在 exit 事件中退出 RootAutomator，例如：\n\n\n\n注意以下命令需要 root 权限\n\n\nRootAutomator.tap(x, y[, id])#\n\n * x {number} 横坐标\n * y {number} 纵坐标\n * id {number} 多点触摸 id，可选，默认为 1，可以通过 setDefaultId 指定。\n\n点击位置(x, y)。其中 id 是一个整数值，用于区分多点触摸，不同的 id 表示不同的\"手指\"，例如：\n\n\n\n如果不需要多点触摸，则不需要 id 这个参数。 多点触摸通常用于手势或游戏操作，例如模拟双指捏合、双指上滑等。\n\n某些情况下可能存在 tap 点击无反应的情况，这时可以用RootAutomator.press()函数代替。\n\n\nRootAutomator.swipe(x1, x2, y1, y2[, duration, id])#\n\n * x1 {number} 滑动起点横坐标\n * y1 {number} 滑动起点纵坐标\n * x2 {number} 滑动终点横坐标\n * y2 {number} 滑动终点纵坐标\n * duration {number} 滑动时长，单位毫秒，默认值为 300\n * id {number} 多点触摸 id，可选，默认为 1\n\n模拟一次从(x1, y1)到(x2, y2)的时间为 duration 毫秒的滑动。\n\n\nRootAutomator.press(x, y, duration[, id])#\n\n * x {number} 横坐标\n * y {number} 纵坐标\n * duration {number} 按下时长\n * id {number} 多点触摸 id，可选，默认为 1\n\n模拟按下位置(x, y)，时长为 duration 毫秒。\n\n\nRootAutomator.longPress(x, y[, id])#\n\n * x {number} 横坐标\n * y {number} 纵坐标\n * duration {number} 按下时长\n * id {number} 多点触摸 id，可选，默认为 1\n\n模拟长按位置(x, y)。\n\n以上为简单模拟触摸操作的函数。如果要模拟一些复杂的手势，需要更底层的函数。\n\n\nRootAutomator.touchDown(x, y[, id])#\n\n * x {number} 横坐标\n * y {number} 纵坐标\n * id {number} 多点触摸 id，可选，默认为 1\n\n模拟手指按下位置(x, y)。\n\n\nRootAutomator.touchMove(x, y[, id])#\n\n * x {number} 横坐标\n * y {number} 纵坐标\n * id {number} 多点触摸 id，可选，默认为 1\n\n模拟移动手指到位置(x, y)。\n\n\nRootAutomator.touchUp([id])#\n\n * id {number} 多点触摸 id，可选，默认为 1\n\n模拟手指弹起。","routePath":"/v1/基础/coordinatesBasedAutomation/rootAutomator","lang":"","toc":[{"text":"RootAutomator.tap(x, y[, id])","id":"rootautomatortapx-y-id","depth":2,"charIndex":172},{"text":"RootAutomator.swipe(x1, x2, y1, y2[, duration, id])","id":"rootautomatorswipex1-x2-y1-y2-duration-id","depth":2,"charIndex":466},{"text":"RootAutomator.press(x, y, duration[, id])","id":"rootautomatorpressx-y-duration-id","depth":2,"charIndex":730},{"text":"RootAutomator.longPress(x, y[, id])","id":"rootautomatorlongpressx-y-id","depth":2,"charIndex":901},{"text":"RootAutomator.touchDown(x, y[, id])","id":"rootautomatortouchdownx-y-id","depth":2,"charIndex":1089},{"text":"RootAutomator.touchMove(x, y[, id])","id":"rootautomatortouchmovex-y-id","depth":2,"charIndex":1214},{"text":"RootAutomator.touchUp([id])","id":"rootautomatortouchupid","depth":2,"charIndex":1340}],"domain":"","frontmatter":{},"version":""},{"id":18,"title":"","content":"setScreenMetrics(width, height)#\n\n * width {number} 屏幕宽度，单位像素\n * height {number} 屏幕高度，单位像素\n\n设置脚本坐标点击所适合的屏幕宽高。如果脚本运行时，屏幕宽度不一致会自动放缩坐标。\n\n例如在 1920*1080 的设备中，某个操作的代码为\n\n\n\n那么在其他设备上 AutoJs 会自动放缩坐标以便脚本仍然有效。例如在 540 * 960 的屏幕中click(800, 200)实际上会点击位置(400,\n100)。","routePath":"/v1/基础/coordinatesBasedAutomation/setScreenMetrics","lang":"","toc":[{"text":"setScreenMetrics(width, height)","id":"setscreenmetricswidth-height","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":19,"title":"使用 root 权限点击和滑动的简单命令","content":"#\n\n稳定性: 实验\n\n\n注意：本章节的函数在后续版本很可能有改动！请勿过分依赖本章节函数的副作用。推荐使用RootAutomator代替本章节的触摸函数。\n\n以下函数均需要 root 权限，可以实现任意位置的点击、滑动等。\n\n * 这些函数通常首字母大写以表示其特殊的权限。\n * 这些函数均不返回任何值。\n * 并且，这些函数的执行是异步的、非阻塞的，在不同机型上所用的时间不同。脚本不会等待动作执行完成才继续执行。因此最好在每个函数之后加上适当的 sleep\n   来达到期望的效果。\n\n例如:\n\n\n\n注意，动作的执行可能无法被停止，例如：\n\n\n\n这段代码执行后可能会出现在任务管理中停止脚本后点击仍然继续的情况。 因此，强烈建议在每个动作后加上延时：\n\n\n\n\nTap(x, y)#\n\n * x, y {number} 要点击的坐标。\n\n点击位置(x, y), 您可以通过\"开发者选项\"开启指针位置来确定点击坐标。\n\n\nSwipe(x1, y1, x2, y2, [duration])#\n\n * x1, y1 {number} 滑动起点的坐标\n * x2, y2 {number} 滑动终点的坐标\n * duration {number} 滑动动作所用的时间\n\n滑动。从(x1, y1)位置滑动到(x2, y2)位置。","routePath":"/v1/基础/coordinatesBasedAutomation/simpleRootApi","lang":"","toc":[{"text":"Tap(x, y)","id":"tapx-y","depth":2,"charIndex":333},{"text":"Swipe(x1, y1, x2, y2, [duration])","id":"swipex1-y1-x2-y2-duration","depth":2,"charIndex":412}],"domain":"","frontmatter":{},"version":""},{"id":20,"title":"安卓 7.0 以上的触摸和手势模拟","content":"#\n\n稳定性: 稳定\n\n\n注意以下命令只有 Android7.0 及以上才有效\n\n\nclick(x, y)#\n\n * x {number} 要点击的坐标的 x 值\n * y {number} 要点击的坐标的 y 值\n\n模拟点击坐标(x, y)，并返回是否点击成功。只有在点击执行完成后脚本才继续执行。\n\n一般而言，只有点击过程(大约 150 毫秒)中被其他事件中断(例如用户自行点击)才会点击失败。\n\n使用该函数模拟连续点击时可能有点击速度过慢的问题，这时可以用press()函数代替。\n\n\nlongClick(x, y)#\n\n * x {number} 要长按的坐标的 x 值\n * y {number} 要长按的坐标的 y 值\n\n模拟长按坐标(x, y), 并返回是否成功。只有在长按执行完成（大约 600 毫秒）时脚本才会继续执行。\n\n一般而言，只有长按过程中被其他事件中断(例如用户自行点击)才会长按失败。\n\n\npress(x, y, duration)#\n\n * x {number} 要按住的坐标的 x 值\n * y {number} 要按住的坐标的 y 值\n * duration {number} 按住时长，单位毫秒\n\n模拟按住坐标(x, y), 并返回是否成功。只有按住操作执行完成时脚本才会继续执行。\n\n如果按住时间过短，那么会被系统认为是点击；如果时长超过 500 毫秒，则认为是长按。\n\n一般而言，只有按住过程中被其他事件中断才会操作失败。\n\n一个连点器的例子如下：\n\n\n\n\nswipe(x1, y1, x2, y2, duration)#\n\n * x1 {number} 滑动的起始坐标的 x 值\n * y1 {number} 滑动的起始坐标的 y 值\n * x2 {number} 滑动的结束坐标的 x 值\n * y2 {number} 滑动的结束坐标的 y 值\n * duration {number} 滑动时长，单位毫秒\n\n模拟从坐标(x1, y1)滑动到坐标(x2, y2)，并返回是否成功。只有滑动操作执行完成时脚本才会继续执行。\n\n一般而言，只有滑动过程中被其他事件中断才会滑动失败。\n\n\ngesture(duration, [x1, y1], [x2, y2], ...)#\n\n * duration {number} 手势的时长\n * [x, y] ... 手势滑动路径的一系列坐标\n\n模拟手势操作。例如gesture(1000, [0, 0], [500, 500], [500, 1000])为模拟一个从(0, 0)到(500,\n500)到(500, 100)的手势操作，时长为 2 秒。\n\n\ngestures([delay1, duration1, [x1, y1], [x2, y2], ...], [delay2, duration2, [x3,\ny3], [x4, y4], ...], ...)#\n\n同时模拟多个手势。每个手势的参数为[delay, duration, 坐标], delay 为延迟多久(毫秒)才执行该手势；duration\n为手势执行时长；坐标为手势经过的点的坐标。其中 delay 参数可以省略，默认为 0。\n\n例如手指捏合：\n\n","routePath":"/v1/基础/coordinatesBasedAutomation/touchAndGestureSimulation","lang":"","toc":[{"text":"click(x, y)","id":"clickx-y","depth":2,"charIndex":41},{"text":"longClick(x, y)","id":"longclickx-y","depth":2,"charIndex":245},{"text":"press(x, y, duration)","id":"pressx-y-duration","depth":2,"charIndex":409},{"text":"swipe(x1, y1, x2, y2, duration)","id":"swipex1-y1-x2-y2-duration","depth":2,"charIndex":649},{"text":"gesture(duration, [x1, y1], [x2, y2], ...)","id":"gestureduration-x1-y1-x2-y2-","depth":2,"charIndex":913},{"text":"gestures([delay1, duration1, [x1, y1], [x2, y2], ...], [delay2, duration2, [x3, y3], [x4, y4], ...], ...)","id":"gesturesdelay1-duration1-x1-y1-x2-y2--delay2-duration2-x3-y3-x4-y4--","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":21,"title":"Device","content":"#\n\n稳定性: 稳定\n\n\ndevice 模块提供了与设备有关的信息与操作，例如获取设备宽高，内存使用率，IMEI，调整设备亮度、音量等。\n\n此模块的部分函数，例如调整音量，需要\"修改系统设置\"的权限。如果没有该权限，会抛出SecurityException并跳转到权限设置界面。\n\n\ndevice.width#\n\n * {number}\n\n设备屏幕分辨率宽度。例如 1080。\n\n\ndevice.height#\n\n * {number}\n\n设备屏幕分辨率高度。例如 1920。\n\n\ndevice.buildId#\n\n * {string}\n\nEither a changelist number, or a label like \"M4-rc20\".\n\n修订版本号，或者诸如\"M4-rc20\"的标识。\n\n\ndevice.broad#\n\n * {string}\n\nThe name of the underlying board, like \"goldfish\".\n\n设备的主板(?)型号。\n\n\ndevice.brand#\n\n * {string}\n\nThe consumer-visible brand with which the product/hardware will be associated,\nif any.\n\n与产品或硬件相关的厂商品牌，如\"Xiaomi\", \"Huawei\"等。\n\n\ndevice.device#\n\n * {string}\n\nThe name of the industrial design.\n\n设备在工业设计中的名称。\n\n\ndevice.model#\n\n * {string}\n\nThe end-user-visible name for the end product.\n\n设备型号。\n\n\ndevice.product#\n\n * {string}\n\nThe name of the overall product.\n\n整个产品的名称。\n\n\ndevice.bootloader#\n\n * {string}\n\nThe system bootloader version number.\n\n设备 Bootloader 的版本。\n\n\ndevice.hardware#\n\n * {string}\n\nThe name of the hardware (from the kernel command line or /proc).\n\n设备的硬件名称(来自内核命令行或者/proc)。\n\n\ndevice.fingerprint#\n\n * {string}\n\nA string that uniquely identifies this build. Do not attempt to parse this\nvalue.\n\n构建(build)的唯一标识码。\n\n\ndevice.serial#\n\n * {string}\n\nA hardware serial number, if available. Alphanumeric only, case-insensitive.\n\n硬件序列号。\n\n\ndevice.sdkInt#\n\n * {number}\n\nThe user-visible SDK version of the framework; its possible values are defined\nin Build.VERSION_CODES.\n\n安卓系统 API 版本。例如安卓 4.4 的 sdkInt 为 19。\n\n\ndevice.incremental#\n\n * {string}\n\nThe internal value used by the underlying source control to represent this\nbuild. E.g., a perforce changelist number or a git hash.\n\n\ndevice.release#\n\n * {string}\n\nThe user-visible version string. E.g., \"1.0\" or \"3.4b5\".\n\nAndroid 系统版本号。例如\"5.0\", \"7.1.1\"。\n\n\ndevice.baseOS#\n\n * {string}\n\nThe base OS build the product is based on.\n\n\ndevice.securityPatch#\n\n * {string}\n\nThe user-visible security patch level.\n\n安全补丁程序级别。\n\n\ndevice.codename#\n\n * {string}\n\nThe current development codename, or the string \"REL\" if this is a release\nbuild.\n\n开发代号，例如发行版是\"REL\"。\n\n\ndevice.getIMEI()#\n\n * {string}\n\n返回设备的 IMEI.\n\n\ndevice.getAndroidId()#\n\n * {string}\n\n返回设备的 Android ID。\n\nAndroid ID 为一个用 16 进制字符串表示的 64 位整数，在设备第一次使用时随机生成，之后不会更改，除非恢复出厂设置。\n\n\ndevice.getMacAddress()#\n\n * {string}\n\n返回设备的 Mac 地址。该函数需要在有 WLAN 连接的情况下才能获取，否则会返回 null。\n\n可能的后续修改：未来可能增加有 root 权限的情况下通过 root 权限获取，从而在没有 WLAN 连接的情况下也能返回正确的 Mac\n地址，因此请勿使用此函数判断 WLAN 连接。\n\n\ndevice.getBrightness()#\n\n * {number}\n\n返回当前的(手动)亮度。范围为 0~255。\n\n\ndevice.getBrightnessMode()#\n\n * {number}\n\n返回当前亮度模式，0 为手动亮度，1 为自动亮度。\n\n\ndevice.setBrightness(b)#\n\n * b {number} 亮度，范围 0~255\n\n设置当前手动亮度。如果当前是自动亮度模式，该函数不会影响屏幕的亮度。\n\n此函数需要\"修改系统设置\"的权限。如果没有该权限，会抛出 SecurityException 并跳转到权限设置界面。\n\n\ndevice.setBrightnessMode(mode)#\n\n * mode {number} 亮度模式，0 为手动亮度，1 为自动亮度\n\n设置当前亮度模式。\n\n此函数需要\"修改系统设置\"的权限。如果没有该权限，会抛出 SecurityException 并跳转到权限设置界面。\n\n\ndevice.getMusicVolume()#\n\n * {number} 整数值\n\n返回当前媒体音量。\n\n\ndevice.getNotificationVolume()#\n\n * {number} 整数值\n\n返回当前通知音量。\n\n\ndevice.getAlarmVolume()#\n\n * {number} 整数值\n\n返回当前闹钟音量。\n\n\ndevice.getMusicMaxVolume()#\n\n * {number} 整数值\n\n返回媒体音量的最大值。\n\n\ndevice.getNotificationMaxVolume()#\n\n * {number} 整数值\n\n返回通知音量的最大值。\n\n\ndevice.getAlarmMaxVolume()#\n\n * {number} 整数值\n\n返回闹钟音量的最大值。\n\n\ndevice.setMusicVolume(volume)#\n\n * volume {number} 音量\n\n设置当前媒体音量。\n\n此函数需要\"修改系统设置\"的权限。如果没有该权限，会抛出 SecurityException 并跳转到权限设置界面。\n\n\ndevice.setNotificationVolume(volume)#\n\n * volume {number} 音量\n\n设置当前通知音量。\n\n此函数需要\"修改系统设置\"的权限。如果没有该权限，会抛出 SecurityException 并跳转到权限设置界面。\n\n\ndevice.setAlarmVolume(volume)#\n\n * volume {number} 音量\n\n设置当前闹钟音量。\n\n此函数需要\"修改系统设置\"的权限。如果没有该权限，会抛出 SecurityException 并跳转到权限设置界面。\n\n\ndevice.getBattery()#\n\n * {number} 0.0~100.0 的浮点数\n\n返回当前电量百分比。\n\n\ndevice.isCharging()#\n\n * {boolean}\n\n返回设备是否正在充电。\n\n\ndevice.getTotalMem()#\n\n * {number}\n\n返回设备内存总量，单位字节(B)。1MB = 1024 * 1024B。\n\n\ndevice.getAvailMem()#\n\n * {number}\n\n返回设备当前可用的内存，单位字节(B)。\n\n\ndevice.isScreenOn()#\n\n * 返回 {boolean}\n\n返回设备屏幕是否是亮着的。如果屏幕亮着，返回true; 否则返回false。\n\n需要注意的是，类似于 vivo xplay\n系列的息屏时钟不属于\"屏幕亮着\"的情况，虽然屏幕确实亮着但只能显示时钟而且不可交互，此时isScreenOn()也会返回false。\n\n\ndevice.wakeUp()#\n\n唤醒设备。包括唤醒设备 CPU、屏幕等。可以用来点亮屏幕。\n\n\ndevice.wakeUpIfNeeded()#\n\n如果屏幕没有点亮，则唤醒设备。\n\n\ndevice.keepScreenOn([timeout])#\n\n * timeout {number} 屏幕保持常亮的时间, 单位毫秒。如果不加此参数，则一直保持屏幕常亮。\n\n保持屏幕常亮。\n\n此函数无法阻止用户使用锁屏键等正常关闭屏幕，只能使得设备在无人操作的情况下保持屏幕常亮；同时，如果此函数调用时屏幕没有点亮，则会唤醒屏幕。\n\n在某些设备上，如果不加参数 timeout，只能在 Auto.js\n的界面保持屏幕常亮，在其他界面会自动失效，这是因为设备的省电策略造成的。因此，建议使用比较长的时长来代替\"一直保持屏幕常亮\"的功能，例如device.keepS\ncreenOn(3600 * 1000)。\n\n可以使用device.cancelKeepingAwake()来取消屏幕常亮。\n\n\n\n\ndevice.keepScreenDim([timeout])#\n\n * timeout {number} 屏幕保持常亮的时间, 单位毫秒。如果不加此参数，则一直保持屏幕常亮。\n\n保持屏幕常亮，但允许屏幕变暗来节省电量。此函数可以用于定时脚本唤醒屏幕操作，不需要用户观看屏幕，可以让屏幕变暗来节省电量。\n\n此函数无法阻止用户使用锁屏键等正常关闭屏幕，只能使得设备在无人操作的情况下保持屏幕常亮；同时，如果此函数调用时屏幕没有点亮，则会唤醒屏幕。\n\n可以使用device.cancelKeepingAwake()来取消屏幕常亮。\n\n\ndevice.cancelKeepingAwake()#\n\n取消设备保持唤醒状态。用于取消device.keepScreenOn(), device.keepScreenDim()等函数设置的屏幕常亮。\n\n\ndevice.vibrate(millis)#\n\n * millis {number} 震动时间，单位毫秒\n\n使设备震动一段时间。\n\n\n\n\ndevice.cancelVibration()#\n\n[v4.2.7 新增] 如果设备处于震动状态，则取消震动。\n\n\ndevice.checkDeviceHasNavigationBar()#\n\n[v4.2.7 新增]\n\n * {boolean} 返回 true|false 设备是否存储虚拟导航栏\n\n\ndevice.getVirtualBarHeigh();#\n\n[v4.2.7 新增]\n\n * {number} 返回导航栏的高度 设备虚拟导航栏的高度,可以用设备高度 减去 这个高度，再按一定比例 点击底部附件的坐标","routePath":"/v1/基础/device","lang":"","toc":[{"text":"device.width","id":"devicewidth","depth":2,"charIndex":141},{"text":"device.height","id":"deviceheight","depth":2,"charIndex":190},{"text":"device.buildId","id":"devicebuildid","depth":2,"charIndex":240},{"text":"device.broad","id":"devicebroad","depth":2,"charIndex":352},{"text":"device.brand","id":"devicebrand","depth":2,"charIndex":446},{"text":"device.device","id":"devicedevice","depth":2,"charIndex":600},{"text":"device.model","id":"devicemodel","depth":2,"charIndex":680},{"text":"device.product","id":"deviceproduct","depth":2,"charIndex":764},{"text":"device.bootloader","id":"devicebootloader","depth":2,"charIndex":839},{"text":"device.hardware","id":"devicehardware","depth":2,"charIndex":932},{"text":"device.fingerprint","id":"devicefingerprint","depth":2,"charIndex":1057},{"text":"device.serial","id":"deviceserial","depth":2,"charIndex":1193},{"text":"device.sdkInt","id":"devicesdkint","depth":2,"charIndex":1309},{"text":"device.incremental","id":"deviceincremental","depth":2,"charIndex":1480},{"text":"device.release","id":"devicerelease","depth":2,"charIndex":1648},{"text":"device.baseOS","id":"devicebaseos","depth":2,"charIndex":1770},{"text":"device.securityPatch","id":"devicesecuritypatch","depth":2,"charIndex":1844},{"text":"device.codename","id":"devicecodename","depth":2,"charIndex":1932},{"text":"device.getIMEI()","id":"devicegetimei","depth":2,"charIndex":2066},{"text":"device.getAndroidId()","id":"devicegetandroidid","depth":2,"charIndex":2112},{"text":"device.getMacAddress()","id":"devicegetmacaddress","depth":2,"charIndex":2236},{"text":"device.getBrightness()","id":"devicegetbrightness","depth":2,"charIndex":2419},{"text":"device.getBrightnessMode()","id":"devicegetbrightnessmode","depth":2,"charIndex":2482},{"text":"device.setBrightness(b)","id":"devicesetbrightnessb","depth":2,"charIndex":2552},{"text":"device.setBrightnessMode(mode)","id":"devicesetbrightnessmodemode","depth":2,"charIndex":2702},{"text":"device.getMusicVolume()","id":"devicegetmusicvolume","depth":2,"charIndex":2846},{"text":"device.getNotificationVolume()","id":"devicegetnotificationvolume","depth":2,"charIndex":2901},{"text":"device.getAlarmVolume()","id":"devicegetalarmvolume","depth":2,"charIndex":2963},{"text":"device.getMusicMaxVolume()","id":"devicegetmusicmaxvolume","depth":2,"charIndex":3018},{"text":"device.getNotificationMaxVolume()","id":"devicegetnotificationmaxvolume","depth":2,"charIndex":3078},{"text":"device.getAlarmMaxVolume()","id":"devicegetalarmmaxvolume","depth":2,"charIndex":3145},{"text":"device.setMusicVolume(volume)","id":"devicesetmusicvolumevolume","depth":2,"charIndex":3205},{"text":"device.setNotificationVolume(volume)","id":"devicesetnotificationvolumevolume","depth":2,"charIndex":3332},{"text":"device.setAlarmVolume(volume)","id":"devicesetalarmvolumevolume","depth":2,"charIndex":3466},{"text":"device.getBattery()","id":"devicegetbattery","depth":2,"charIndex":3593},{"text":"device.isCharging()","id":"deviceischarging","depth":2,"charIndex":3656},{"text":"device.getTotalMem()","id":"devicegettotalmem","depth":2,"charIndex":3706},{"text":"device.getAvailMem()","id":"devicegetavailmem","depth":2,"charIndex":3781},{"text":"device.isScreenOn()","id":"deviceisscreenon","depth":2,"charIndex":3840},{"text":"device.wakeUp()","id":"devicewakeup","depth":2,"charIndex":4010},{"text":"device.wakeUpIfNeeded()","id":"devicewakeupifneeded","depth":2,"charIndex":4060},{"text":"device.keepScreenOn([timeout])","id":"devicekeepscreenontimeout","depth":2,"charIndex":4104},{"text":"device.keepScreenDim([timeout])","id":"devicekeepscreendimtimeout","depth":2,"charIndex":4455},{"text":"device.cancelKeepingAwake()","id":"devicecancelkeepingawake","depth":2,"charIndex":4721},{"text":"device.vibrate(millis)","id":"devicevibratemillis","depth":2,"charIndex":4825},{"text":"device.cancelVibration()","id":"devicecancelvibration","depth":2,"charIndex":4895},{"text":"device.checkDeviceHasNavigationBar()","id":"devicecheckdevicehasnavigationbar","depth":2,"charIndex":4954},{"text":"device.getVirtualBarHeigh();","id":"devicegetvirtualbarheigh","depth":2,"charIndex":5047}],"domain":"","frontmatter":{},"version":""},{"id":22,"title":"Files","content":"#\n\n稳定性: 稳定\n\n\nfiles 模块提供了一些常见的文件处理，包括文件读写、移动、复制、删掉等。\n\n一次性的文件读写可以直接使用files.read(), files.write(),\nfiles.append()等方便的函数，但如果需要频繁读写或随机读写，则使用open()函数打开一个文件对象来操作文件，并在操作完毕后调用close()函数关\n闭文件。\n\n\nfiles.isFile(path)#\n\n * path {string} 路径\n * 返回 {boolean}\n\n返回路径 path 是否是文件。\n\n\n\n\nfiles.isDir(path)#\n\n * path {string} 路径\n * 返回 {boolean}\n\n返回路径 path 是否是文件夹。\n\n\n\n\nfiles.isEmptyDir(path)#\n\n * path {string} 路径\n * 返回 {boolean}\n\n返回文件夹 path 是否为空文件夹。如果该路径并非文件夹，则直接返回false。\n\n\nfiles.join(parent, child)#\n\n * parent {string} 父目录路径\n * child {string} 子路径\n * 返回 {string}\n\n连接两个路径并返回，例如files.join(\"/sdcard/\", \"1.txt\")返回\"/sdcard/1.txt\"。\n\n\nfiles.create(path)#\n\n * path {string} 路径\n * 返回 {boolean}\n\n创建一个文件或文件夹并返回是否创建成功。如果文件已经存在，则直接返回false。\n\n\n\n\nfiles.createWithDirs(path)#\n\n * path {string} 路径\n * 返回 {boolean}\n\n创建一个文件或文件夹并返回是否创建成功。如果文件所在文件夹不存在，则先创建他所在的一系列文件夹。如果文件已经存在，则直接返回false。\n\n\n\n\nfiles.exists(path)#\n\n * path {string} 路径\n * 返回 {boolean}\n\n返回在路径 path 处的文件是否存在。\n\n\nfiles.ensureDir(path)#\n\n * path {string} 路径\n\n确保路径 path 所在的文件夹存在。如果该路径所在文件夹不存在，则创建该文件夹。\n\n例如对于路径\"/sdcard/Download/ABC/1.txt\"，如果/Download/文件夹不存在，则会先创建 Download，再创建 ABC\n文件夹。\n\n\nfiles.read(path[, encoding = \"utf-8\"])#\n\n * path {string} 路径\n * encoding {string} 字符编码，可选，默认为 utf-8\n * 返回 {string}\n\n读取文本文件 path 的所有内容并返回。如果文件不存在，则抛出FileNotFoundException。\n\n\n\n\nfiles.readBytes(path)#\n\n * path {string} 路径\n * 返回 {byte[]}\n\n读取文件 path 的所有内容并返回一个字节数组。如果文件不存在，则抛出FileNotFoundException。\n\n注意，该数组是 Java 的数组，不具有 JavaScript 数组的 forEach, slice 等函数。\n\n一个以 16 进制形式打印文件的例子如下:\n\n\n\n\nfiles.write(path, text[, encoding = \"utf-8\"])#\n\n * path {string} 路径\n * text {string} 要写入的文本内容\n * encoding {string} 字符编码\n\n把 text 写入到文件 path 中。如果文件存在则覆盖，不存在则创建。\n\n\n\n\nfiles.writeBytes(path, bytes)#\n\n * path {string} 路径\n * bytes {byte[]} 字节数组，要写入的二进制数据\n\n把 bytes 写入到文件 path 中。如果文件存在则覆盖，不存在则创建。\n\n\nfiles.append(path, text[, encoding = 'utf-8'])#\n\n * path {string} 路径\n * text {string} 要写入的文本内容\n * encoding {string} 字符编码\n\n把 text 追加到文件 path 的末尾。如果文件不存在则创建。\n\n\n\n\nfiles.appendBytes(path, text[, encoding = 'utf-8'])#\n\n * path {string} 路径\n * bytes {byte[]} 字节数组，要写入的二进制数据\n\n把 bytes 追加到文件 path 的末尾。如果文件不存在则创建。\n\n\nfiles.copy(fromPath, toPath)#\n\n * fromPath {string} 要复制的原文件路径\n * toPath {string} 复制到的文件路径\n * 返回 {boolean}\n\n复制文件，返回是否复制成功。例如files.copy(\"/sdcard/1.txt\", \"/sdcard/Download/1.txt\")。\n\n\nfiles.move(fromPath, toPath)#\n\n * fromPath {string} 要移动的原文件路径\n * toPath {string} 移动到的文件路径\n * 返回 {boolean}\n\n移动文件，返回是否移动成功。例如files.move(\"/sdcard/1.txt\", \"/sdcard/Download/1.txt\")会把 1.txt\n文件从 sd 卡根目录移动到 Download 文件夹。\n\n\nfiles.rename(path, newName)#\n\n * path {string} 要重命名的原文件路径\n * newName {string} 要重命名的新文件名\n * 返回 {boolean}\n\n重命名文件，并返回是否重命名成功。例如files.rename(\"/sdcard/1.txt\", \"2.txt\")。\n\n\nfiles.renameWithoutExtension(path, newName)#\n\n * path {string} 要重命名的原文件路径\n * newName {string} 要重命名的新文件名\n * 返回 {boolean}\n\n重命名文件，不包含拓展名，并返回是否重命名成功。例如files.rename(\"/sdcard/1.txt\",\n\"2\")会把\"1.txt\"重命名为\"2.txt\"。\n\n\nfiles.getName(path)#\n\n * path {string} 路径\n * 返回 {string}\n\n返回文件的文件名。例如files.getName(\"/sdcard/1.txt\")返回\"1.txt\"。\n\n\nfiles.getNameWithoutExtension(path)#\n\n * path {string} 路径\n * 返回 {string}\n\n返回不含拓展名的文件的文件名。例如files.getName(\"/sdcard/1.txt\")返回\"1\"。\n\n\nfiles.getExtension(path)#\n\n * path {string} 路径\n * 返回 {string}\n\n返回文件的拓展名。例如files.getExtension(\"/sdcard/1.txt\")返回\"txt\"。\n\n\nfiles.remove(path)#\n\n * path {string} 路径\n * 返回 {boolean}\n\n删除文件或空文件夹，返回是否删除成功。\n\n\nfiles.removeDir(path)#\n\n * path {string} 路径\n * path {string} 路径\n * 返回 {boolean}\n\n删除文件夹，如果文件夹不为空，则删除该文件夹的所有内容再删除该文件夹，返回是否全部删除成功。\n\n\nfiles.getSdcardPath()#\n\n * 返回 {string}\n\n返回 SD 卡路径。所谓 SD 卡，即外部存储器。\n\n\nfiles.cwd()#\n\n * 返回 {string}\n\n返回脚本的\"当前工作文件夹路径\"。该路径指的是，如果脚本本身为脚本文件，则返回这个脚本文件所在目录；否则返回null获取其他设定路径。\n\n例如，对于脚本文件\"/sdcard/脚本/1.js\"运行files.cwd()返回\"/sdcard/脚本/\"。\n\n\nfiles.path(relativePath)#\n\n * relativePath {string} 相对路径\n * 返回 {string}\n\n返回相对路径对应的绝对路径。例如files.path(\"./1.png\")，如果运行这个语句的脚本位于文件夹\"/sdcard/脚本/\"中，则返回\"/sdcard\n/脚本/1.png\"。\n\n\nfiles.listDir(path[, filter])#\n\n * path {string} 路径\n * filter {Function} 过滤函数，可选。接收一个string参数（文件名），返回一个boolean值。\n\n列出文件夹 path 下的满足条件的文件和文件夹的名称的数组。如果不加 filter 参数，则返回所有文件和文件夹。\n\n列出 sdcard 目录下所有文件和文件夹为:\n\n\n\n列出脚本目录下所有 js 脚本文件为:\n\n","routePath":"/v1/基础/files/files","lang":"","toc":[{"text":"files.isFile(path)","id":"filesisfilepath","depth":2,"charIndex":183},{"text":"files.isDir(path)","id":"filesisdirpath","depth":2,"charIndex":262},{"text":"files.isEmptyDir(path)","id":"filesisemptydirpath","depth":2,"charIndex":341},{"text":"files.join(parent, child)","id":"filesjoinparent-child","depth":2,"charIndex":447},{"text":"files.create(path)","id":"filescreatepath","depth":2,"charIndex":602},{"text":"files.createWithDirs(path)","id":"filescreatewithdirspath","depth":2,"charIndex":705},{"text":"files.exists(path)","id":"filesexistspath","depth":2,"charIndex":844},{"text":"files.ensureDir(path)","id":"filesensuredirpath","depth":2,"charIndex":925},{"text":"files.read(path[, encoding = \"utf-8\"])","id":"filesreadpath-encoding--utf-8","depth":2,"charIndex":1097},{"text":"files.readBytes(path)","id":"filesreadbytespath","depth":2,"charIndex":1272},{"text":"files.write(path, text[, encoding = \"utf-8\"])","id":"fileswritepath-text-encoding--utf-8","depth":2,"charIndex":1475},{"text":"files.writeBytes(path, bytes)","id":"fileswritebytespath-bytes","depth":2,"charIndex":1638},{"text":"files.append(path, text[, encoding = 'utf-8'])","id":"filesappendpath-text-encoding--utf-8","depth":2,"charIndex":1765},{"text":"files.appendBytes(path, text[, encoding = 'utf-8'])","id":"filesappendbytespath-text-encoding--utf-8","depth":2,"charIndex":1925},{"text":"files.copy(fromPath, toPath)","id":"filescopyfrompath-topath","depth":2,"charIndex":2070},{"text":"files.move(fromPath, toPath)","id":"filesmovefrompath-topath","depth":2,"charIndex":2250},{"text":"files.rename(path, newName)","id":"filesrenamepath-newname","depth":2,"charIndex":2466},{"text":"files.renameWithoutExtension(path, newName)","id":"filesrenamewithoutextensionpath-newname","depth":2,"charIndex":2632},{"text":"files.getName(path)","id":"filesgetnamepath","depth":2,"charIndex":2837},{"text":"files.getNameWithoutExtension(path)","id":"filesgetnamewithoutextensionpath","depth":2,"charIndex":2949},{"text":"files.getExtension(path)","id":"filesgetextensionpath","depth":2,"charIndex":3079},{"text":"files.remove(path)","id":"filesremovepath","depth":2,"charIndex":3199},{"text":"files.removeDir(path)","id":"filesremovedirpath","depth":2,"charIndex":3279},{"text":"files.getSdcardPath()","id":"filesgetsdcardpath","depth":2,"charIndex":3409},{"text":"files.cwd()","id":"filescwd","depth":2,"charIndex":3477},{"text":"files.path(relativePath)","id":"filespathrelativepath","depth":2,"charIndex":3634},{"text":"files.listDir(path[, filter])","id":"fileslistdirpath-filter","depth":2,"charIndex":3802}],"domain":"","frontmatter":{},"version":""},{"id":23,"title":"","content":"open(path[, mode = \"r\", encoding = \"utf-8\", bufferSize = 8192])#\n\n * path {string} 文件路径，例如\"/sdcard/1.txt\"。\n * mode {string} 文件打开模式，包括:\n   * r: 只读文本模式。该模式下只能对文件执行文本读取操作。\n   * w: 只写文本模式。该模式下只能对文件执行文本覆盖写入操作。\n   * a: 附加文本模式。该模式下将会把写入的文本附加到文件末尾。\n   * rw: 随机读写文本模式。该模式下将会把写入的文本附加到文件末尾。\n     \n     目前暂不支持二进制模式，随机读写模式。\n * encoding {string} 字符编码。\n * bufferSize {number} 文件读写的缓冲区大小。\n\n打开一个文件。根据打开模式返回不同的文件对象。包括：\n\n * \"r\": 返回一个 ReadableTextFile 对象。\n * \"w\", \"a\": 返回一个 WritableTextFile 对象。\n\n对于\"w\"模式，如果文件并不存在，则会创建一个，已存在则会清空该文件内容；其他模式文件不存在会抛出 FileNotFoundException。\n\n\nclose()#\n\n关闭该文件。\n\n打开一个文件不再使用时务必关闭","routePath":"/v1/基础/files/openAndClose","lang":"","toc":[{"text":"open(path[, mode = \"r\", encoding = \"utf-8\", bufferSize = 8192])","id":"openpath-mode--r-encoding--utf-8-buffersize--8192","depth":2,"charIndex":-1},{"text":"close()","id":"close","depth":2,"charIndex":550}],"domain":"","frontmatter":{},"version":""},{"id":24,"title":"PWritableTextFile","content":"#\n\n可写文件对象。\n\n\nPWritableTextFile.write(text)#\n\n * text {string} 文本\n\n把文本内容 text 写入到文件中。\n\n\nPWritableTextFile.writeline(line)#\n\n * text {string} 文本\n\n把文本 line 写入到文件中并写入一个换行符。\n\n\nPWritableTextFile.writelines(lines)#\n\n * lines {Array} 字符串数组\n\n把很多行写入到文件中....\n\n\nPWritableTextFile.flush()#\n\n把缓冲区内容输出到文件中。\n\n\nPWritableTextFile.close()#\n\n关闭文件。同时会被缓冲区内容输出到文件。\n\n打开一个文件写入后，不再使用时务必关闭，否则文件可能会丢失","routePath":"/v1/基础/files/pWritableTextFile","lang":"","toc":[{"text":"PWritableTextFile.write(text)","id":"pwritabletextfilewritetext","depth":2,"charIndex":12},{"text":"PWritableTextFile.writeline(line)","id":"pwritabletextfilewritelineline","depth":2,"charIndex":86},{"text":"PWritableTextFile.writelines(lines)","id":"pwritabletextfilewritelineslines","depth":2,"charIndex":170},{"text":"PWritableTextFile.flush()","id":"pwritabletextfileflush","depth":2,"charIndex":249},{"text":"PWritableTextFile.close()","id":"pwritabletextfileclose","depth":2,"charIndex":293}],"domain":"","frontmatter":{},"version":""},{"id":25,"title":"ReadableTextFile","content":"#\n\n可读文件对象。\n\n\nReadableTextFile.read()#\n\n返回该文件剩余的所有内容的字符串。\n\n\nReadableTextFile.read(maxCount)#\n\n * maxCount {Number} 最大读取的字符数量\n\n读取该文件接下来最长为 maxCount 的字符串并返回。即使文件剩余内容不足 maxCount 也不会出错。\n\n\nReadableTextFile.readline()#\n\n读取一行并返回（不包含换行符）。\n\n\nReadableTextFile.readlines()#\n\n读取剩余的所有行，并返回它们按顺序组成的字符串数组。","routePath":"/v1/基础/files/readableTextFile","lang":"","toc":[{"text":"ReadableTextFile.read()","id":"readabletextfileread","depth":2,"charIndex":12},{"text":"ReadableTextFile.read(maxCount)","id":"readabletextfilereadmaxcount","depth":2,"charIndex":58},{"text":"ReadableTextFile.readline()","id":"readabletextfilereadline","depth":2,"charIndex":182},{"text":"ReadableTextFile.readlines()","id":"readabletextfilereadlines","depth":2,"charIndex":231}],"domain":"","frontmatter":{},"version":""},{"id":26,"title":"全局变量与函数","content":"#\n\n全局变量和函数在所有模块中均可使用。 但以下变量的作用域只在模块内，详见 module：\n\n * exports\n * module\n * require() 以下的对象是特定于 Auto.js 的。 有些内置对象是 JavaScript 语言本身的一部分，它们也是全局的。\n\n一些模块中的函数为了使用方便也可以直接全局使用，这些函数在此不再赘述。例如timers模块的setInterval, setTimeout等函数。\n\n\nsleep(n)#\n\n * n {number} 毫秒数\n\n暂停运行n毫秒的时间。1秒等于1000毫秒。\n\n\n\n\ncurrentPackage()#\n\n * 返回 {string}\n\n返回最近一次监测到的正在运行的应用的包名，一般可以认为就是当前正在运行的应用的包名。\n\n此函数依赖于无障碍服务，如果服务未启动，则抛出异常并提示用户启动。\n\n\ncurrentActivity()#\n\n * 返回 {string}\n\n返回最近一次监测到的正在运行的Activity的名称，一般可以认为就是当前正在运行的Activity的名称。\n\n此函数依赖于无障碍服务，如果服务未启动，则抛出异常并提示用户启动。\n\n\nsetClip(text)#\n\n * text {string} 文本\n\n设置剪贴板内容。此剪贴板即系统剪贴板，在一般应用的输入框中\"粘贴\"既可使用。\n\n\n\n\ngetClip()#\n\n * 返回 {string}\n\n返回系统剪贴板的内容。\n\n\n\n\ntoast(message)#\n\n * message {string} 要显示的信息\n\n以气泡显示信息message几秒。(具体时间取决于安卓系统，一般都是2秒)\n\n注意，信息的显示是\"异步\"执行的，并且，不会等待信息消失程序才继续执行。如果在循环中执行该命令，可能出现脚本停止运行后仍然有不断的气泡信息出现的情况。 例如:\n\n\n\n运行这段程序以后，会很快执行完成，且不断弹出消息，在任务管理中关闭所有脚本也无法停止。 要保证气泡消息才继续执行可以用：\n\n\n\n或者修改toast函数：\n\n\n\n\ntoastLog(message)#\n\n * message {string} 要显示的信息\n\n相当于toast(message);log(message)。显示信息message并在控制台中输出。参见console.log。\n\n\nwaitForActivity(activity[, period = 200])#\n\n * activity Activity名称\n * period 轮询等待间隔（毫秒）\n\n等待指定的Activity出现，period为检查Activity的间隔。\n\n\nwaitForPackage(package[, period = 200])#\n\n * package 包名\n * period 轮询等待间隔（毫秒）\n\n等待指定的应用出现。例如waitForPackage(\"com.tencent.mm\")为等待当前界面为微信。\n\n\nexit()#\n\n立即停止脚本运行。\n\n立即停止是通过抛出ScriptInterrupttedException来实现的，因此如果用try...catch把exit()函数的异常捕捉，则脚本不会立即停\n止，仍会运行几行后再停止。\n\n\nrandom(min, max)#\n\n * min {number} 随机数产生的区间下界\n * max {number} 随机数产生的区间上界\n * 返回 {number}\n\n返回一个在[min...max]之间的随机数。例如random(0, 2)可能产生0, 1, 2。\n\n\nrandom()#\n\n * 返回 {number}\n\n返回在[0, 1)的随机浮点数。\n\n\nrequiresApi(api)#\n\n * api Android版本号\n\n表示此脚本需要Android API版本达到指定版本才能运行。例如requiresApi(19)表示脚本需要在Android 4.4以及以上运行。\n\n调用该函数时会判断运行脚本的设备系统的版本号，如果没有达到要求则抛出异常。\n\n可以参考以下Android API和版本的对照表:\n\n平台版本： API级别\n\nAndroid 7.0： 24\n\nAndroid 6.0： 23\n\nAndroid 5.1： 22\n\nAndroid 5.0： 21\n\nAndroid 4.4W： 20\n\nAndroid 4.4： 19\n\nAndroid 4.3： 18\n\n\nrequiresAutojsVersion(version)#\n\n * version {string} | {number} Auto.js的版本或版本号\n\n表示此脚本需要Auto.js版本达到指定版本才能运行。例如requiresAutojsVersion(\"3.0.0 Beta\")表示脚本需要在Auto.js\n3.0.0 Beta以及以上运行。\n\n调用该函数时会判断运行脚本的Auto.js的版本号，如果没有达到要求则抛出异常。\n\nversion参数可以是整数表示版本号，例如requiresAutojsVersion(250)；也可以是字符串格式表示的版本，例如\"3.0.0 Beta\",\n\"3.1.0 Alpha4\", \"3.2.0\"等。\n\n可以通过app.autojs.versionCode和app.autojs.versionName获取当前的Auto.js版本号和版本。\n\n\nruntime.requestPermissions(permissions)#\n\n * permissions {Array} 权限的字符串数组\n\n动态申请安卓的权限。例如：\n\n\n\n尽管安卓有很多权限，但必须写入Manifest才能动态申请，为了防止权限的滥用，目前Auto.js只能额外申请两个权限：\n\n * access_fine_location GPS权限\n * record_audio 录音权限\n\n您可以通过APK编辑器来增加Auto.js以及Auto.js打包的应用的权限。\n\n安卓所有的权限列表参见Permissions Overview。（并没有用）\n\n\nruntime.loadJar(path)#\n\n * path {string} jar文件路径\n\n加载目标jar文件，加载成功后将可以使用该Jar文件的类。\n\n\n\n(jsoup是一个Java实现的解析Html DOM的库，可以在Jsoup下载)\n\n\nruntime.loadDex(path)#\n\n * path {string} dex文件路径\n\n加载目标dex文件，加载成功后将可以使用该dex文件的类。\n\n因为加载jar实际上是把jar转换为dex再加载的，因此加载dex文件会比jar文件快得多。可以使用Android SDK的build\ntools的dx工具把jar转换为dex。\n\n\ncontext#\n\n全局变量。一个android.content.Context对象。\n\n注意该对象为ApplicationContext，因此不能用于界面、对话框等的创建。","routePath":"/v1/基础/globals","lang":"","toc":[{"text":"sleep(n)","id":"sleepn","depth":2,"charIndex":217},{"text":"currentPackage()","id":"currentpackage","depth":2,"charIndex":274},{"text":"currentActivity()","id":"currentactivity","depth":2,"charIndex":389},{"text":"setClip(text)","id":"setcliptext","depth":2,"charIndex":517},{"text":"getClip()","id":"getclip","depth":2,"charIndex":597},{"text":"toast(message)","id":"toastmessage","depth":2,"charIndex":641},{"text":"toastLog(message)","id":"toastlogmessage","depth":2,"charIndex":889},{"text":"waitForActivity(activity[, period = 200])","id":"waitforactivityactivity-period--200","depth":2,"charIndex":1005},{"text":"waitForPackage(package[, period = 200])","id":"waitforpackagepackage-period--200","depth":2,"charIndex":1134},{"text":"exit()","id":"exit","depth":2,"charIndex":1270},{"text":"random(min, max)","id":"randommin-max","depth":2,"charIndex":1387},{"text":"random()","id":"random","depth":2,"charIndex":1528},{"text":"requiresApi(api)","id":"requiresapiapi","depth":2,"charIndex":1574},{"text":"requiresAutojsVersion(version)","id":"requiresautojsversionversion","depth":2,"charIndex":1887},{"text":"runtime.requestPermissions(permissions)","id":"runtimerequestpermissionspermissions","depth":2,"charIndex":2285},{"text":"runtime.loadJar(path)","id":"runtimeloadjarpath","depth":2,"charIndex":2573},{"text":"runtime.loadDex(path)","id":"runtimeloaddexpath","depth":2,"charIndex":2699},{"text":"context","id":"context","depth":2,"charIndex":2872}],"domain":"","frontmatter":{},"version":""},{"id":27,"title":"Response","content":"HTTP#\n\n稳定性: 稳定\n\n\nhttp 模块提供一些进行 http 请求的函数。\n\n\nhttp.get(url[, options, callback])#\n\n * url {string} 请求的 URL 地址，需要以\"http://\"或\"https://\"开头。如果 url\n   没有以\"http://\"开头，则默认为\"http://\"。\n * options {Object} 请求选项。参见[http.request()][]。\n * callback {Function} 回调函数，可选，其参数是一个[Response][]对象。如果不加回调函数，则该请求将阻塞、同步地执行。\n\n对地址 url 进行一次 HTTP GET 请求。如果没有回调函数，则在请求完成或失败时返回此次请求的响应(参见[Response][])。\n\n最简单 GET 请求如下:\n\n\n\n采用回调形式的 GET 请求如下：\n\n\n\n如果要增加 HTTP 头部信息，则在 options 参数中添加，例如：\n\n\n\n一个请求天气并解析返回的天气 JSON 结果的例子如下：\n\n\n\n\nhttp.post(url, data[, options, callback])#\n\n * url {string} 请求的 URL 地址，需要以\"http://\"或\"https://\"开头。如果 url\n   没有以\"http://\"开头，则默认为\"http://\"。\n * data {string} | {Object} POST 数据。\n * options {Object} 请求选项。\n * callback {Function} 回调，其参数是一个[Response][]对象。如果不加回调参数，则该请求将阻塞、同步地执行。\n\n对地址 url 进行一次 HTTP POST 请求。如果没有回调函数，则在请求完成或失败时返回此次请求的响应(参见[Response][])。\n\n其中 POST 数据可以是字符串或键值对。具体含义取决于 options.contentType\n的值。默认为\"application/x-www-form-urlencoded\"(表单提交), 这种方式是 JQuery 的 ajax 函数的默认方式。\n\n一个模拟表单提交登录淘宝的例子如下:\n\n\n\n\nhttp.postJson(url[, data, options, callback])#\n\n * url {string} 请求的 URL 地址，需要以\"http://\"或\"https://\"开头。如果 url\n   没有以\"http://\"开头，则默认为\"http://\"。\n * data {Object} POST 数据。\n * options {Object} 请求选项。\n * callback {Function} 回调，其参数是一个[Response][]对象。如果不加回调参数，则该请求将阻塞、同步地执行。\n\n以 JSON 格式向目标 Url 发起 POST 请求。如果没有回调函数，则在请求完成或失败时返回此次请求的响应(参见[Response][])。\n\nJSON 格式指的是，将会调用JSON.stringify()把 data 对象转换为 JSON 字符串，并在 HTTP\n头部信息中把\"Content-Type\"属性置为\"application/json\"。这种方式是 AngularJS 的 ajax 函数的默认方式。\n\n一个调用图灵机器人接口的例子如下：\n\n\n\n\nhttp.postMultipart(url, files[, options, callback])#\n\n * url {string} 请求的 URL 地址，需要以\"http://\"或\"https://\"开头。如果 url\n   没有以\"http://\"开头，则默认为\"http://\"。\n * files {Object} POST 数据。\n * options {Object} 请求选项。\n * callback {Function} 回调，其参数是一个Response对象。如果不加回调参数，则该请求将阻塞、同步地执行。\n\n向目标地址发起类型为 multipart/form-data 的请求（通常用于文件上传等), 其中 files 参数是{name1: value1,\nname2: value2, ...}的键值对，value 的格式可以是以下几种情况：\n\n 1. string\n 2. 文件类型，即 open()返回的类型\n 3. [fileName, filePath]\n 4. [fileName, mimeType, filePath]\n\n其中 1 属于非文件参数，2、3、4 为文件参数。举个例子，最简单的文件上传的请求为：\n\n\n\n如果使用格式 2，则代码为\n\n\n\n如果使用格式 3，则代码为\n\n\n\n如果使用格式 2 的同时要附带非文件参数\"appId=abcdefghijk\"，则为:\n\n\n\n\nhttp.request(url[, options, callback])#\n\n * url {string} 请求的 URL 地址，需要以\"http://\"或\"https://\"开头。如果 url\n   没有以\"http://\"开头，则默认为\"http://\"。\n * options {Object} 请求选项。参见[http.buildRequest()][]。\n * callback {Function} 回调，其参数是一个[Response][]对象。如果不加回调参数，则该请求将阻塞、同步地执行。\n\n对目标地址 url 发起一次 HTTP 请求。如果没有回调函数，则在请求完成或失败时返回此次请求的响应(参见[Response][])。\n\n选项 options 可以包含以下属性：\n\n * headers {Object} 键值对形式的 HTTP 头部信息。有关 HTTP 头部信息，参见菜鸟教程：HTTP 响应头信息。\n * method {string} HTTP 请求方法。包括\"GET\", \"POST\", \"PUT\", \"DELET\", \"PATCH\"。\n * contentType {string} HTTP 头部信息中的\"Content-Type\", 表示 HTTP\n   请求的内容类型。例如\"text/plain\", \"application/json\"。更多信息参见菜鸟教程：HTTP contentType。\n * body {string} | {Array} | {Function} HTTP\n   请求的内容。可以是一个字符串，也可以是一个字节数组；或者是一个以BufferedSink为参数的函数。\n\n该函数是 get, post, postJson 等函数的基础函数。因此除非是 PUT, DELET 等请求，或者需要更高定制的 HTTP 请求，否则直接使用\nget, post, postJson 等函数会更加方便。\n\n\nResponse#\n\nHTTP 请求的响应。\n\n\nResponse.statusCode#\n\n * {number}\n\n当前响应的 HTTP 状态码。例如 200(OK), 404(Not Found)等。\n\n有关 HTTP 状态码的信息，参见菜鸟教程：HTTP 状态码。\n\n\nResponse.statusMessage#\n\n * {string}\n\n当前响应的 HTTP 状态信息。例如\"OK\", \"Bad Request\", \"Forbidden\"。\n\n有关 HTTP 状态码的信息，参见菜鸟教程：HTTP 状态码。\n\n例子：\n\n\n\n\nResponse.headers#\n\n * {Object}\n\n当前响应的 HTTP 头部信息。该对象的键是响应头名称，值是各自的响应头值。 所有响应头名称都是小写的(吗)。\n\n有关 HTTP 头部信息，参见菜鸟教程：HTTP 响应头信息。\n\n例子:\n\n\n\n\nResponse.body#\n\n * {Object}\n\n当前响应的内容。他有以下属性和函数：\n\n * bytes() {Array} 以字节数组形式返回响应内容\n * string() {string} 以字符串形式返回响应内容\n * json() {Object} 把响应内容作为 JSON 格式的数据并调用 JSON.parse，返回解析后的对象\n * contentType {string} 当前响应的内容类型\n\n\nResponse.request#\n\n * {Request} 当前响应所对应的请求。参见[Request][]。\n\n\nResponse.url#\n\n * {number} 当前响应所对应的请求 URL。\n\n\nResponse.method#\n\n * {string} 当前响应所对应的 HTTP 请求的方法。例如\"GET\", \"POST\", \"PUT\"等。","routePath":"/v1/基础/http","lang":"","toc":[{"text":"http.get(url[, options, callback])","id":"httpgeturl-options-callback","depth":2,"charIndex":44},{"text":"http.post(url, data[, options, callback])","id":"httpposturl-data-options-callback","depth":2,"charIndex":481},{"text":"http.postJson(url[, data, options, callback])","id":"httppostjsonurl-data-options-callback","depth":2,"charIndex":977},{"text":"http.postMultipart(url, files[, options, callback])","id":"httppostmultiparturl-files-options-callback","depth":2,"charIndex":1476},{"text":"http.request(url[, options, callback])","id":"httprequesturl-options-callback","depth":2,"charIndex":2088},{"text":"Response.statusCode","id":"responsestatuscode","depth":2,"charIndex":2950},{"text":"Response.statusMessage","id":"responsestatusmessage","depth":2,"charIndex":3064},{"text":"Response.headers","id":"responseheaders","depth":2,"charIndex":3196},{"text":"Response.body","id":"responsebody","depth":2,"charIndex":3326},{"text":"Response.request","id":"responserequest","depth":2,"charIndex":3539},{"text":"Response.url","id":"responseurl","depth":2,"charIndex":3599},{"text":"Response.method","id":"responsemethod","depth":2,"charIndex":3644}],"domain":"","frontmatter":{},"version":""},{"id":28,"title":"KeyCode 对照表","content":"#\n\nKeyCode KeyEvent Value\n\n * KEYCODE_MENU 1\n * KEYCODE_SOFT_RIGHT 2\n * KEYCODE_HOME 3\n * KEYCODE_BACK 4\n * KEYCODE_CALL 5\n * KEYCODE_ENDCALL 6\n * KEYCODE_0 7\n * KEYCODE_1 8\n * KEYCODE_2 9\n * KEYCODE_3 10\n * KEYCODE_4 11\n * KEYCODE_5 12\n * KEYCODE_6 13\n * KEYCODE_7 14\n * KEYCODE_8 15\n * KEYCODE_9 16\n * KEYCODE_STAR 17\n * KEYCODE_POUND 18\n * KEYCODE_DPAD_UP 19\n * KEYCODE_DPAD_DOWN 20\n * KEYCODE_DPAD_LEFT 21\n * KEYCODE_DPAD_RIGHT 22\n * KEYCODE_DPAD_CENTER 23\n * KEYCODE_VOLUME_UP 24\n * KEYCODE_VOLUME_DOWN 25\n * KEYCODE_POWER 26\n * KEYCODE_CAMERA 27\n * KEYCODE_CLEAR 28\n * KEYCODE_A 29\n * KEYCODE_B 30\n * KEYCODE_C 31\n * KEYCODE_D 32\n * KEYCODE_E 33\n * KEYCODE_F 34\n * KEYCODE_G 35\n * KEYCODE_H 36\n * KEYCODE_I 37\n * KEYCODE_J 38\n * KEYCODE_K 39\n * KEYCODE_L 40\n * KEYCODE_M 41\n * KEYCODE_N 42\n * KEYCODE_O 43\n * KEYCODE_P 44\n * KEYCODE_Q 45\n * KEYCODE_R 46\n * KEYCODE_S 47\n * KEYCODE_T 48\n * KEYCODE_U 49\n * KEYCODE_V 50\n * KEYCODE_W 51\n * KEYCODE_X 52\n * KEYCODE_Y 53\n * KEYCODE_Z 54\n * KEYCODE_COMMA 55\n * KEYCODE_PERIOD 56\n * KEYCODE_ALT_LEFT 57\n * KEYCODE_ALT_RIGHT 58\n * KEYCODE_SHIFT_LEFT 59\n * KEYCODE_SHIFT_RIGHT 60\n * KEYCODE_TAB 61\n * KEYCODE_SPACE 62\n * KEYCODE_SYM 63\n * KEYCODE_EXPLORER 64\n * KEYCODE_ENVELOPE 65\n * KEYCODE_ENTER 66\n * KEYCODE_DEL 67\n * KEYCODE_GRAVE 68\n * KEYCODE_MINUS 69\n * KEYCODE_EQUALS 70\n * KEYCODE_LEFT_BRACKET 71\n * KEYCODE_RIGHT_BRACKET 72\n * KEYCODE_BACKSLASH 73\n * KEYCODE_SEMICOLON 74\n * KEYCODE_APOSTROPHE 75\n * KEYCODE_SLASH 76\n * KEYCODE_AT 77\n * KEYCODE_NUM 78\n * KEYCODE_HEADSETHOOK 79\n * KEYCODE_FOCUS 80\n * KEYCODE_PLUS 81\n * KEYCODE_MENU 82\n * KEYCODE_NOTIFICATION 83\n * KEYCODE_SEARCH 84\n * TAGLAST KEYCODE 85","routePath":"/v1/基础/keys/keyCode","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":29,"title":"Keys","content":"#\n\n按键模拟部分提供了一些模拟物理按键的全局函数，包括Home、音量键、照相键等，有的函数依赖于无障碍服务，有的函数依赖于root权限。\n\n一般来说，以大写字母开头的函数都依赖于root权限。执行此类函数时，如果没有root权限，则函数执行后没有效果，并会在控制台输出一个警告。\n\n\nback()#\n\n * 返回 {boolean}\n\n模拟按下返回键。返回是否执行成功。 此函数依赖于无障碍服务。\n\n\nhome()#\n\n * 返回 {boolean}\n\n模拟按下Home键。返回是否执行成功。 此函数依赖于无障碍服务。\n\n\npowerDialog()#\n\n * 返回 {boolean}\n\n弹出电源键菜单。返回是否执行成功。 此函数依赖于无障碍服务。\n\n\nnotifications()#\n\n * 返回 {boolean}\n\n拉出通知栏。返回是否执行成功。 此函数依赖于无障碍服务。\n\n\nquickSettings()#\n\n * 返回 {boolean}\n\n显示快速设置(下拉通知栏到底)。返回是否执行成功。 此函数依赖于无障碍服务。\n\n\nrecents()#\n\n * 返回 {boolean}\n\n显示最近任务。返回是否执行成功。 此函数依赖于无障碍服务。\n\n\nsplitScreen()#\n\n * 返回 {boolean}\n\n分屏。返回是否执行成功。 此函数依赖于无障碍服务, 并且需要系统自身功能的支持。\n\n\ntakeScreenshot()#\n\n * 返回 {boolean}\n * 需要Android 9以上\n\n模拟按键 电源键+音量下键 截屏 不返回截屏得到的图片对象，只返回是否截图成功，图片保存到系统相册\n\n\nlockScreen()#\n\n * 返回 {boolean}\n * 需要Android 9以上\n\n模拟按键 电源键 锁屏\n\n\ndismissNotificationShade()#\n\n * 返回 {boolean}\n * 需要Android 12以上\n\n关闭通知栏的操作\n\n\nkeyCodeHeadsetHook()#\n\n * 返回 {boolean}\n * 需要Android 12以上\n\n发送KEYCODE_HEADSETHOOK KeyEvent的动作，用于接听/挂断通话和播放/停止媒体\n\n\naccessibilityShortcut()#\n\n * 返回 {boolean}\n * 需要Android 12以上\n\n触发辅助功能快捷方式的操作。此快捷方式有一个硬件触发器并且可以通过按住两个音量键来激活。\n\n\naccessibilityButtonChooser()#\n\n * 返回 {boolean}\n * 需要Android 12以上\n\n调出辅助功能按钮的选择器菜单的操作\n\n\naccessibilityButton()#\n\n * 返回 {boolean}\n * 需要Android 12以上\n\n触发辅助功能按钮的操作\n\n\naccessibilityAllApps()#\n\n * 返回 {boolean}\n * 需要Android 12以上\n\n显示 Launcher（启动器） 的所有应用的操作。\n\n\nHome()#\n\n模拟按下Home键。 此函数依赖于root权限。\n\n\nBack()#\n\n模拟按下返回键。 此函数依赖于root权限。\n\n\nPower()#\n\n模拟按下电源键。 此函数依赖于root权限。\n\n\nMenu()#\n\n模拟按下菜单键。 此函数依赖于root权限。\n\n\nVolumeUp()#\n\n按下音量上键。 此函数依赖于root权限。\n\n\nVolumeDown()#\n\n按键音量上键。 此函数依赖于root权限。\n\n\nCamera()#\n\n模拟按下照相键。\n\n\nUp()#\n\n模拟按下物理按键上。 此函数依赖于root权限。\n\n\nDown()#\n\n模拟按下物理按键下。 此函数依赖于root权限。\n\n\nLeft()#\n\n模拟按下物理按键左。 此函数依赖于root权限。\n\n\nRight()#\n\n模拟按下物理按键右。 此函数依赖于root权限。\n\n\nOK()#\n\n模拟按下物理按键确定。 此函数依赖于root权限。\n\n\nText(text)#\n\n * text {string} 要输入的文字，只能为英文或英文符号 输入文字text。例如Text(\"aaa\");\n\n\nKeyCode(code)#\n\n * code {number} | 要按下的按键的数字代码或名称。参见下表。\n   模拟物理按键。例如KeyCode(29)和KeyCode(\"KEYCODE_A\")是按下A键。","routePath":"/v1/基础/keys/keys","lang":"","toc":[{"text":"back()","id":"back","depth":2,"charIndex":142},{"text":"home()","id":"home","depth":2,"charIndex":201},{"text":"powerDialog()","id":"powerdialog","depth":2,"charIndex":262},{"text":"notifications()","id":"notifications","depth":2,"charIndex":328},{"text":"quickSettings()","id":"quicksettings","depth":2,"charIndex":394},{"text":"recents()","id":"recents","depth":2,"charIndex":470},{"text":"splitScreen()","id":"splitscreen","depth":2,"charIndex":531},{"text":"takeScreenshot()","id":"takescreenshot","depth":2,"charIndex":607},{"text":"lockScreen()","id":"lockscreen","depth":2,"charIndex":712},{"text":"dismissNotificationShade()","id":"dismissnotificationshade","depth":2,"charIndex":775},{"text":"keyCodeHeadsetHook()","id":"keycodeheadsethook","depth":2,"charIndex":850},{"text":"accessibilityShortcut()","id":"accessibilityshortcut","depth":2,"charIndex":962},{"text":"accessibilityButtonChooser()","id":"accessibilitybuttonchooser","depth":2,"charIndex":1070},{"text":"accessibilityButton()","id":"accessibilitybutton","depth":2,"charIndex":1156},{"text":"accessibilityAllApps()","id":"accessibilityallapps","depth":2,"charIndex":1229},{"text":"Home()","id":"home-1","depth":2,"charIndex":-1},{"text":"Back()","id":"back-1","depth":2,"charIndex":-1},{"text":"Power()","id":"power","depth":2,"charIndex":1388},{"text":"Menu()","id":"menu","depth":2,"charIndex":1423},{"text":"VolumeUp()","id":"volumeup","depth":2,"charIndex":1457},{"text":"VolumeDown()","id":"volumedown","depth":2,"charIndex":1494},{"text":"Camera()","id":"camera","depth":2,"charIndex":1533},{"text":"Up()","id":"up","depth":2,"charIndex":1555},{"text":"Down()","id":"down","depth":2,"charIndex":1589},{"text":"Left()","id":"left","depth":2,"charIndex":1625},{"text":"Right()","id":"right","depth":2,"charIndex":1661},{"text":"OK()","id":"ok","depth":2,"charIndex":1698},{"text":"Text(text)","id":"texttext","depth":2,"charIndex":1733},{"text":"KeyCode(code)","id":"keycodecode","depth":2,"charIndex":1807}],"domain":"","frontmatter":{},"version":""},{"id":30,"title":"MQTT","content":"#\n\n6.5.9 新增\n\n稳定性: 稳定\n\n\nMQTT 模块，采用org.eclipse.paho.client.mqttv3实现\n\n\n代码示例#\n\n> 主题订阅、发布、QOS、遗嘱消息\n\n","routePath":"/v1/基础/mqtt","lang":"","toc":[{"text":"代码示例","id":"代码示例","depth":2,"charIndex":67}],"domain":"","frontmatter":{},"version":""},{"id":31,"title":"Storage","content":"s#\n\n稳定性: 稳定\n\n\nstorages 模块提供了保存简单数据、用户配置等的支持。保存的数据除非应用被卸载或者被主动删除，否则会一直保留。\n\nstorages 支持number, boolean, string等数据类型以及把Object, Array用JSON.stringify序列化存取。\n\nstorages 保存的数据在脚本之间是共享的，任何脚本只要知道 storage 名称便可以获取到相应的数据，因此它不能用于敏感数据的储存。 storages\n无法像 Web 开发中 LocalStorage 一样提供根据域名独立的存储，因为脚本的路径随时可能改变。\n\n\nstorages.create(name)#\n\n * name {string} 本地存储名称\n\n创建一个本地存储并返回一个Storage对象。不同名称的本地存储的数据是隔开的，而相同名称的本地存储的数据是共享的。\n\n例如在一个脚本中，创建名称为 ABC 的存储并存入 a=123:\n\n\n\n而在另一个脚本中是可以获取到 ABC 以及 a 的值的：\n\n\n\n因此，本地存储的名称比较重要，尽量使用含有域名、作者邮箱等唯一信息的名称来避免冲突，例如：\n\n\n\n\nstorages.remove(name)#\n\n * name {string} 本地存储名称\n\n删除一个本地存储以及他的全部数据。如果该存储不存在，返回 false；否则返回 true。\n\n\nStorage#\n\n\nStorage.get(key[, defaultValue])#\n\n * key {string} 键值\n * defaultValue {any} 可选，默认值\n\n从本地存储中取出键值为 key 的数据并返回。\n\n如果该存储中不包含该数据，这时若指定了默认值参数则返回默认值，否则返回 undefined。\n\n返回的数据可能是任意数据类型，这取决于使用Storage.put保存该键值的数据时的数据类型。\n\n\nStorage.put(key, value)#\n\n * key {string} 键值\n * value {any} 值\n\n把值 value 保存到本地存储中。value 可以是 undefined 以外的任意数据类型。如果 value 为 undefined 则抛出\nTypeError。\n\n存储的过程实际上是使用 JSON.stringify 把 value 转换为字符串再保存，因此 value 必须是可 JSON 化的才能被接受。\n\n\nStorage.remove(key)#\n\n * key {string} 键值\n\n移除键值为 key 的数据。不返回任何值。\n\n\nStorage.contains(key)#\n\n * key {string} 键值\n\n返回该本地存储是否包含键值为 key 的数据。是则返回 true，否则返回 false。\n\n\nStorage.clear()#\n\n移除该本地存储的所有数据。不返回任何值。","routePath":"/v1/基础/storages","lang":"","toc":[{"text":"storages.create(name)","id":"storagescreatename","depth":2,"charIndex":287},{"text":"storages.remove(name)","id":"storagesremovename","depth":2,"charIndex":514},{"text":"Storage.get(key[, defaultValue])","id":"storagegetkey-defaultvalue","depth":2,"charIndex":622},{"text":"Storage.put(key, value)","id":"storageputkey-value","depth":2,"charIndex":829},{"text":"Storage.remove(key)","id":"storageremovekey","depth":2,"charIndex":1052},{"text":"Storage.contains(key)","id":"storagecontainskey","depth":2,"charIndex":1118},{"text":"Storage.clear()","id":"storageclear","depth":2,"charIndex":1209}],"domain":"","frontmatter":{},"version":""},{"id":32,"title":"Timers","content":"#\n\n稳定性: 稳定\n\n\ntimers 模块暴露了一个全局的 API，用于在某个未来时间段调用调度函数。\n\n因为定时器函数是全局的，所以使用该 API 无需调用 timers.XXXXX\n\nAuto.js 中的计时器函数实现了与 Web 浏览器提供的定时器类似的 API，除了它使用了一个不同的内部实现，它是基于 Android\nLooper-Handler 消息循环机制构建的。其实现机制与 Node.js 比较相似。\n\n例如，要在 5 秒后发出消息\"hello\":\n\n\n\n需要注意的是，这些定时器仍然是单线程的。如果脚本主体有耗时操作或死循环，则设定的定时器不能被及时执行，例如：\n\n\n\n再如：\n\n\n\n\nsetInterval(callback, delay[, ...args])#\n\n * callback {Function} 当定时器到点时要调用的函数。\n * delay {number} 调用 callback 之前要等待的毫秒数。\n * ...args {any} 当调用 callback 时要传入的可选参数。\n\n预定每隔 delay 毫秒重复执行的 callback。 返回一个用于 clearInterval() 的 id。\n\n当 delay 小于 0 时，delay 会被设为 0。\n\n\nsetTimeout(callback, delay[, ...args])#\n\n * callback {Function} 当定时器到点时要调用的函数。\n * delay {number} 调用 callback 之前要等待的毫秒数。\n * ...args {any} 当调用 callback 时要传入的可选参数。\n\n预定在 delay 毫秒之后执行的单次 callback。 返回一个用于 clearTimeout() 的 id。\n\ncallback 可能不会精确地在 delay 毫秒被调用。 Auto.js 不能保证回调被触发的确切时间，也不能保证它们的顺序。\n回调会在尽可能接近所指定的时间上调用。\n\n当 delay 小于 0 时，delay 会被设为 0。\n\n\nsetImmediate(callback[, ...args])#\n\n * callback {Function} 在 Looper 循环的当前回合结束时要调用的函数。\n * ...args {any} 当调用 callback 时要传入的可选参数。\n\n预定立即执行的 callback，它是在 I/O 事件的回调之后被触发。 返回一个用于 clearImmediate() 的 id。\n\n当多次调用 setImmediate() 时，callback 函数会按照它们被创建的顺序依次执行。 每次事件循环迭代都会处理整个回调队列。\n如果一个立即定时器是被一个正在执行的回调排入队列的，则该定时器直到下一次事件循环迭代才会被触发。\n\nsetImmediate()、setInterval() 和 setTimeout() 方法每次都会返回表示预定的计时器的 id。\n它们可用于取消定时器并防止触发。\n\n\nclearInterval(id)#\n\n * id {number} 一个 setInterval() 返回的 id。\n\n取消一个由 setInterval() 创建的循环定时任务。\n\n例如：\n\n\n\n\nclearTimeout(id)#\n\n * id {number} 一个 setTimeout() 返回的 id。\n\n取消一个由 setTimeout() 创建的定时任务。\n\n\nclearImmediate(id)#\n\n * id {number} 一个 setImmediate() 返回的 id。\n\n取消一个由 setImmediate() 创建的 Immediate 对象。","routePath":"/v1/基础/timers","lang":"","toc":[{"text":"setInterval(callback, delay[, ...args])","id":"setintervalcallback-delay-args","depth":2,"charIndex":303},{"text":"setTimeout(callback, delay[, ...args])","id":"settimeoutcallback-delay-args","depth":2,"charIndex":556},{"text":"setImmediate(callback[, ...args])","id":"setimmediatecallback-args","depth":2,"charIndex":895},{"text":"clearInterval(id)","id":"clearintervalid","depth":2,"charIndex":1297},{"text":"clearTimeout(id)","id":"cleartimeoutid","depth":2,"charIndex":1398},{"text":"clearImmediate(id)","id":"clearimmediateid","depth":2,"charIndex":1487}],"domain":"","frontmatter":{},"version":""},{"id":33,"title":"按钮控件: button","content":"#\n\n按钮控件是一个特殊的文本控件，因此所有文本控件的函数的属性都适用于按钮控件。\n\n除此之外，按钮控件有一些内置的样式，通过style属性设置，包括：\n\n * Widget.AppCompat.Button.Colored 带颜色的按钮\n * Widget.AppCompat.Button.Borderless 无边框按钮\n * Widget.AppCompat.Button.Borderless.Colored 带颜色的无边框按钮\n\n这些样式的具体效果参见\"示例/界面控件/按钮控件.js\"。\n\n例如：<button style=\"Widget.AppCompat.Button.Colored\" text=\"漂亮的按钮\"/>","routePath":"/v1/基础/ui/button","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":34,"title":"卡片: card","content":"#\n\n官方教程：\n\n卡片控件是一个拥有圆角、阴影的控件。\n\nardBackgroundColor:\n\n卡片的背景颜色。比如 cardBackgroundColor=\"#ffffff\"。\n\ncardCornerRadius:\n\n卡片的圆角半径。\n\ncardElevation:\n\n设置卡片在 z 轴上的高度，来控制阴影的大小。\n\ncontentPadding:\n\n设置卡片的内边距。该属性包括四个值：\n\n * contentPaddingLeft 左内边距\n * contentPaddingRight 右内边距\n * contentPaddingTop 上内边距\n * contentPaddingBottom 下内边距\n\nforeground:\n\n使用foreground=\"?selectableItemBackground\"属性可以为卡片添加点击效果。","routePath":"/v1/基础/ui/card","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":35,"title":"勾选框控件: checkbox","content":"#\n\n勾选框是一种用于表示选择状态的控件，用户可以通过点击来切换其选中状态。\n\n1.创建勾选框控件\n\n要创建一个勾选框控件，可以使用 ui.CheckBox 函数，并传入相应的参数来设置其属性。以下是一个创建勾选框控件的示例代码：\n\n\n\n在上述代码中：\n\nid=\"cb\":为勾选框控件设置了一个唯一的标识符，以便后续可以通过该 ID 来引用和操作该控件。\n\ntext=\"同意条款\":设置了勾选框控件的文本标签，用于向用户显示相关信息。\n\nchecked=\"{{false}}\":初始化勾选框控件的选中状态为未选中（false）。如果希望初始状态为选中，可以将值设置为 true\n\n2.获取和设置勾选框状态\n\n获取勾选框状态\n\n要获取勾选框控件的当前选中状态，可以使用 ui.cb.checked 属性。以下是一个获取勾选框状态的示例代码：\n\n\n\n在上述代码中：\n\nui.cb.on(\"check\", function(checked) {...}):为勾选框控件注册了一个 check\n事件监听器，当勾选框的状态发生变化时，会触发该事件，并传递当前的选中状态（checked）作为参数。\n\ntoast(\"当前选中状态：\" + checked):使用 toast 函数显示当前的选中状态。\n\n设置勾选框状态\n\n要设置勾选框控件的选中状态，可以直接修改 ui.cb.checked 属性的值。以下是一个设置勾选框状态的示例代码：\n\n\n\n或者，你也可以在创建勾选框控件时，通过 checked 属性来设置初始状态，如之前所示。\n\n3.监听勾选框事件\n\n除了 check 事件外，还可以为勾选框控件注册其他事件监听器，例如 click 事件。以下是一个监听勾选框点击事件的示例代码：\n\n\n\n在上述代码中：\n\nui.cb.on(\"click\", function() {...}):为勾选框控件注册了一个 click 事件监听器，当用户点击勾选框时，会触发该事件。\n\ntoast(\"勾选框被点击\"):使用 toast 函数显示一条提示信息，表示勾选框被点击。\n\n4.完整示例\n\n以下是一个完整的示例代码，演示了如何创建勾选框控件、获取和设置其状态，以及监听相关事件：\n\n\n\n在上述代码中:\n\n创建了一个勾选框控件（id=\"cb\"），并设置了初始状态为未选中。\n\n添加了两个按钮控件，分别用于获取勾选框的当前状态和设置勾选框为选中状态。\n\n为勾选框控件注册了 check 事件监听器，用于实时显示当前的选中状态。\n\n为获取状态按钮注册了 click 事件监听器，用于显示当前的选中状态。\n\n为设置状态按钮注册了 click 事件监听器，用于将勾选框设置为选中状态。\n\n官方教程：\n\ncheckbox 控件即复选框，提供勾选交互的控件。\n\n参见 Android CheckBox\n\ntext:\n\ncheckbox 控件的文本，显示在勾选框后面。实际上 checkbox 控件继承于text和button控件，它们的属性也可以用在 checkbox\n上，比如textSize, textStyle。\n\nchecked:\n\n设置 checkbox 的选中状态，当checked=\"true\"为选中选项框，否则为未选中选项框。可以通过 attr\n方法动态设置勾选框的状态。比如：$ui.checkbox1.attr(\"checked\", \"true\")。\n\nenabled:\n\n设置复选框是否是启用的，若enabled=\"false\"则为禁用状态，显示未灰色，无法交互。\n\nisChecked():\n\n * 返回 {boolean}\n\n通过 isChecked 可以检测选项框当前是否被选中。如果被选中则返回为true，否则为false。\n\n事件: check:\n\n * checked {boolean} 是否被勾选\n * view {View} 当前事件的 View\n\n当用户勾选/取消勾选选项框时会触发该事件。\n\n例子:\n\n","routePath":"/v1/基础/ui/checkbox","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":36,"title":"日期选择控件: datepicker","content":"#\n\n官方教程：\n\n用户可以选择日期，呈现内容为\"MM/dd/yyyy\"，日历样式日期选择模式还可呈现该日期的星期，如周二。\n\n参见 Android DatePicker\n\ndatePickerMode:\n\n * {string}\n\n日期选择界面的呈现模式。若用户在 datePicker 控件中未指定 datePickerMode，则默认使用日历样式calendar时间选择。\n\n * spinner 滑动样式日期选择模式。\n * calendar 日历样式选择模式。\n\nspinnersShown:\n\n * {boolean}\n\n设置是否显示 spinner 滑动样式日期选择模式。\n\ncalendarViewShown:\n\n * {boolean}\n\n设置是否显示日历样式。\n\nfirstDayOfWeek:\n\n * {number}\n\n设置一周的第一天。范围为 1~7，分别代表周日~周六。默认为 1，也即周日。\n\nmaxDate:\n\n * {string}\n\n设置此 datePicker 支持的最大日期，格式为yyyy/MM/dd。\n\nminDate:\n\n * {string}\n\n设置此 datePicker 支持的最小日期，格式为yyyy/MM/dd。","routePath":"/v1/基础/ui/datepicker","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":37,"title":"","content":"","routePath":"/v1/基础/ui/drawer","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":38,"title":"浮动按钮控件: fab","content":"#\n\n官方教程：\n\n浮动按钮是 UI 界面上的一个浮动的图标，它的颜色、图标、位置在 UI\n界面中有着明显的区别，通常是为了突出一个重要的功能点，引导用户点击来执行重要/频繁的操作。\n\nsrc:\n\n指定浮动按钮的图标，其格式与图片控件属性src一致，比如@drawable/ic_add_black_48dp，https://图片网址等。\n\n以下是一个放在右下角的浮动按钮的例子：\n\n","routePath":"/v1/基础/ui/fab","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":39,"title":"帧布局: frame","content":"#\n\n帧布局是最简单的布局，它默认从容器的左上角(0,0)坐标开始布局，多个子控件层叠排序，后面的控件会覆盖前面的控件。\n\n参见 Android FrameLayout。\n\ngravity\n\n设置布局的默认重力位置。默认为容器的左上角。比如设置gravity=\"center\"后，它的子控件会默认居中显示。gravity\n的详细字段说明参见View.gravity。\n\n可以用layout_gravity单独控制子控件的重力，参见View.layout_gravity。\n\n以下是一个创建帧布局的示例代码：\n\n\n\nforeground:\n\n设置改帧布局容器的前景图像，前景图像将永远处于帧布局最上面，不会被覆盖。foreground属性的取值可以是颜色、图片路径等，和背景bg属性类似，参见bg。\n\nforegroundGravity:\n\n设置前景图像（foreground）显示的位置。属性与gravity属性相同。","routePath":"/v1/基础/ui/frame","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":40,"title":"水平布局:","content":"#\n\n水平布局是一种比较简单的布局，会把在它里面的控件按照水平方向依次摆放，如下图所示： 水平布局: ————————————————————————————\n\n| 控件1 | 控件2 | 控件3 | ... |\n\n————————————————————————————\n\n\nlayout_weight#\n\n水平布局中也可以使用layout_weight属性来控制子控件的宽度占父布局的比例。和垂直布局中类似，不再赘述。","routePath":"/v1/基础/ui/horizontal","lang":"","toc":[{"text":"layout_weight","id":"layout_weight","depth":2,"charIndex":138}],"domain":"","frontmatter":{},"version":""},{"id":41,"title":"图片控件: img","content":"#\n\n图片控件用于显示来自网络、本地或者内嵌数据的图片，并可以指定图片以圆角矩形、圆形等显示。但是不能用于显示gif动态图。\n\n这里只介绍他的主要方法和属性，如果要查看他的所有方法和属性，阅读ImageView。\n\n\nsrc#\n\n使用一个Uri指定图片的来源。可以是图片的地址(http://....)，本地路径(file://....)或者base64数据(\"data:image/png\n;base64,...\")。\n\n如果使用图片地址或本地路径，Auto.js会自动使用适当的缓存来储存这些图片，减少下次加载的时间。\n\n例如，显示百度的logo:\n\n\n\n再例如，显示文件/sdcard/1.png的图片为 <img src=\"file:///sdcard/1.png\"/>。\n再例如，使base64显示一张钱包小图片为：\n\n\n\n\ntint#\n\n图片着色，其值是一个颜色名称或RGB颜色值。使用该属性会将图片中的非透明区域都涂上同一颜色。可以用于改变图片的颜色。\n\n例如，对于上面的base64的图片: <img w=\"40\" h=\"40\" tint=\"red\"\nsrc=\"data:image/png;base64,...\"/>，则钱包图标颜色会变成红色。\n\n\nscaleType#\n\n控制图片根据图片控件的宽高放缩时的模式。可选的值为：\n\n * center 在控件中居中显示图像, 但不执行缩放。\n * centerCrop 保持图像的长宽比缩放图片, 使图像的尺寸 (宽度和高度) 等于或大于控件的相应尺寸\n   (不包括内边距padding)并且使图像在控件中居中显示。\n * centerInside 保持图像的长宽比缩放图片, 使图像的尺寸 (宽度和高度) 小于视图的相应尺寸\n   (不包括内边距padding)并且图像在控件中居中显示。\n * fitCenter 保持图像的长宽比缩放图片, 使图片的宽或高和控件的宽高相同并使图片在控件中居中显示\n * fitEnd 保持图像的长宽比缩放图片, 使图片的宽或高和控件的宽高相同并使图片在控件中靠右下角显示\n * fitStart 保持图像的长宽比缩放图片, 使图片的宽或高和控件的宽高相同并使图片在控件靠左上角显示\n * fitXY 使图片和宽高和控件的宽高完全匹配，但图片的长宽比可能不能保持一致\n * matrix 绘制时使用图像矩阵进行缩放。需要在代码中使用setImageMatrix(Matrix)函数才能生效。\n\n默认的scaleType为fitCenter；除此之外最常用的是fitXY， 他能使图片放缩到控件一样的大小，但图片可能会变形。\n\n\nradius#\n\n图片控件的半径。如果设置为控件宽高的一半并且控件的宽高相同则图片将剪切为圆形显示；否则图片为圆角矩形显示，半径即为四个圆角的半径，也可以通过radiusTopL\neft, radiusTopRight, radiusBottomLeft, radiusBottomRight等属性分别设置四个圆角的半径。\n\n例如，圆角矩形的Auto.js图标：<img w=\"100\" h=\"100\" radius=\"20\" bg=\"white\"\nsrc=\"http://www.autojs.org/assets/uploads/profile/3-profileavatar.png\" />\n\n有关该属性的单位，参见尺寸的单位: Dimension。\n\n\nradiusTopLeft#\n\n图片控件的左上角圆角的半径。有关该属性的单位，参见尺寸的单位: Dimension。\n\n\nradiusTopRight#\n\n图片控件的右上角圆角的半径。有关该属性的单位，参见尺寸的单位: Dimension。\n\n\nradiusBottomLeft#\n\n图片控件的左下角圆角的半径。有关该属性的单位，参见尺寸的单位: Dimension。\n\n\nradiusBottomRight#\n\n图片控件的右下角圆角的半径。有关该属性的单位，参见尺寸的单位: Dimension。\n\n\nborderWidth#\n\n图片控件的边框宽度。用于在图片外面显示一个边框，边框会随着图片控件的外形(圆角等)改变而相应变化。 例如, 圆角矩形带灰色边框的Auto.js图标：<img\nw=\"100\" h=\"100\" radius=\"20\" borderWidth=\"5\" borderColor=\"gray\" bg=\"white\"\nsrc=\"http://www.autojs.org/assets/uploads/profile/3-profileavatar.png\" />\n\n\nborderColor#\n\n图片控件的边框颜色。\n\n\ncircle#\n\n指定该图片控件的图片是否剪切为圆形显示。如果为true，则图片控件会使其宽高保持一致(如果宽高不一致，则保持高度等于宽度)并使圆形的半径为宽度的一半。\n\n例如，圆形的Auto.js图标：<img w=\"100\" h=\"100\" circle=\"true\" bg=\"white\"\nsrc=\"http://www.autojs.org/assets/uploads/profile/3-profileavatar.png\" />","routePath":"/v1/基础/ui/img","lang":"","toc":[{"text":"src","id":"src","depth":2,"charIndex":108},{"text":"tint","id":"tint","depth":2,"charIndex":367},{"text":"scaleType","id":"scaletype","depth":2,"charIndex":533},{"text":"radius","id":"radius","depth":2,"charIndex":1115},{"text":"radiusTopLeft","id":"radiustopleft","depth":2,"charIndex":1446},{"text":"radiusTopRight","id":"radiustopright","depth":2,"charIndex":1507},{"text":"radiusBottomLeft","id":"radiusbottomleft","depth":2,"charIndex":1569},{"text":"radiusBottomRight","id":"radiusbottomright","depth":2,"charIndex":1633},{"text":"borderWidth","id":"borderwidth","depth":2,"charIndex":1698},{"text":"borderColor","id":"bordercolor","depth":2,"charIndex":1941},{"text":"circle","id":"circle","depth":2,"charIndex":1968}],"domain":"","frontmatter":{},"version":""},{"id":42,"title":"输入框控件: input","content":"#\n\n输入框控件也是一个特殊的文本控件，因此所有文本控件的函数的属性和函数都适用于按钮控件。输入框控件有自己的属性和函数，要查看所有这些内容，阅读EditText。\n\n对于一个输入框控件，我们可以通过 text 属性设置他的内容，通过 lines 属性指定输入框的行数；在代码中通过getText()函数获取输入的内容。例如：\n\n\n\n效果如图：\n\n\n\n除此之外，输入框控件有另外一些主要属性(虽然这些属性对于文本控件也是可用的但一般只用于输入框控件)：\n\n\nhint#\n\n输入提示。这个提示会在输入框为空的时候显示出来。如图所示:\n\n\n\n上面图片效果的代码为：\n\n\n\n\ntextColorHint#\n\n指定输入提示的字体颜色。\n\n\ntextSizeHint#\n\n指定输入提示的字体大小。\n\n\ninputType#\n\n指定输入框可以输入的文本类型。可选的值为以下值及其用\"|\"的组合:\n\n * date 用于输入日期。\n * datetime 用于输入日期和时间。\n * none 没有内容类型。此输入框不可编辑。\n * number 仅可输入数字。\n * numberDecimal 可以与 number 和它的其他选项组合，以允许输入十进制数(包括小数)。\n * numberPassword 仅可输入数字密码。\n * numberSigned 可以与 number 和它的其他选项组合，以允许输入有符号的数。\n * phone 用于输入一个电话号码。\n * text 只是普通文本。\n * textAutoComplete 可以与 text 和它的其他选项结合, 以指定此字段将做自己的自动完成, 并适当地与输入法交互。\n * textAutoCorrect 可以与 text 和它的其他选项结合, 以请求自动文本输入纠错。\n * textCapCharacters 可以与 text 和它的其他选项结合, 以请求大写所有字符。\n * textCapSentences 可以与 text 和它的其他选项结合, 以请求大写每个句子里面的第一个字符。\n * textCapWords 可以与 text 和它的其他选项结合, 以请求大写每个单词里面的第一个字符。\n * textEmailAddress 用于输入一个电子邮件地址。\n * textEmailSubject 用于输入电子邮件的主题。\n * textImeMultiLine 可以与 text 和它的其他选项结合，以指示虽然常规文本视图不应为多行, 但如果可以, 则 IME 应提供多行支持。\n * textLongMessage 用于输入长消息的内容。\n * textMultiLine 可以与 text 和它的其他选项结合, 以便在该字段中允许多行文本。如果未设置此标志, 则文本字段将被限制为单行。\n * textNoSuggestions 可以与 text 及它的其他选项结合, 以指示输入法不应显示任何基于字典的单词建议。\n * textPassword 用于输入密码。\n * textPersonName 用于输入人名。\n * textPhonetic 用于输入拼音发音的文本, 如联系人条目中的拼音名称字段。\n * textPostalAddress 用于输入邮寄地址。\n * textShortMessage 用于输入短的消息内容。\n * textUri 用于输入一个 URI。\n * textVisiblePassword 用于输入可见的密码。\n * textWebEditText 用于输入在 web 表单中的文本。\n * textWebEmailAddress 用于在 web 表单里输入一个电子邮件地址。\n * textWebPassword 用于在 web 表单里输入一个密码。\n * time 用于输入时间。\n\n例如，想指定一个输入框的输入类型为小数数字，为: <input inputType=\"number|numberDecimal\"/>\n\n\npassword#\n\n指定输入框输入框是否为密码输入框。默认为false。\n\n例如：<input password=\"true\"/>\n\n\nnumeric#\n\n指定输入框输入框是否为数字输入框。默认为false。\n\n例如：<input numeric=\"true\"/>\n\n\nphoneNumber#\n\n指定输入框输入框是否为电话号码输入框。默认为false。\n\n例如：<input phoneNumber=\"true\"/>\n\n\ndigits#\n\n指定输入框可以输入的字符。例如，要指定输入框只能输入\"1234567890+-\"，为<input digits=\"1234567890+-\"/>。\n\n\nsingleLine#\n\n指定输入框是否为单行输入框。默认为false。您也可以通过lines=\"1\"来指定单行输入框。\n\n例如：<input singleLine=\"true\"/>","routePath":"/v1/基础/ui/input","lang":"","toc":[{"text":"hint","id":"hint","depth":2,"charIndex":228},{"text":"textColorHint","id":"textcolorhint","depth":2,"charIndex":284},{"text":"textSizeHint","id":"textsizehint","depth":2,"charIndex":315},{"text":"inputType","id":"inputtype","depth":2,"charIndex":345},{"text":"password","id":"password","depth":2,"charIndex":1668},{"text":"numeric","id":"numeric","depth":2,"charIndex":1737},{"text":"phoneNumber","id":"phonenumber","depth":2,"charIndex":1804},{"text":"digits","id":"digits","depth":2,"charIndex":1881},{"text":"singleLine","id":"singleline","depth":2,"charIndex":1966}],"domain":"","frontmatter":{},"version":""},{"id":43,"title":"线性布局: linear","content":"#\n\n实际上，垂直布局和水平布局都属于线性布局。线性布局有一个orientation的属性，用于指定布局的方向，可选的值为vertical和horizontal。\n\n例如<linear orientation=\"vertical\"></linear>相当于<vertical></vertical>。\n\n线性布局的默认方向是横向的，因此，一个没有指定orientation属性的线性布局就是横向布局。","routePath":"/v1/基础/ui/linear","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":44,"title":"列表: list","content":"#\n\n官方教程：\n\n参见 Android RecyclerView\n\n事件: item_click:\n\n当用户点击一个 List 中的项时会触发该事件。\n\n例子：\n\n\n\n事件: item_click:\n\n * item {any} 被点击的列表项的数据\n * i {number} 被点击的列表项的位置\n * itemView {View} 被点击的列表项的 View\n * listView {View} 当前列表控件\n\n当用户点击一个 List 中的项时会触发该事件。\n\n例子：\n\n\n\n事件: item_long_click:\n\n * event{object} 事件，字段有：\n   * consumed {boolean} 设置此事件是否被消费\n   * view {View} 此事件对应的 View\n * item {any} 被点击的列表项的数据\n * i {number} 被点击的列表项的位置\n * itemView {View} 被点击的列表项的 View\n * listView {View} 当前列表控件\n\n当用户长按一个 List 中的项时会触发该事件。\n\n事件: item_bind:\n\n * itemView {View} 当前列表项的 View\n * itemHolder{object} 当前列表项的管理对象，可动态获取列表项的位置和数据。\n   * item {any} 获取列表项的数据\n   * position {number} 获取列表项的位置\n\n当列表创建一个新的列表项的 View 时触发该事件。实际上列表控件不会为列表控件的每个项目创建一个单独的 View，假设列表为 2000 个，屏幕最多显示 10\n个，那么列表控件只会创建 10 个左右的 View。\n\n这个事件通常用于对列表项的 View 设置事件回调，比如：\n\n\n\n事件: item_data_bind:\n\n * itemView {View} 当前列表项的 View\n * itemHolder{object} 当前列表项的管理对象，可获取列表项的位置和数据。\n   * item {any} 获取列表项的数据\n   * position {number} 获取列表项的位置\n\n当列表将一个列表项的数据绑定到列表项的 View 时触发该事件。\n\n例子:\n\n","routePath":"/v1/基础/ui/list","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":45,"title":"进度条控件: progressbar","content":"#\n\n官方教程：\n\nprogressbar 即进度条控件，显示某种操作的进度及百分比。通过修改进度条控件的参数可以修改进度条的呈现形式，默认为无限圆形进度条。\n\n参见 Android ProgressBar\n\nindeterminate:\n\n * {boolean}\n\n是否为无限进度条，默认为true。可选的值为：\n\n * true 显示无限进度条\n * false 显示有限进度条\n\nprogress:\n\n * {number}\n\n进度条的进度，为一个整数，默认范围是 0~100。\n\nmin:\n\n * {number}\n\n进度条的最小进度，默认为 0。\n\nmax:\n\n * {number}\n\n进度条的最大进度，默认为 100。\n\nprogressDrawable:\n\n * {string}\n\n定义用于在 progress 模式下绘制进度条的 drawable。\n\nprogressBackgroundTint:\n\n * {string}\n\n对 progress 的背景应用颜色。不修改当前的着色模式。\n\nprogressBackgroundTintMode:\n\n * \"add\" | \"multiply\" | \"screen\" | \"src_atop\" | \"src_in\" | \"src_over\"\n\n将 progressBackgroundTint 指定的色调应用到进度背景的混合模式。\n\nprogressTint:\n\n * {string}\n\n将颜色应用于整个可绘制的进度。不修改当前的着色模式。\n\nprogressTintMode:\n\n * \"add\" | \"multiply\" | \"screen\" | \"src_atop\" | \"src_in\" | \"src_over\"\n\n将 progressTint 指定的色调应用到进度背景的混合模式。\n\nsecondaryProgress:\n\n * {number}\n\n设置次要进度的值。如果进度条处于 indeterminate（无限进度条）模式，则不执行任何操作。\n\nsecondaryProgressTint:\n\n * {string}\n\n对 secondaryProgress 应用色调（如果存在）。不修改当前的着色模式。\n\nsecondaryProgressTintMode:\n\n * \"add\" | \"multiply\" | \"screen\" | \"src_atop\" | \"src_in\" | \"src_over\"\n\n将 secondaryProgressTint 指定的色调应用到辅助进度指示器的混合模式。\n\nstyle:\n\n * {string}\n\n设置进度条的宽度、布局样式。可选的值有：\n\n * @style/Base.Widget.AppCompat.ProgressBar.Horizontal 水平直线进度条\n * @style/Base.Widget.AppCompat.ProgressBar 圆形进度条","routePath":"/v1/基础/ui/progressbar","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":46,"title":"单选框控件: radio","content":"#\n\n单选按钮用于在多个互斥的选项中选择一个。在 Auto.js 中，通常将多个单选按钮放在一个 RadioGroup 中，以确保只能选择其中一个。\n\n创建单选按钮\n\n以下是一个创建单选按钮的示例代码：\n\n\n\n在上述代码中：\n\n<radiogroup id=\"rg\">:定义了一个单选按钮组，所有包含在其中的单选按钮将互斥。\n\n<radio id=\"rb1\" text=\"选项1\" checked=\"{{true}}\" /> :创建了一个单选按钮，并设置了初始状态为选中。\n其他两个单选按钮（rb2和rb3）初始状态为未选中。\n\n获取选中的单选按钮\n\n要获取当前选中的单选按钮，可以通过遍历 RadioGroup 中的单选按钮来实现。\n\n以下是一个获取选中单选按钮的示例代码：\n\n\n\n在上述代码中：\n\nui.rg.getChildCount():获取单选按钮组中的子控件数量。\n\nui.rg.getChildAt(i):获取第 i 个子控件（即单选按钮）。\n\nradio.checked:判断当前单选按钮是否被选中。\n\ntoast(\"选中的选项：\" + radio.text):显示当前选中的选项文本。\n\n官方教程：\n\n单选框只能选中一个选项，一般与 radiogroup 搭配使用。\n\n参见 Android RadioButton\n\ntext:\n\nradio 控件的文本，显示在单选框后面。实际上 radio 控件也继承于text和button控件，它们的属性也可以用在 radio\n上，比如textSize, textStyle。\n\nchecked:\n\n设置 radio 单选框的选中状态，当checked=\"true\"为选中选项框，否则为未选中选项框。\n\nenabled:\n\n设置单选框是否是启用的，若enabled=\"false\"则为禁用状态，显示未灰色，无法交互。\n\nisChecked():\n\n * 返回 {boolean}\n\n返回选项框是否被选中，是则返回true，否则返回false。例如$ui.radio1.isChecked()。\n\ncheck:\n\n * checked {boolean} 是否被勾选\n * view {View} 当前事件的 View\n\n当用户勾选/取消勾选选项框时会触发该事件。\n\n例子：\n\n","routePath":"/v1/基础/ui/radio","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":47,"title":"单选框组控件: radiogroup","content":"#\n\n1.垂直布局\n\n垂直布局是将选择框控件按从上到下的顺序排列。这是最常见的布局方式，特别适合选项较少的情况。\n\n示例代码:\n\n\n\n在上述代码中：\n\n使用<vertical>标签将所有控件按垂直方向排列。\n\n单选按钮被包含在一个<radiogroup>中，确保只能选择一个选项。\n\n复选框则单独排列，允许用户选择多个选项。\n\n2.水平布局\n\n水平布局是将选择框控件按从左到右的顺序排列。这种布局适合选项较少且希望节省垂直空间的情况。\n\n示例代码:\n\n\n\n在上述代码中：\n\n使用<horizontal>标签将选择框控件按水平方向排列。\n\n单选按钮和复选框都被包含在各自的<horizontal>标签中，实现水平布局。\n\n3.网格布局\n\n网格布局是将选择框控件按行和列的方式排列，适合选项较多的情况，可以更有效地利用屏幕空间。\n\n示例代码:\n\n\n\n在上述代码中：\n\n使用<grid>标签将选择框控件按网格方式排列。\n\ncolumns=\"2\"属性指定了每行显示两个控件。\n\n单选按钮和复选框都被包含在各自的<grid>标签中，实现网格布局。\n\n4.响应式布局\n\n为了适应不同屏幕尺寸，可以使用**权重（weight）**来实现响应式布局。权重可以让控件按比例分配可用空间。\n\n示例代码:\n\n\n\n在上述代码中:\n\nlayout_weight=\"1\"使用属性为每个选择框控件设置了相同的权重。 这样，每个控件将平分水平方向上的可用空间，实现响应式布局。\n\n5.完整示例\n\n以下是一个完整的示例代码，结合了垂直布局、水平布局和网格布局：\n\n\n\n官方教程：\n\nradiogroup 单选框组合提供了几个单选框 radio 选项，但用户至多只能选择其中一个选项，即实现选项选中互斥功能。\n\n参见 Android RadioGroup\n\ncheckedButton:\n\n设置 radiogroup 单选框组合中初始勾选的单选框 id。例如checkedButton=\"@+id/radio5\"，则使 id 为 radio5\n的单选框选项为初始勾选状态。\n\n例子：\n\n\n\nsetOnCheckedChangeListener(listener):\n\nlistener{Function} 勾选监听的回调函数，其参数为:\n\n * group {RadioGroup} 发生勾选变化事件的 radiogroup 对象\n\n * checkedId {number} 被勾选的 radio 的 id，是一个整数；若当前没有任何单选框被勾选，则为-1\n   \n   设置某个 radiogroup 单选框组合中的单选框被选中时的监听。需要注意的是这里的checkedId是一个整数，并不是类似于radio5这样的 id\n   字符串，我们可以通过findViewById()函数来获取具体被勾选的单选框，比如：\n   \n   \n\ngetCheckedRadioButtonId():\n\n * 返回 {number}\n\n获取单选框组合中的已勾选的单选框选项的整数 ID，若当前没有任何单选框被勾选，则为-1。\n\n需要注意的是这里的checkedId是一个整数，并不是类似于radio5这样的 id\n字符串，我们可以通过findViewById()函数来获取具体被勾选的单选框。\n\n进一步，我们可以通过indexOfChild获取被勾选的单选框在 radiogroup 中的位置。\n\n例如：\n\n\n\nclearCheck():\n\n清空单选框组合的各单选框选项的勾选状态。也即让单选框组合重置为未勾选状态。\n\n例如:\n\n","routePath":"/v1/基础/ui/radiogroup","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":48,"title":"相对布局: relative","content":"#\n\n相对布局会把在它里面的控件以父容器和兄弟控件作为参照来确定控件的位置。\n\n参见 Android RelativeLayout。\n\n\n以父容器作为参照物#\n\n在相对布局中，可以以父容器作为参照物来确定其他控件的位置。\n\n————— ————— ————— ————— ————— —————\n\n| 控件 1：左上角 | | 控件 4：上居中 | | 控件 7：右上角 |\n\n| 控件 2：左居中 | | 控件 5：（居中)| | 控件 8：右居中 |\n\n| 控件 3：左下角 | | 控件 6：下居中 | | 控件 9：右下角 |\n\n————— ————— ————— ————— ————— —————\n\n在以父容器作为参照物中，属性如下：\n\n * layout_alignParentLeft=\"true\" 以父容器为参照物，使控件贴在父容器的左边。\n * layout_alignParentRight=\"true\" 以父容器为参照物，使控件贴在父容器的右边。\n * layout_alignParentTop=\"true\" 以父容器为参照物，使控件贴在父容器的顶部。\n * layout_alignParentBottom=\"true\" 以父容器为参照物，使控件贴在父容器的底部。\n * layout_centerHorizontal=\"true\" 以父容器为参照物，使控件在父容器的水平方向居中。\n * layout_centerVertical=\"true\" 以父容器为参照物，使控件在父容器的垂直方向居中。\n * layout_centerInParent=\"true\" 以父容器为参照物，使控件在父容器的水平、垂直方向都居中。\n\n可以通过这 6\n个属性的组合让控件处于父容器的左上角、右上角、左下角、右下角、上居中、下居中、左居中、右居中、正居中的位置。例如给一个控件添加layout_alignParen\ntLeft=\"true\"和layout_alignParentBottom=\"true\"属性后，该空间将以父容器为参照物，使控件位于父容器的左下角。\n\n示例：\n\n\n\n\n以兄弟控件作为参照物#\n\n在相对布局中，以兄弟控件（已经确定好位置的控件）作为参照物来确定其他控件的位置。\n\n————— ————— ————— ————— ————— —————\n\n| 控件 2：左上角 | | 控件 5：正上方 | | 控件 7：右上角 |\n\n| 控件 3：正左方 | | 控件 1：基准兄弟控件| | 控件 8：正右方 |\n\n| 控件 4：左下角 | | 控件 6：正下方 | | 控件 9：右下角 |\n\n————— ————— ————— ————— ————— —————\n\n在以兄弟控件（button1）作为参照物中，属性如下：\n\n * layout_toRightOf=\"@+id/button1\" 以兄弟控件（button1）作为参照物，使控件在兄弟控件 button1 的下方。\n * layout_toRightOf=\"@+id/button1\" 以兄弟控件（button1）作为参照物，使控件在兄弟控件 button1 的右方。\n * layout_above=\"@+id/button1\" 以兄弟控件（button1）作为参照物，使控件在兄弟控件 button1 的上方。\n * layout_below=\"@+id/button1\" 以兄弟控件（button1）作为参照物，使控件在兄弟控件 button1 的下方。\n * layout_alignLeft=\"@+id/button1\" 以兄弟控件（button1）作为参照物，使控件与兄弟控件 button1 的左方平齐。\n * layout_alignRight=\"@+id/button1\" 以兄弟控件（button1）作为参照物，使控件与兄弟控件 button1 的右方平齐。\n * layout_alignTop=\"@+id/button1\" 以兄弟控件（button1）作为参照物，使控件与兄弟控件 button1 的上方平齐。\n * layout_alignBottom=\"@+id/button1\" 以兄弟控件（button1）作为参照物，使控件与兄弟控件 button1 的下方平齐。\n\n可以通过这 8\n个属性的组合让控件处于兄弟控件的左上角、右上角、左下角、右下角、正上方、正下方、正左方、正右方等位置。例如给一个控件添加layout_toRightOf=\"@+\nid/button1\"和layout_above=\"@+id/button1\"属性后，该空间将以兄弟控件为参照物，使控件位于兄弟控件的右上角（两个控件的右侧边缘\n在同一垂线）。\n\n相对布局里以兄弟控件为参照物确定控件的位置的示例如下：\n\n","routePath":"/v1/基础/ui/relative","lang":"","toc":[{"text":"以父容器作为参照物","id":"以父容器作为参照物","depth":3,"charIndex":68},{"text":"以兄弟控件作为参照物","id":"以兄弟控件作为参照物","depth":3,"charIndex":897}],"domain":"","frontmatter":{},"version":""},{"id":49,"title":"拖动条控件: seekbar","content":"#\n\n官方教程：\n\n可调节进度条，类似于 progressbar，但用户可以拖动控件来调节进度条。\n\n参见 Android SeekBar\n\nseekbar 继承自 progressbar，因此 progressbar 的属性它都能使用。\n\n通过方法setOnSeekBarChangeListener可监听 seekbar 的拖动进度，通过getProgress方法可随时获得 seekbar\n的当前进度。\n\n例子：\n\n","routePath":"/v1/基础/ui/seekbar","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":50,"title":"下拉菜单控件: spinner","content":"#\n\n官方教程：\n\n点击下拉箭头，可弹出多个选项供用户选择。\n\n参见 Android Spinner\n\nspinnerMode:\n\n * {string}\n\n下拉菜单的呈现模式。默认为 dropdown 下拉菜单形式。\n\n * dialog 使用对话框模式菜单来选择 spinner 选项。\n * dropdown使用下拉模式菜单来选择 spinner 选项。\n\ndropDownHorizontalOffset:\n\n * {string}\n\n为 spinner 的选择弹出窗口设置水平偏移。仅在 spinnerMode=dropdown时有效。\n\ndropDownVerticalOffset:\n\n * {string}\n\n为 spinner 的选择弹出窗口设置垂直偏移。仅在 spinnerMode=dropdown时有效。\n\ndropDownWidth:\n\n * {string}\n\n设置 spinner 的选择弹出窗口的宽度。仅在 spinnerMode=dropdown时有效。\n\npopupBackground:\n\n * {string}\n\n为 spinner 的选择弹出窗口设置背景。仅在 spinnerMode=dropdown时有效。\n\nprompt：\n\n * {string}\n\n设置显示对话框时显示的提示。\n\ntextStyle:\n\n * {string}\n\n设置 spinner 当前被选择的项目文本的样式，例如bold(加粗), italic(斜体)等。\n\ntextColor:\n\n * {string}\n\n设置 spinner 当前被选择的项目文本的颜色，例如bold(加粗), italic(斜体)等。\n\ntextSize:\n\n * {string}\n\n设置 spinner 当前被选择的项目文本的字体尺寸大小。\n\nentries:\n\n * {string}\n\n下拉菜单的选项具体内容。若有多个选项，可使用|隔开，例如 entries=\"选项 1|选项 2|选项\n3\"。在代码中也可动态修改，比如$ui.spinner.attr('entries', '选项A|选项B|选项C|选项D')。\n\nentryTextStyle:\n\n * {string}\n\n下拉菜单的选项具体内容的文本样式。\n\nentryTextColor:\n\n * {string}\n\n下拉菜单的选项具体内容的文本颜色。\n\nentryTextSize:\n\n * {string}\n\n下拉菜单的选项具体内容的字体尺寸大小。","routePath":"/v1/基础/ui/spinner","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":51,"title":"开关控件: switch","content":"#\n\n在 Auto.js 中，开关控件（Switch）\n是一种常用的用户界面元素，用于表示两种互斥的状态，通常为“开”和“关”。用户可以通过滑动或点击来切换开关的状态。\n\n以下是关于如何在 Auto.js 中使用开关控件的详细教程。\n\n1.创建开关控件\n\n要创建一个开关控件，可以使用 ui.Switch 函数，并传入相应的参数来设置其属性。\n\n以下是一个创建开关控件的示例代码：\n\n\n\n在上述代码中：\n\nid=\"sw\":为开关控件设置了一个唯一的标识符，以便后续可以通过该 ID 来引用和操作该控件。\n\ntext=\"启用功能\":设置了开关控件旁边显示的文本标签，用于向用户说明该开关的功能。\n\nchecked=\"{{false}}\":初始化开关控件的状态为“关”（false）。如果希望初始状态为“开”，可以将值设置为 true。\n\n2.获取和设置开关状态\n\n获取开关状态\n\n要获取开关控件的当前状态，可以使用 ui.sw.checked 属性。\n\n以下是一个获取开关状态的示例代码：\n\n\n\n在上述代码中：\n\nui.sw.on(\"check\", function(checked)\n{...}):为开关控件注册了一个check事件监听器，当开关的状态发生变化时，会触发该事件，并传递当前的状态（checked）作为参数。\n\ntoast(\"当前开关状态：\" + (checked ? \"开\" :\n\"关\")):使用toast函数显示当前的开关状态。如果checked为true，则显示“开”；否则显示“关”。\n\n设置开关状态\n\n要设置开关控件的状态，可以直接修改ui.sw.checked属性的值。\n\n以下是一个设置开关状态的示例代码：\n\n\n\n或者，你也可以在创建开关控件时，通过checked属性来设置初始状态，如之前所示。\n\n3.监听开关事件\n\n除了check事件外，还可以为开关控件注册其他事件监听器，例如click事件。\n\n以下是一个监听开关点击事件的示例代码：\n\n\n\n在上述代码中：\n\nui.sw.on(\"click\", function() {...}):为开关控件注册了一个click事件监听器，当用户点击开关时，会触发该事件。\n\ntoast(\"开关被点击\"):使用toast函数显示一条提示信息，表示开关被点击。\n\n4.完整示例\n\n以下是一个完整的示例代码，演示了如何创建开关控件、获取和设置其状态，以及监听相关事件：\n\n\n\n在上述代码中：\n\n创建了一个开关控件（id=\"sw\"），并设置了初始状态为“关”。 添加了两个按钮控件，分别用于获取开关的当前状态和设置开关为“开”状态。\n为开关控件注册了check事件监听器，用于实时显示当前的开关状态。 为获取状态按钮注册了click事件监听器，用于显示当前的开关状态。\n为设置状态按钮注册了click事件监听器，用于将开关设置为“开”状态。\n\n官方教程：\n\n开关控件用于表示一个选项是否被启用。\n\n参见 Android Switch\n\ntext:\n\nSwitch 控件的文本，显示在框后面。实际上 Switch 控件也继承于text和button控件，它们的属性也可以用在 Switch\n上，比如textSize, textStyle。\n\nchecked:\n\n设置 Switch 开关的开启状态，当checked=\"true\"时为开启。\n\nenabled:\n\n设置 Switch 开关是否是启用的，若enabled=\"false\"则为禁用状态，显示未灰色，无法交互。\n\nisChecked():\n\n * 返回 {boolean}\n\n返回 Switch 控件是否是开启状态。比如$ui.switch1.isChecked()。\n\n事件: check:\n\n * checked {boolean} 是否被勾选\n * view {View} 当前事件的 View\n\n当用户勾选/取消勾选选项框时会触发该事件。\n\n例子：\n\n","routePath":"/v1/基础/ui/switch","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":52,"title":"Tab: tab","content":"#\n\n官方教程：\n\n参见 Android TabLayout\n\n选项卡布局。\n\ntabGravity\n\n设置布局选项卡时使用的 gravity 重力。可以参考博客tabMode 和 tabGravity 配合使用效果对比。\n\ntabIndicatorColor:\n\n为当前选定的选项卡设置选项卡指示器的颜色。\n\ntabIndicatorHeight:\n\n为当前选定的选项卡设置选项卡指示器的高度。\n\ntabMode:\n\n设置此布局中选项卡的行为模式。包括：\n\n * fixed 固定选项卡同时显示所有选项卡，最适合与受益于选项卡之间快速旋转的内容一起使用。\n * scrollable\n   可滚动选项卡在任何给定时刻显示选项卡的子集，并且可以包含更长的选项卡标签和更多的选项卡。当用户不需要直接比较选项卡标签时，它们最适合用于浏览触摸界面中的上\n   下文。\n\ntabTextColor:\n\n设置用于选项卡的正常状态的文本颜色。\n\ntabSelectedTextColor:\n\n设置用于选项卡的选定状态的文本颜色。","routePath":"/v1/基础/ui/tab","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":53,"title":"文本控件: text","content":"#\n\n文本控件用于显示文本，可以控制文本的字体大小，字体颜色，字体等。\n\n> 继承于视图(View)，可使用View的所有属性\n\n以下介绍该控件的主要属性和方法，如果要查看他的所有属性和方法，请阅读TextView。\n\n\ntext#\n\n设置文本的内容。例如text=\"一段文本\"。\n\n\ntextColor#\n\n设置字体的颜色，可以是RGB格式的颜色(例如#ff00ff)，或者颜色名称(例如red, green等)，具体参见颜色。\n\n示例, 红色字体：\n\n\n\n\ntextSize#\n\n设置字体的大小，单位一般是sp。按照Material Design的规范，正文字体大小为14sp，标题字体大小为18sp，次标题为16sp。\n\n示例，超大字体:\n\n\n\n\ntextStyle#\n\n设置字体的样式，比如斜体、粗体等。可选的值为：\n\n * bold 加粗字体\n * italic 斜体\n * normal 正常字体\n\n可以用或(\"|\")把他们组合起来，比如粗斜体为\"bold|italic\"。\n\n例如，粗体：\n\n\n\n\nlines#\n\n设置文本控件的行数。即使文本内容没有达到设置的行数，控件也会留出相应的宽度来显示空白行；如果文本内容超出了设置的行数，则超出的部分不会显示。\n\n另外在xml中是不能设置多行文本的，要在代码中设置。例如:\n\n\n\n\nmaxLines#\n\n设置文本控件的最大行数。\n\n\nminLines#\n\n设置文本控件的最小行数。\n\n\ntypeface#\n\n设置字体。可选的值为：\n\n * normal 正常字体\n * sans 衬线字体\n * serif 非衬线字体\n * monospace 等宽字体\n\n示例，等宽字体: <text text=\"等宽字体\" typeface=\"monospace\"/>\n\n\nellipsize#\n\n设置文本的省略号位置。文本的省略号会在文本内容超出文本控件时显示。可选的值为：\n\n * end 在文本末尾显示省略号\n * marquee 跑马灯效果，文本将滚动显示\n * middle 在文本中间显示省略号\n * none 不显示省略号\n * start 在文本开头显示省略号\n\n\nems#\n\n当设置该属性后,TextView显示的字符长度（单位是em）,超出的部分将不显示，或者根据ellipsize属性的设置显示省略号。\n\n例如，限制文本最长为5em: `\n\n\nautoLink#\n\n控制是否自动找到url和电子邮件地址等链接，并转换为可点击的链接。默认值为“none”。\n\n设置该值可以让文本中的链接、电话等变成可点击状态。\n\n可选的值为以下的值以其通过或(\"|\")的组合：\n\n * all 匹配所有连接、邮件、地址、电话\n * email 匹配电子邮件地址\n * map 匹配地图地址\n * none 不匹配 (默认)\n * phone 匹配电话号码\n * web 匹配URL地址\n\n示例：<text autoLink=\"web|phone\" text=\"百度: http://www.baidu.com 电信电话: 10000\"/>","routePath":"/v1/基础/ui/text","lang":"","toc":[{"text":"text","id":"text","depth":2,"charIndex":110},{"text":"textColor","id":"textcolor","depth":2,"charIndex":142},{"text":"textSize","id":"textsize","depth":2,"charIndex":230},{"text":"textStyle","id":"textstyle","depth":2,"charIndex":326},{"text":"lines","id":"lines","depth":2,"charIndex":455},{"text":"maxLines","id":"maxlines","depth":2,"charIndex":569},{"text":"minLines","id":"minlines","depth":2,"charIndex":595},{"text":"typeface","id":"typeface","depth":2,"charIndex":621},{"text":"ellipsize","id":"ellipsize","depth":2,"charIndex":759},{"text":"ems","id":"ems","depth":2,"charIndex":913},{"text":"autoLink","id":"autolink","depth":2,"charIndex":1005}],"domain":"","frontmatter":{},"version":""},{"id":54,"title":"时间选择控件: timepicker","content":"#\n\n官方教程：\n\n用户可以选择 24 小时内的任意时间，呈现内容为上午/下午 XX（时）：XX（分）。\n\n参见 Android TimePicker\n\ntimePickerMode：\n\n * {string}\n\n时间选择界面的呈现模式。若用户在 timePicker 控件中未指定 timePickerMode，则默认使用时钟样式clock时间选择。\n\n * spinner 滑动样式时间选择模式。\n * clock 时钟样式。","routePath":"/v1/基础/ui/timepicker","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":55,"title":"标题栏控件: toolbar","content":"#\n\n官方教程：\n\n应用程序中使用的标题栏。\n\n\nlogo#\n\n为标题栏设置一个可绘制的 logo。\n\nlogoDescription:\n\n为标题栏设置 logo 的描述。\n\nnavigationIcon:\n\n为标题栏设置导航按钮的内容描述（如果存在）。内容描述将通过屏幕阅读器或其他辅助系统阅读，以解释导航按钮的操作。\n\npopupTheme:\n\n指定标题栏弹出菜单时使用的主题。默认情况下，使用与标题栏本身相同的主题。\n\ntitle:\n\n设置此标题栏的标题。标题应该用作内容部分的锚点。它应该描述或命名正在查看的内容。\n\ntitleTextColor:\n\n设置此标题栏的标题的文本颜色。\n\ntitleMargin:\n\n设置标题边距。\n\ntitleMarginBottom:\n\n设置底部标题边距。\n\ntitleMarginTop:\n\n设置顶部标题边距。\n\ntitleMarginStart:\n\n设置起始标题边距。\n\ntitleMarginEnd:\n\n设置结束标题边距。\n\nsubtitle:\n\n设置此标题栏的副标题。\n\nsubtitleTextColor:\n\n设置此标题栏的副标题的文本颜色。","routePath":"/v1/基础/ui/toolbar","lang":"","toc":[{"text":"logo","id":"logo","depth":3,"charIndex":24}],"domain":"","frontmatter":{},"version":""},{"id":56,"title":"垂直布局: vertical","content":"#\n\n垂直布局是一种比较简单的布局，会把在它里面的控件按照垂直方向依次摆放，如下图所示：\n\n垂直布局:\n\n—————\n\n| 控件1 |\n\n| 控件2 |\n\n| 控件3 |\n\n| ............ |\n\n——————\n\n\nlayout_weight#\n\n垂直布局中的控件可以通过layout_weight属性来控制控件高度占垂直布局高度的比例。如果为一个控件指定layout_weight,\n则这个控件的高度=垂直布局剩余高度 * layout_weight / weightSum；如果不指定weightSum,\n则weightSum为所有子控件的layout_weight之和。所谓\"剩余高度\"，指的是垂直布局中减去没有指定layout_weight的控件的剩余高度。\n例如:\n\n\n\n在这个布局中，三个控件的layout_weight都是1，也就是他们的高度都会占垂直布局高度的1/3，都是33.3dp. 再例如：\n\n\n\n在这个布局中，第一个控件高度为1/4, 第二个控件为2/4, 第三个控件为1/4. 再例如：\n\n\n\n在这个布局中，因为指定了weightSum为5, 因此第一个控件高度为1/5, 第二个控件为2/5, 第三个控件为1/5. 再例如：\n\n\n\n在这个布局中，第一个控件并没有指定layout_weight, 而是指定高度为40dp,\n因此不加入比例计算，此时布局剩余高度为60dp。第二个控件高度为剩余高度的2/3，也就是40dp，第三个控件高度为剩余高度的1/3，也就是20dp。\n\n垂直布局的layout_weight属性还可以用于控制他的子控件高度占满剩余空间，例如：\n\n\n\n在这个布局中，第三个控件的高度会占满除去控件1和控件2的剩余空间。","routePath":"/v1/基础/ui/vertical","lang":"","toc":[{"text":"layout_weight","id":"layout_weight","depth":2,"charIndex":113}],"domain":"","frontmatter":{},"version":""},{"id":57,"title":"视图: View","content":"#\n\n控件和布局都继承于视图(View)。 本节将介绍视图(View)的属性和方法，这些属性和方法可在所有控件和布局中使用，例如背景，宽高，点击回调click()等。\n\n\nw#\n\nView的宽度，是属性width的缩写形式。可以设置的值为*,\nauto和具体数值。其中*表示宽度尽量填满父布局，而auto表示宽度将根据View的内容自动调整(自适应宽度)。例如：\n\n\n\n在这个例子中，第一个按钮为自适应宽度，第二个按钮为填满父布局，显示效果为：\n\n\n\n如果不设置该属性，则不同的控件和布局有不同的默认宽度，大多数为auto。\n\n宽度属性也可以指定一个具体数值。例如w=\"20\"，w=\"20px\"等。不加单位的情况下默认单位为dp，其他单位包括px(像素), mm(毫米),\nin(英寸)。有关尺寸单位的更多内容，参见尺寸的单位: Dimension。\n\n\n\n\nh#\n\nView的高度，是属性height的缩写形式。可以设置的值为*,\nauto和具体数值。其中*表示宽度尽量填满父布局，而auto表示宽度将根据View的内容自动调整(自适应宽度)。\n\n如果不设置该属性，则不同的控件和布局有不同的默认高度，大多数为auto。\n\n宽度属性也可以指定一个具体数值。例如h=\"20\"，h=\"20px\"等。不加单位的情况下默认单位为dp，其他单位包括px(像素), mm(毫米),\nin(英寸)。有关尺寸单位的更多内容，参见尺寸的单位: Dimension。\n\n\nid#\n\nView的id，用来区分一个界面下的不同控件和布局，一个界面的id在同一个界面下通常是唯一的，也就是一般不存在两个View有相同的id。id属性也是连接xml布\n局和JavaScript代码的桥梁，在代码中可以通过一个View的id来获取到这个View，并对他进行操作(设置点击动作、设置属性、获取属性等)。例如：\n\n\n\n这个例子中有一个按钮控件\"确定\"，id属性为\"ok\"，那么我们可以在代码中使用ui.ok来获取他，再通过getText()函数获取到这个按钮控件的文本内容。\n另外这个例子中使用帧布局(frame)是因为，我们只有一个控件，因此用于最简单的布局帧布局。\n\n\ngravity#\n\nView的\"重力\"。用于决定View的内容相对于View的位置，可以设置的值为:\n\n * left 靠左\n * right 靠右\n * top 靠顶部\n * bottom 靠底部\n * center 居中\n * center_vertical 垂直居中\n * center_horizontal 水平居中\n\n例如对于一个按钮控件，gravity=\"right\"会使其中的文本内容靠右显示。例如：\n\n\n\n显示效果为:\n\n\n\n这些属性是可以组合的，例如gravity=\"right|bottom\"的View他的内容会在右下角。\n\n\nlayout_gravity#\n\nView在布局中的\"重力\"，用于决定View本身在他的父布局的位置，可以设置的值和gravity属性相同。注意把这个属性和gravity属性区分开来。\n\n\n\n在这个例子中，我们让帧布局(frame)的大小占满整个屏幕，通过给第一个按钮设置属性layout_gravity=\"center\"来使得按钮在帧布局中居中，通过\n给第二个按钮设置属性layout_gravity=\"right|bottom\"使得他在帧布局中位于右下角。效果如图：\n\n\n\n要注意的是，layout_gravity的属性不一定总是生效的，具体取决于布局的类别。例如不能让水平布局中的第一个子控件靠底部显示(否则和水平布局本身相违背)。\n\n\nmargin#\n\nmargin为View和其他View的间距，即外边距。margin属性包括四个值:\n\n * marginLeft 左外边距\n * marginRight 右外边距\n * marginTop 上外边距\n * marginBottom 下外边距\n\n而margin属性本身的值可以有三种格式:\n\n * margin=\"marginAll\" 指定各个外边距都是该值。例如margin=\"10\"表示左右上下边距都是10dp。\n * margin=\"marginLeft marginTop marginRight marginBottom\" 分别指定各个外边距。例如margin=\"10\n   20 30 40\"表示左边距为10dp, 上边距为20dp, 右边距为30dp, 下边距为40dp\n * margin=\"marginHorizontal marginVertical\" 指定水平外边距和垂直外边距。例如margin=\"10\n   20\"表示左右边距为10dp, 上下边距为20dp。\n\n用一个例子来具体理解外边距的含义：\n\n\n\n第一个按钮的margin属性指定了他的边距为30dp, 也就是他与水平布局以及第二个按钮的间距都是30dp, 其显示效果如图:\n\n\n\n如果把margin=\"30\"改成margin=\"10 40\"那么第一个按钮的左右间距为10dp, 上下间距为40dp, 效果如图:\n\n\n\n有关margin属性的单位，参见尺寸的单位: Dimension。\n\n\nmarginLeft#\n\nView的左外边距。如果该属性和margin属性指定的值冲突，则在后面的属性生效，前面的属性无效，例如margin=\"20\"\nmarginLeft=\"10\"的左外边距为10dp，其他外边距为20dp。\n\n\n\n第一个按钮指定了左外边距为50dp，则他和他的父布局水平布局(horizontal)的左边的间距为50dp, 效果如图：\n\n\n\n\nmarginRight#\n\nView的右外边距。如果该属性和margin属性指定的值冲突，则在后面的属性生效，前面的属性无效。\n\n\nmarginTop#\n\nView的上外边距。如果该属性和margin属性指定的值冲突，则在后面的属性生效，前面的属性无效。\n\n\nmarginBottom#\n\nView的下外边距。如果该属性和margin属性指定的值冲突，则在后面的属性生效，前面的属性无效。\n\n\npadding#\n\nView和他的自身内容的间距，也就是内边距。注意和margin属性区分开来，margin属性是View之间的间距，而padding是View和他自身内容的间距。\n举个例子，一个文本控件的padding也即文本控件的边缘和他的文本内容的间距，paddingLeft即文本控件的左边和他的文本内容的间距。\n\npaddding属性的值同样有三种格式：\n\n * padding=\"paddingAll\" 指定各个内边距都是该值。例如padding=\"10\"表示左右上下内边距都是10dp。\n * padding=\"paddingLeft paddingTop paddingRight paddingBottom\"\n   分别指定各个内边距。例如padding=\"10 20 30 40\"表示左内边距为10dp, 上内边距为20dp, 右内边距为30dp, 下内边距为40dp\n * padding=\"paddingHorizontal paddingVertical\" 指定水平内边距和垂直内边距。例如padding=\"10\n   20\"表示左右内边距为10dp, 上下内边距为20dp。\n\n用一个例子来具体理解内边距的含义：\n\n\n\n这个例子是一个居中的按钮(通过父布局的gravity=\"center\"属性设置)，背景色为红色(bg=\"#ff0000\")，文本内容为\"HelloWorld\"，\n左边距为10dp，上边距为20dp，下边距为30dp，右边距为40dp，其显示效果如图：\n\n\n\n\npaddingLeft#\n\nView的左内边距。如果该属性和padding属性指定的值冲突，则在后面的属性生效，前面的属性无效。\n\n\npaddingRight#\n\nView的右内边距。如果该属性和padding属性指定的值冲突，则在后面的属性生效，前面的属性无效。\n\n\npaddingTop#\n\nView的上内边距。如果该属性和padding属性指定的值冲突，则在后面的属性生效，前面的属性无效。\n\n\npaddingBottom#\n\nView的下内边距。如果该属性和padding属性指定的值冲突，则在后面的属性生效，前面的属性无效。\n\n\nbg#\n\nView的背景。其值可以是一个链接或路径指向的图片，或者RGB格式的颜色，或者其他背景。具体参见Drawables。\n\n例如，bg=\"#00ff00\"设置背景为绿色，bg=\"file:///sdcard/1.png\"设置背景为图片\"1.png\"，bg=\"?attr/selecta\nbleItemBackground\"设置背景为点击时出现的波纹效果(可能需要同时设置clickable=\"true\"才生效)。\n\n\nalpha#\n\nView的透明度，其值是一个0~1之间的小数，0表示完全透明，1表示完全不透明。例如alpha=\"0.5\"表示半透明。\n\n\nforeground#\n\nView的前景。前景即在一个View的内容上显示的内容，可能会覆盖掉View本身的内容。其值和属性bg的值类似。\n\n\nminHeight#\n\nView的最小高度。该值不总是生效的，取决于其父布局是否有足够的空间容纳。\n\n例：<text height=\"auto\" minHeight=\"50\"/>\n\n有关该属性的单位，参见尺寸的单位: Dimension。\n\n\nminWidth#\n\nView的最小宽度。该值不总是生效的，取决于其父布局是否有足够的空间容纳。\n\n例：<input width=\"auto\" minWidth=\"50\"/>\n\n有关该属性的单位，参见尺寸的单位: Dimension。\n\n\nvisbility#\n\nView的可见性，该属性可以决定View是否显示出来。其值可以为：\n\n * gone 不可见。\n * visible 可见。默认情况下View都是可见的。\n * invisible 不可见，但仍然占用位置。\n\n\nrotation#\n\nView的旋转角度。通过该属性可以让这个View顺时针旋转一定的角度。例如rotation=\"90\"可以让他顺时针旋转90度。\n\n如果要设置旋转中心，可以通过transformPivotX, transformPivotY属性设置。默认的旋转中心为View的中心。\n\n\ntransformPivotX#\n\nView的变换中心坐标x。用于View的旋转、放缩等变换的中心坐标。例如transformPivotX=\"10\"。\n\n该坐标的坐标系以View的左上角为原点。也就是x值为变换中心到View的左边的距离。\n\n有关该属性的单位，参见尺寸的单位: Dimension。\n\n\ntransformPivotY#\n\nView的变换中心坐标y。用于View的旋转、放缩等变换的中心坐标。例如transformPivotY=\"10\"。\n\n该坐标的坐标系以View的左上角为原点。也就是y值为变换中心到View的上边的距离。\n\n有关该属性的单位，参见尺寸的单位: Dimension。\n\n\nstyle#\n\n设置View的样式。不同控件有不同的可选的内置样式。具体参见各个控件的说明。\n\n需要注意的是，style属性只支持安卓5.1及其以上。","routePath":"/v1/基础/ui/view","lang":"","toc":[{"text":"w","id":"w","depth":2,"charIndex":85},{"text":"h","id":"h","depth":2,"charIndex":379},{"text":"id","id":"id","depth":2,"charIndex":626},{"text":"gravity","id":"gravity","depth":2,"charIndex":920},{"text":"layout_gravity","id":"layout_gravity","depth":2,"charIndex":1194},{"text":"margin","id":"margin","depth":2,"charIndex":1516},{"text":"marginLeft","id":"marginleft","depth":2,"charIndex":2162},{"text":"marginRight","id":"marginright","depth":2,"charIndex":2344},{"text":"marginTop","id":"margintop","depth":2,"charIndex":2410},{"text":"marginBottom","id":"marginbottom","depth":2,"charIndex":2474},{"text":"padding","id":"padding","depth":2,"charIndex":2541},{"text":"paddingLeft","id":"paddingleft","depth":2,"charIndex":3195},{"text":"paddingRight","id":"paddingright","depth":2,"charIndex":3262},{"text":"paddingTop","id":"paddingtop","depth":2,"charIndex":3330},{"text":"paddingBottom","id":"paddingbottom","depth":2,"charIndex":3396},{"text":"bg","id":"bg","depth":2,"charIndex":3465},{"text":"alpha","id":"alpha","depth":2,"charIndex":3677},{"text":"foreground","id":"foreground","depth":2,"charIndex":3747},{"text":"minHeight","id":"minheight","depth":2,"charIndex":3819},{"text":"minWidth","id":"minwidth","depth":2,"charIndex":3941},{"text":"visbility","id":"visbility","depth":2,"charIndex":4061},{"text":"rotation","id":"rotation","depth":2,"charIndex":4179},{"text":"transformPivotX","id":"transformpivotx","depth":2,"charIndex":4325},{"text":"transformPivotY","id":"transformpivoty","depth":2,"charIndex":4477},{"text":"style","id":"style","depth":2,"charIndex":4629}],"domain":"","frontmatter":{},"version":""},{"id":58,"title":"","content":"支持属性#\n\n属性        类型             功能\nalpha     float          View的透明度。视图的alpha通道属性，介于0(完全透明)和1(完全不透明)之间的值。\nh         stringnumber   View的高度。可设置为auto或*，当为具体数值时默认单位为dp。\nw         stringnumber   View的宽度。可设置为auto或*，当为具体数值时默认单位为dp。\nid        string         View的id，用来区分一个界面下的不同控件和布局，一个界面的id在同一个界面下通常是唯一的，也就是一般不存在两个Vie\n                         w有相同的id。id属性也是连接xml布局和JavaScript代码的桥梁，在代码中可以通过一个View的id来获取到这\n                         个View，并对他进行操作(设置点击动作、设置属性、获取属性等)。\ngravity   string         View的\"重力\"。用于决定View的内容相对于View的位置，可以设置的值为：left靠左、right靠右、\n                         top靠顶部、bottom靠底部、center居中、center_vertical垂直居中、center_horizon\n                         tal水平居中。可使用 | 进行组合。\n                         \n                         \n                         \n                         \n                         \n                         \n                         ","routePath":"/v1/基础/ui/viewAttributes","lang":"","toc":[{"text":"支持属性","id":"支持属性","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":59,"title":"websocket","content":"#\n\n4.2.8 新增\n\n稳定性: 稳定\n\n\nwebsocket 模块，采用 okhttp3 实现，本模块中包含了 okhttp3\n核心所有的类，下面讲解其基本的使用方法，更多的使用规则,可参考：(https://square.github.io/okhttp/)，这里涉及一些线程安全问题，\n请学习多线程，生命周期等内容。\n\n\n创建 websocket 客户端#\n\n * 创建一个 http client，可以设定 client 是否重连，心跳等功能\n * 创建一个 request 请求对象，采用什么协议 ws 或 wss 、服务器、端口都能内容\n * 设置监听，当 websocket 生命周期内的一些事情。\n * 设置上面的操作以后，打开链接，创建 webSocket 客户端。\n * 用 webSocket 客户端 发送消息 webSocket.send(\"你好服务器\");\n\n\n\n创建 websocket 服务器端，一样支持，可以参考 okhttp 官网。","routePath":"/v1/基础/websocket","lang":"","toc":[{"text":"创建 websocket 客户端","id":"创建-websocket-客户端","depth":2,"charIndex":164}],"domain":"","frontmatter":{},"version":""},{"id":60,"title":"基于控件的操作","content":"#\n\n基于控件的操作指的是选择屏幕上的控件，获取其信息或对其进行操作。对于一般软件而言，基于控件的操作对不同机型有很好的兼容性；但是对于游戏而言，由于游戏界面并不是由\n控件构成，无法采用本章节的方法，也无法使用本章节的函数。有关游戏脚本的编写，请参考《基于坐标的操作》。\n\n基于控件的操作依赖于无障碍服务，因此最好在脚本开头使用auto()函数来确保无障碍服务已经启用。如果运行到某个需要权限的语句无障碍服务并没启动，则会抛出异常并跳\n转到无障碍服务界面。这样的用户体验并不好，因为需要重新运行脚本，后续会加入等待无障碍服务启动并让脚本继续运行的函数。\n\n您也可以在脚本开头使用\"auto\";表示这个脚本需要无障碍服务，但是不推荐这种做法，因为这个标记必须在脚本的最开头(前面不能有注释或其他语句、空格等)，我们推荐\n使用auto()函数来确保无障碍服务已启用。","routePath":"/v1/基础/widgetsBasedAutomation/about","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":61,"title":"","content":"auto([mode])#\n\n * mode {string} 模式\n\n检查无障碍服务是否已经启用，如果没有启用则抛出异常并跳转到无障碍服务启用界面；同时设置无障碍模式为 mode。mode 的可选值为：\n\n * fast 快速模式。该模式下会启用控件缓存，从而选择器获取屏幕控件更快。对于需要快速的控件操作的脚本可以使用该模式，一般脚本则没有必要使用该函数。\n * normal 正常模式，默认。\n\n如果不加 mode 参数，则为正常模式。\n\n建议使用auto.waitFor()和auto.setMode()代替该函数，因为auto()函数如果无障碍服务未启动会停止脚本；而auto.waitFor()\n则会在在无障碍服务启动后继续运行。\n\n示例：\n\n\n\n示例 2：\n\n\n\n\nauto.waitFor()#\n\n检查无障碍服务是否已经启用，如果没有启用则跳转到无障碍服务启用界面，并等待无障碍服务启动；当无障碍服务启动后脚本会继续运行。\n\n\nauto.setMode(mode)#\n\n * mode {string} 模式\n\n设置无障碍模式为 mode。mode 的可选值为：\n\n * fast 快速模式。该模式下会启用控件缓存，从而选择器获取屏幕控件更快。对于需要快速的控件查看和操作的脚本可以使用该模式，一般脚本则没有必要使用该函数。\n * normal 正常模式，默认。","routePath":"/v1/基础/widgetsBasedAutomation/auto","lang":"","toc":[{"text":"auto([mode])","id":"automode","depth":2,"charIndex":-1},{"text":"auto.waitFor()","id":"autowaitfor","depth":2,"charIndex":339},{"text":"auto.setMode(mode)","id":"autosetmodemode","depth":2,"charIndex":421}],"domain":"","frontmatter":{},"version":""},{"id":62,"title":"Rect","content":"#\n\nUiObject.bounds(), UiObject.boundsInParent()返回的对象。表示一个长方形(范围)。\n\n\nRect.left#\n\n * {number}\n\n长方形左边界的 x 坐标、\n\n\nRect.right#\n\n * {number}\n\n长方形右边界的 x 坐标、\n\n\nRect.top#\n\n * {number}\n\n长方形上边界的 y 坐标、\n\n\nRect.bottom#\n\n * {number}\n\n长方形下边界的 y 坐标、\n\n\nRect.centerX()#\n\n * 返回 {number}\n\n长方形中点 x 坐标。\n\n\nRect.centerY()#\n\n * 返回 {number}\n\n长方形中点 y 坐标。\n\n\nRect.width()#\n\n * 返回 {number}\n\n长方形宽度。通常可以作为控件宽度。\n\n\nRect.height()#\n\n * 返回 {number}\n\n长方形高度。通常可以作为控件高度。\n\n\nRect.contains(r)#\n\n * r Rect\n\n返回是否包含另一个长方形 r。包含指的是，长方形 r 在该长方形的里面(包含边界重叠的情况)。\n\n\nRect.intersect(r)#\n\n * r Rect\n\n返回是否和另一个长方形相交。","routePath":"/v1/基础/widgetsBasedAutomation/rect","lang":"","toc":[{"text":"Rect.left","id":"rectleft","depth":2,"charIndex":67},{"text":"Rect.right","id":"rectright","depth":2,"charIndex":108},{"text":"Rect.top","id":"recttop","depth":2,"charIndex":150},{"text":"Rect.bottom","id":"rectbottom","depth":2,"charIndex":190},{"text":"Rect.centerX()","id":"rectcenterx","depth":2,"charIndex":233},{"text":"Rect.centerY()","id":"rectcentery","depth":2,"charIndex":280},{"text":"Rect.width()","id":"rectwidth","depth":2,"charIndex":327},{"text":"Rect.height()","id":"rectheight","depth":2,"charIndex":378},{"text":"Rect.contains(r)","id":"rectcontainsr","depth":2,"charIndex":430},{"text":"Rect.intersect(r)","id":"rectintersectr","depth":2,"charIndex":510}],"domain":"","frontmatter":{},"version":""},{"id":63,"title":"SimpleActionAutomator","content":"#\n\n稳定性: 稳定\n\n\nSimpleActionAutomator 提供了一些模拟简单操作的函数，例如点击文字、模拟按键等。这些函数可以直接作为全局函数使用。\n\n\nclick(text[, i])#\n\n * text {string} 要点击的文本\n * i {number} 如果相同的文本在屏幕中出现多次，则 i 表示要点击第几个文本, i 从 0 开始计算\n\n返回是否点击成功。当屏幕中并未包含该文本，或者该文本所在区域不能点击时返回 false，否则返回 true。\n\n该函数可以点击大部分包含文字的按钮。例如微信主界面下方的\"微信\", \"联系人\", \"发现\", \"我\"的按钮。\n\n通常与 while 同时使用以便点击按钮直至成功。例如:\n\n\n\n当不指定参数 i 时则会尝试点击屏幕上出现的所有文字 text 并返回是否全部点击成功。\n\ni 是从 0 开始计算的, 也就是, click(\"啦啦啦\", 0)表示点击屏幕上第一个\"啦啦啦\", click(\"啦啦啦\",\n1)表示点击屏幕上第二个\"啦啦啦\"。\n\n> 文本所在区域指的是，从文本处向其父视图寻找，直至发现一个可点击的部件为止。\n\n\nclick(left, top, bottom, right)#\n\n * left {number} 要点击的长方形区域左边与屏幕左边的像素距离\n * top {number} 要点击的长方形区域上边与屏幕上边的像素距离\n * bottom {number} 要点击的长方形区域下边与屏幕下边的像素距离\n * right {number} 要点击的长方形区域右边与屏幕右边的像素距离\n\n注意，该函数一般只用于录制的脚本中使用，在自己写的代码中使用该函数一般不要使用该函数。\n\n点击在指定区域的控件。当屏幕中并未包含与该区域严格匹配的区域，或者该区域不能点击时返回 false，否则返回 true。\n\n有些按钮或者部件是图标而不是文字（例如发送朋友圈的照相机图标以及 QQ 下方的消息、联系人、动态图标），这时不能通过click(text,\ni)来点击，可以通过描述图标所在的区域来点击。left, bottom, top, right 描述的就是点击的区域。\n\n至于要定位点击的区域，可以在悬浮窗使用布局分析工具查看控件的 bounds 属性。\n\n通过无障碍服务录制脚本会生成该语句。\n\n\nlongClick(text[, i])#\n\n * text {string} 要长按的文本\n * i {number} 如果相同的文本在屏幕中出现多次，则 i 表示要长按第几个文本, i 从 0 开始计算\n\n返回是否点击成功。当屏幕中并未包含该文本，或者该文本所在区域不能点击时返回 false，否则返回 true。\n\n当不指定参数 i 时则会尝试点击屏幕上出现的所有文字 text 并返回是否全部长按成功。\n\n\nscrollUp([i])#\n\n * i {number} 要滑动的控件序号\n\n找到第 i+1 个可滑动控件上滑或左滑。返回是否操作成功。屏幕上没有可滑动的控件时返回 false。\n\n另外不加参数时scrollUp()会寻找面积最大的可滑动的控件上滑或左滑，例如微信消息列表等。\n\n参数为一个整数 i 时会找到第 i + 1 个可滑动控件滑动。例如scrollUp(0)为滑动第一个可滑动控件。\n\n\nscrollDown([i])#\n\n * i {number} 要滑动的控件序号\n\n找到第 i+1 个可滑动控件下滑或右滑。返回是否操作成功。屏幕上没有可滑动的控件时返回 false。\n\n另外不加参数时scrollUp()会寻找面积最大的可滑动的控件下滑或右滑。\n\n参数为一个整数 i 时会找到第 i + 1 个可滑动控件滑动。例如scrollUp(0)为滑动第一个可滑动控件。\n\n\nsetText([i, ]text)#\n\n * i {number} 表示要输入的为第 i + 1 个输入框\n * text {string} 要输入的文本\n\n返回是否输入成功。当找不到对应的文本框时返回 false。\n\n不加参数 i 则会把所有输入框的文本都置为 text。例如setText(\"测试\")。\n\n这里的输入文本的意思是，把输入框的文本置为 text，而不是在原来的文本上追加。\n\n\ninput([i, ]text)#\n\n * i {number} 表示要输入的为第 i + 1 个输入框\n * text {string} 要输入的文本\n\n返回是否输入成功。当找不到对应的文本框时返回 false。\n\n不加参数 i 则会把所有输入框的文本追加内容 text。例如input(\"测试\")。","routePath":"/v1/基础/widgetsBasedAutomation/simpleActionAutomator","lang":"","toc":[{"text":"click(text[, i])","id":"clicktext-i","depth":2,"charIndex":82},{"text":"click(left, top, bottom, right)","id":"clickleft-top-bottom-right","depth":2,"charIndex":499},{"text":"longClick(text[, i])","id":"longclicktext-i","depth":2,"charIndex":994},{"text":"scrollUp([i])","id":"scrollupi","depth":2,"charIndex":1202},{"text":"scrollDown([i])","id":"scrolldowni","depth":2,"charIndex":1402},{"text":"setText([i, ]text)","id":"settexti-text","depth":2,"charIndex":1594},{"text":"input([i, ]text)","id":"inputi-text","depth":2,"charIndex":1793}],"domain":"","frontmatter":{},"version":""},{"id":64,"title":"UiCollection","content":"#\n\nUiCollection, 控件集合, 通过选择器的find(), untilFind()方法返回的对象。\n\nUiCollection\"继承\"于数组，实际上是一个 UiObject 的数组，因此可以使用数组的函数和属性，例如使用 length 属性获取\nUiCollection 的大小，使用 forEach 函数来遍历 UiCollection。\n\n例如，采用 forEach 遍历屏幕上所有的文本控件并打印出文本内容的代码为：\n\n\n\n也可以使用传统的数组遍历方式：\n\n\n\nUiCollection 的每一个元素都是 UiObject，我们可以取出他的元素进行操作，例如取出第一个 UiObject\n并点击的代码为ui[0].click()。如果想要对该集合的所有元素进行操作，可以直接在集合上调用相应的函数，例如uc.click()，该代码会对集合上所有\nUiObject 执行点击操作并返回是否全部点击成功。\n\n因此，UiCollection 具有所有 UiObject 对控件操作的函数，包括click(), longClick(),\nscrollForward()等等，不再赘述。\n\n\nUiCollection.size()#\n\n * 返回 {number}\n\n返回集合中的控件数。\n\n历史遗留函数，相当于属性 length。\n\n\nUiCollection.get(i)#\n\n * i {number} 索引\n * 返回 UiObject\n\n返回集合中第 i+1 个控件(UiObject)。\n\n历史遗留函数，建议直接使用数组下标的方式访问元素。\n\n\nUiCollection.each(func)#\n\n * func {Function} 遍历函数，参数为 UiObject。\n\n遍历集合。\n\n历史遗留函数，相当于forEach。参考forEach。\n\n\nempty()#\n\n * 返回 {Boolean}\n\n返回控件集合是否为空。\n\n\nnonEmpty()#\n\n * 返回 {Boolean}\n\n返回控件集合是否非空。\n\n\nUiCollection.find(selector)#\n\n * selector UiSelector\n * 返回 UiCollection\n\n根据 selector 所确定的条件在该控件集合的控件、子控件、孙控件...中找到所有符合条件的控件并返回找到的控件集合。\n\n注意这会递归地遍历控件集合里所有的控件以及他们的子控件。和数组的filter函数不同。\n\n例如：\n\n\n\n\nUiCollection.findOne(selector)#\n\n * selector UiSelector\n * 返回 UiOobject\n\n根据选择器 selector\n在该控件集合的控件的子控件、孙控件...中搜索符合该选择器条件的控件，并返回找到的第一个控件；如果没有找到符合条件的控件则返回null。","routePath":"/v1/基础/widgetsBasedAutomation/uiCollection","lang":"","toc":[{"text":"UiCollection.size()","id":"uicollectionsize","depth":2,"charIndex":500},{"text":"UiCollection.get(i)","id":"uicollectiongeti","depth":2,"charIndex":573},{"text":"UiCollection.each(func)","id":"uicollectioneachfunc","depth":2,"charIndex":683},{"text":"empty()","id":"empty","depth":2,"charIndex":786},{"text":"nonEmpty()","id":"nonempty","depth":2,"charIndex":827},{"text":"UiCollection.find(selector)","id":"uicollectionfindselector","depth":2,"charIndex":871},{"text":"UiCollection.findOne(selector)","id":"uicollectionfindoneselector","depth":2,"charIndex":1060}],"domain":"","frontmatter":{},"version":""},{"id":65,"title":"UiObject","content":"#\n\nUiObject 表示一个控件，可以通过这个对象获取到控件的属性，也可以对控件进行点击、长按等操作。\n\n获取一个 UiObject 通常通过选择器的findOne(), findOnce()等函数，也可以通过 UiCollection\n来获取，或者通过UiObject.child(), UiObject.parent()等函数来获取一个控件的子控件或父控件。\n\n\nUiObject.click()#\n\n * 返回 {Boolean}\n\n点击该控件，并返回是否点击成功。\n\n如果该函数返回 false，可能是该控件不可点击(clickable 为 false)，当前界面无法响应该点击等。\n\n\nUiObject.longClick()#\n\n * 返回 {Boolean}\n\n长按该控件，并返回是否点击成功。\n\n如果该函数返回 false，可能是该控件不可点击(longClickable 为 false)，当前界面无法响应该点击等。\n\n\nUiObject.setText(text)#\n\n * text {string} 文本\n * 返回 {Boolean}\n\n设置输入框控件的文本内容，并返回是否设置成功。\n\n该函数只对可编辑的输入框(editable 为 true)有效。\n\n\nUiObject.copy()#\n\n * 返回 {Boolean}\n\n对输入框文本的选中内容进行复制，并返回是否操作成功。\n\n该函数只能用于输入框控件，并且当前输入框控件有选中的文本。可以通过setSelection()函数来设置输入框选中的内容。\n\n\n\n\nUiObject.cut()#\n\n对输入框文本的选中内容进行剪切，并返回是否操作成功。\n\n该函数只能用于输入框控件，并且当前输入框控件有选中的文本。可以通过setSelection()函数来设置输入框选中的内容。\n\n\nUiObject.paste()#\n\n * 返回 {Boolean}\n\n对输入框控件进行粘贴操作，把剪贴板内容粘贴到输入框中，并返回是否操作成功。\n\n\n\n\nUiObject.setSelection(start, end)#\n\n * start {number} 选中内容起始位置\n * end {number} 选中内容结束位置(不包括)\n * 返回 {Boolean}\n\n对输入框控件设置选中的文字内容，并返回是否操作成功。\n\n索引是从 0 开始计算的；并且，选中内容不包含 end\n位置的字符。例如，如果一个输入框内容为\"123456789\"，要选中\"4567\"的文字的代码为et.setSelection(3, 7)。\n\n该函数也可以用来设置光标位置，只要参数的 end 等于 start，即可把输入框光标设置在 start 的位置。例如et.setSelection(1,\n1)会把光标设置在第一个字符的后面。\n\n\nUiObject.scrollForward()#\n\n * 返回 {Boolean}\n\n对控件执行向前滑动的操作，并返回是否操作成功。\n\n向前滑动包括了向右和向下滑动。如果一个控件既可以向右滑动和向下滑动，那么执行scrollForward()的行为是未知的(这是因为 Android\n文档没有指出这一点，同时也没有充分的测试可供参考)。\n\n\nUiObject.scrollBackward()#\n\n * 返回 {Boolean}\n\n对控件执行向后滑动的操作，并返回是否操作成功。\n\n向后滑动包括了向右和向下滑动。如果一个控件既可以向右滑动和向下滑动，那么执行scrollForward()的行为是未知的(这是因为 Android\n文档没有指出这一点，同时也没有充分的测试可供参考)。\n\n\nUiObject.select()#\n\n * 返回 {Boolean}\n\n对控件执行\"选中\"操作，并返回是否操作成功。\"选中\"和isSelected()的属性相关，但该操作十分少用。\n\n\nUiObject.collapse()#\n\n * 返回 {Boolean}\n\n对控件执行折叠操作，并返回是否操作成功。\n\n\nUiObject.expand()#\n\n * 返回 {Boolean}\n\n对控件执行操作，并返回是否操作成功。\n\n\nUiObject.show()#\n\n对集合中所有控件执行显示操作，并返回是否全部操作成功。\n\n\nUiObject.scrollUp()#\n\n对集合中所有控件执行向上滑的操作，并返回是否全部操作成功。\n\n\nUiObject.scrollDown()#\n\n对集合中所有控件执行向下滑的操作，并返回是否全部操作成功。\n\n\nUiObject.scrollLeft()#\n\n对集合中所有控件执行向左滑的操作，并返回是否全部操作成功。\n\n\nUiObject.scrollRight()#\n\n\nchildren()#\n\n * 返回 UiCollection\n\n返回该控件的所有子控件组成的控件集合。可以用于遍历一个控件的子控件，例如：\n\n\n\n\nchildCount()#\n\n * 返回 {number}\n\n返回子控件数目。\n\n\nchild(i)#\n\n * i {number} 子控件索引\n * 返回 {UiObject}\n\n返回第 i+1 个子控件。如果 i>=控件数目或者小于 0，则抛出异常。\n\n需要注意的是，由于布局捕捉的问题，该函数可能返回null，也就是可能获取不到某个子控件。\n\n遍历子控件的示例：\n\n\n\n\nparent()#\n\n * 返回 {UiObject}\n\n返回该控件的父控件。如果该控件没有父控件，返回null。\n\n\nbounds()#\n\n * 返回 Rect\n\n返回控件在屏幕上的范围，其值是一个Rect对象。\n\n示例：\n\n\n\n如果一个控件本身无法通过click()点击，那么我们可以利用bounds()函数获取其坐标，再利用坐标点击。例如：\n\n\n\n\nboundsInParent()#\n\n * 返回 Rect\n\n返回控件在父控件中的范围，其值是一个Rect对象。\n\n\ndrawingOrder()#\n\n * 返回 {number}\n\n返回控件在父控件中的绘制次序。该函数在安卓 7.0 及以上才有效，7.0 以下版本调用会返回 0。\n\n\nid()#\n\n * 返回 {string}\n\n获取控件的 id，如果一个控件没有 id，则返回null。\n\n\ntext()#\n\n * 返回 {string}\n\n获取控件的文本，如果控件没有文本，返回\"\"。\n\n\nfindByText(str)#\n\n * str {string} 文本\n * 返回 UiCollection\n\n根据文本 text 在子控件中递归地寻找并返回文本或描述(desc)包含这段文本 str 的控件，返回它们组成的集合。\n\n该函数会在当前控件的子控件，孙控件，曾孙控件...中搜索 text 或 desc 包含 str 的控件，并返回它们组合的集合。\n\n\nfindOne(selector)#\n\n * selector UiSelector\n * 返回 UiOobject\n\n根据选择器 selector 在该控件的子控件、孙控件...中搜索符合该选择器条件的控件，并返回找到的第一个控件；如果没有找到符合条件的控件则返回null。\n\n例如，对于酷安动态列表，我们可以遍历他的子控件(每个动态列表项)，并在每个子控件中依次寻找点赞数量和图标，对于点赞数量小于 10 的点赞：\n\n\n\n\nfind(selector)#\n\n * selector UiSelector\n * 返回 UiCollection\n\n根据选择器 selector 在该控件的子控件、孙控件...中搜索符合该选择器条件的控件，并返回它们组合的集合。","routePath":"/v1/基础/widgetsBasedAutomation/uiObject","lang":"","toc":[{"text":"UiObject.click()","id":"uiobjectclick","depth":2,"charIndex":185},{"text":"UiObject.longClick()","id":"uiobjectlongclick","depth":2,"charIndex":299},{"text":"UiObject.setText(text)","id":"uiobjectsettexttext","depth":2,"charIndex":421},{"text":"UiObject.copy()","id":"uiobjectcopy","depth":2,"charIndex":543},{"text":"UiObject.cut()","id":"uiobjectcut","depth":2,"charIndex":672},{"text":"UiObject.paste()","id":"uiobjectpaste","depth":2,"charIndex":781},{"text":"UiObject.setSelection(start, end)","id":"uiobjectsetselectionstart-end","depth":2,"charIndex":859},{"text":"UiObject.scrollForward()","id":"uiobjectscrollforward","depth":2,"charIndex":1194},{"text":"UiObject.scrollBackward()","id":"uiobjectscrollbackward","depth":2,"charIndex":1366},{"text":"UiObject.select()","id":"uiobjectselect","depth":2,"charIndex":1539},{"text":"UiObject.collapse()","id":"uiobjectcollapse","depth":2,"charIndex":1633},{"text":"UiObject.expand()","id":"uiobjectexpand","depth":2,"charIndex":1695},{"text":"UiObject.show()","id":"uiobjectshow","depth":2,"charIndex":1753},{"text":"UiObject.scrollUp()","id":"uiobjectscrollup","depth":2,"charIndex":1801},{"text":"UiObject.scrollDown()","id":"uiobjectscrolldown","depth":2,"charIndex":1855},{"text":"UiObject.scrollLeft()","id":"uiobjectscrollleft","depth":2,"charIndex":1911},{"text":"UiObject.scrollRight()","id":"uiobjectscrollright","depth":2,"charIndex":1967},{"text":"children()","id":"children","depth":2,"charIndex":1993},{"text":"childCount()","id":"childcount","depth":2,"charIndex":2068},{"text":"child(i)","id":"childi","depth":2,"charIndex":2110},{"text":"parent()","id":"parent","depth":2,"charIndex":2257},{"text":"bounds()","id":"bounds","depth":2,"charIndex":2317},{"text":"boundsInParent()","id":"boundsinparent","depth":2,"charIndex":2435},{"text":"drawingOrder()","id":"drawingorder","depth":2,"charIndex":2494},{"text":"id()","id":"id","depth":2,"charIndex":2579},{"text":"text()","id":"text","depth":2,"charIndex":2634},{"text":"findByText(str)","id":"findbytextstr","depth":2,"charIndex":2684},{"text":"findOne(selector)","id":"findoneselector","depth":2,"charIndex":2868},{"text":"find(selector)","id":"findselector","depth":2,"charIndex":3082}],"domain":"","frontmatter":{},"version":""},{"id":66,"title":"UiSelector","content":"#\n\nUiSelector 即选择器，用于通过各种条件选取屏幕上的控件，再对这些控件进行点击、长按等动作。这里需要先简单介绍一下控件和界面的相关知识。\n\n一般软件的界面是由一个个控件构成的，例如图片部分是一个图片控件(ImageView)，文字部分是一个文字控件(TextView)；同时，通过各种布局来决定各个控\n件的位置，例如，线性布局(LinearLayout)里面的控件都是按水平或垂直一次叠放的，列表布局(AbsListView)则是以列表的形式显示控件。\n\n控件有各种属性，包括文本(text), 描述(desc), 类名(className), id 等等。我们通常用一个控件的属性来找到这个控件，例如，想要点击\nQQ 聊天窗口的\"发送\"按钮，我们就可以通过他的文本属性为\"发送\"来找到这个控件并点击他，具体代码为:\n\n\n\n在这个例子中, text(\"发送\")表示一个条件(文本属性为\"发送\")，findOne()表示基于这个条件找到一个符合条件的控件，从而我们可以得到发送按钮\nsendButton，再执行sendButton.click()即可点击\"发送\"按钮。\n\n用文本属性来定位按钮控件、文本控件通常十分有效。但是，如果一个控件是图片控件，比如 Auto.js\n主界面右上角的搜索图标，他没有文本属性，这时需要其他属性来定位他。我们如何查看他有什么属性呢？首先打开悬浮窗和无障碍服务，点击蓝色的图标(布局分析),\n可以看到以下界面：\n\n之后我们点击搜索图标，可以看到他有以下属性：\n\n我们注意到这个图标的 desc(描述)属性为\"搜索\"，那么我们就可以通过 desc 属性来定位这个控件，得到点击搜索图标的代码为:\n\n\n\n可能心细的你可能注意到了，这个控件还有很多其他的属性，例如 checked, className, clickable\n等等，为什么不用这些属性来定位搜索图标呢？答案是，其他控件也有这些值相同的属性、尝试一下你就可以发现很多其他控件的 checked\n属性和搜索控件一样都是false，如果我们用checked(false)作为条件，将会找到很多控件，而无法确定哪一个是搜索图标。因此，要找到我们想要的那个控件，\n选择器的条件通常需要是可唯一确定控件的。我们通常用一个独一无二的属性来定位一个控件，例如这个例子中就没有其他控件的 desc(描述)属性为\"搜索\"。\n\n另外，对于这个搜索图标而言，id\n属性也是唯一的，我们也可以用id(\"action_search\").findOne().click()来点击这个控件。如果一个控件有 id\n属性，那么这个属性很可能是唯一的，除了以下几种情况：\n\n * QQ 的控件的 id 属性很多都是\"name\"，也就是在 QQ 界面难以通过 id 来定位一个控件\n * 列表中的控件，比如 QQ 联系人列表，微信联系人列表等\n\n尽管 id 属性很方便，但也不总是最方便的，例如对于微信和网易云音乐，每次更新他的控件 id 都会变化，导致了相同代码对于不同版本的微信、网易云音乐并不兼容。\n\n除了这些属性外，主要还有以下几种属性：\n\n * className 类名。类名表示一个控件的类型，例如文本控件为\"android.widget.TextView\",\n   图片控件为\"android.widget.ImageView\"等。\n * packageName 包名。包名表示控件所在的应用包名，例如 QQ 界面的控件的包名为\"com.tencent.mobileqq\"。\n * bounds 控件在屏幕上的范围。\n * drawingOrder 控件在父控件的绘制顺序。\n * indexInParent 控件在父控件的位置。\n * clickable 控件是否可点击。\n * longClickable 控件是否可长按。\n * checkable 控件是否可勾选。\n * checked 控件是否可已勾选。\n * scrollable 控件是否可滑动。\n * selected 控件是否已选择。\n * editable 控件是否可编辑。\n * visibleToUser 控件是否可见。\n * enabled 控件是否已启用。\n * depth 控件的布局深度。\n\n有时候只靠一个属性并不能唯一确定一个控件，这时需要通过属性的组合来完成定位，例如className(\"ImageView\").depth(10).findOne\n().click()，通过链式调用来组合条件。\n\n通常用这些技巧便可以解决大部分问题，即使解决不了问题，也可以通过布局分析的\"生成代码\"功能来尝试生成一些选择器代码。接下来的问题便是对选取的控件进行操作，包括：\n\n * click() 点击。点击一个控件，前提是这个控件的 clickable 属性为 true\n * longClick() 长按。长按一个控件，前提是这个控件的 longClickable 属性为 true\n * setText() 设置文本，用于编辑框控件设置文本。\n * scrollForward(), scrollBackward() 滑动。滑动一个控件(列表等), 前提是这个控件的 scrollable 属性为\n   true\n * exits() 判断控件是否存在\n * waitFor() 等待控件出现\n\n这些操作包含了绝大部分控件操作。根据这些我们可以很容易写出一个\"刷屏\"脚本(代码仅为示例，请不要在别人的群里测试，否则容易被踢):\n\n\n\n上面这段代码也可以写成：\n\n\n\n如果不加findOne()而直接进行操作，则选择器会找出所有符合条件的控件并操作。\n\n另外一个比较常用的操作的滑动。滑动操作的第一步是找到需要滑动的控件，例如要滑动 QQ\n消息列表则在悬浮窗布局层次分析中找到AbsListView，这个控件就是消息列表控件，如下图：\n\n长按可查看控件信息，注意到其 scrollable 属性为 true，并找出其 id 为\"recent_chat_list\"，从而下滑 QQ 消息列表的代码为：\n\n\n\nscrollForward()为向前滑，包括下滑和右滑。\n\n选择器的入门教程暂且要这里，更多信息可以查看下面的文档和选择器进阶。\n\n\nselector()#\n\n * 返回 {UiSelector}\n\n创建一个新的选择器。但一般情况不需要使用该函数，因为可以直接用相应条件的语句创建选择器。\n\n由于历史遗留原因，本不应该这样设计(不应该让id(), text()等作为全局函数，而是应该用By.id(),\nBy.text())，但为了后向兼容性只能保留这个设计。\n\n这样的 API 设计会污染全局变量，后续可能会支持\"去掉这些全局函数而使用 By.***\"的选项。\n\n\nUiSelector.text(str)#\n\n * str {string} 控件文本\n * 返回 {UiSelector} 返回选择器自身以便链式调用\n\n为当前选择器附加控件\"text 等于字符串 str\"的筛选条件。\n\n控件的 text(文本)属性是文本控件上的显示的文字，例如微信左上角的\"微信\"文本。\n\n\nUiSelector.textContains(str)#\n\n * str {string} 要包含的字符串\n\n为当前选择器附加控件\"text 需要包含字符串 str\"的筛选条件。\n\n这是一个比较有用的条件，例如 QQ\n动态页和微博发现页上方的\"大家都在搜....\"的控件可以用textContains(\"大家都在搜\").findOne()来获取。\n\n\nUiSelector.textStartsWith(prefix)#\n\n * prefix {string} 前缀\n\n为当前选择器附加控件\"text 需要以 prefix 开头\"的筛选条件。\n\n这也是一个比较有用的条件，例如要找出 Auto.js 脚本列表中名称以\"QQ\"开头的脚本的代码为textStartsWith(\"QQ\").find()。\n\n\nUiSelector.textEndsWith(suffix)#\n\n * suffix {string} 后缀\n\n为当前选择器附加控件\"text 需要以 suffix 结束\"的筛选条件。\n\n\nUiSelector.textMatches(reg)#\n\n * reg {string} | {Regex} 要满足的正则表达式。\n\n为当前选择器附加控件\"text 需要满足正则表达式 reg\"的条件。\n\n有关正则表达式，可以查看正则表达式 - 菜鸟教程。\n\n需要注意的是，如果正则表达式是字符串，则需要使用\\\\来表达\\(也即 Java\n正则表达式的形式)，例如textMatches(\"\\\\d+\")匹配多位数字；但如果使用 JavaScript\n语法的正则表达式则不需要，例如textMatches(/\\d+/)。但如果使用字符串的正则表达式则该字符串不能以\"/\"同时以\"/\"结束，也即不能写诸如textM\natches(\"/\\\\d+/\")的表达式，否则会被开头的\"/\"和结尾的\"/\"会被忽略。\n\n\nUiSelector.desc(str)#\n\n * str {string} 控件文本\n * 返回 {UiSelector} 返回选择器自身以便链式调用\n\n为当前选择器附加控件\"desc 等于字符串 str\"的筛选条件。\n\n控件的 desc(描述，全称为\nContent-Description)属性是对一个控件的描述，例如网易云音乐右上角的放大镜图标的描述为搜索。要查看一个控件的描述，同样地可以借助悬浮窗查看。\n\ndesc 属性同样是定位控件的利器。\n\n\nUiSelector.descContains(str)#\n\n * str {string} 要包含的字符串\n\n为当前选择器附加控件\"desc 需要包含字符串 str\"的筛选条件。\n\n\nUiSelector.descStartsWith(prefix)#\n\n * prefix {string} 前缀\n\n为当前选择器附加控件\"desc 需要以 prefix 开头\"的筛选条件。\n\n\nUiSelector.descEndsWith(suffix)#\n\n * suffix {string} 后缀\n\n为当前选择器附加控件\"desc 需要以 suffix 结束\"的筛选条件。\n\n\nUiSelector.descMatches(reg)#\n\n * reg {string} | {Regex} 要满足的正则表达式。\n\n为当前选择器附加控件\"desc 需要满足正则表达式 reg\"的条件。\n\n有关正则表达式，可以查看正则表达式 - 菜鸟教程。\n\n需要注意的是，如果正则表达式是字符串，则需要使用\\\\来表达\\(也即 Java\n正则表达式的形式)，例如textMatches(\"\\\\d+\")匹配多位数字；但如果使用 JavaScript\n语法的正则表达式则不需要，例如textMatches(/\\d+/)。但如果使用字符串的正则表达式则该字符串不能以\"/\"同时以\"/\"结束，也即不能写诸如textM\natches(\"/\\\\d+/\")的表达式，否则会被开头的\"/\"和结尾的\"/\"会被忽略。\n\n\nUiSelector.id(resId)#\n\n * resId {string} 控件的\n   id，以\"包名:id/\"开头，例如\"com.tencent.mm:id/send_btn\"。也可以不指定包名，这时会以当前正在运行的应用的包名来补全\n   id。例如 id(\"send_btn\"),在 QQ 界面想当于 id(\"com.tencent.mobileqq:id/send_btn\")。\n\n为当前选择器附加\"id 等于 resId\"的筛选条件。\n\n控件的 id 属性通常是可以用来确定控件的唯一标识，如果一个控件有 id，那么使用 id 来找到他是最好的方法。要查看屏幕上的控件的\nid，可以开启悬浮窗并使用界面工具，点击相应控件即可查看。若查看到的控件 id 为 null, 表示该控件没有 id。另外，在列表中会出现多个控件的 id\n相同的情况。例如微信的联系人列表，每个头像的 id 都是一样的。此时不能用 id 来唯一确定控件。\n\n在 QQ 界面经常会出现多个 id 为\"name\"的控件，在微信上则每个版本的 id 都会变化。对于这些软件而言比较难用 id 定位控件。\n\n\nUiSelector.idContains(str)#\n\n * str {string} id 要包含的字符串\n\n为当前选择器附加控件\"id 包含字符串 str\"的筛选条件。比较少用。\n\n\nUiSelector.idStartsWith(prefix)#\n\n * prefix {string} id 前缀\n\n为当前选择器附加\"id 需要以 prefix 开头\"的筛选条件。比较少用。\n\n\nUiSelector.idEndsWith(suffix)#\n\n * suffix {string} id 后缀\n\n为当前选择器附加\"id 需要以 suffix 结束\"的筛选条件。比较少用。\n\n\nUiSelector.idMatches(reg)#\n\n * reg {Regex} | {string} id 要满足的正则表达式\n\n附加 id 需要满足正则表达式。\n\n需要注意的是，如果正则表达式是字符串，则需要使用\\\\来表达\\(也即 Java\n正则表达式的形式)，例如textMatches(\"\\\\d+\")匹配多位数字；但如果使用 JavaScript\n语法的正则表达式则不需要，例如textMatches(/\\d+/)。但如果使用字符串的正则表达式则该字符串不能以\"/\"同时以\"/\"结束，也即不能写诸如textM\natches(\"/\\\\d+/\")的表达式，否则会被开头的\"/\"和结尾的\"/\"会被忽略。\n\n\n\n\nUiSelector.className(str)#\n\n * str {string} 控件文本\n * 返回 {UiSelector} 返回选择器自身以便链式调用\n\n为当前选择器附加控件\"className 等于字符串 str\"的筛选条件。\n\n控件的 className(类名)表示一个控件的类别，例如文本控件的类名为 android.widget.TextView。\n\n如果一个控件的类名以\"android.widget.\"开头，则可以省略这部分，例如文本控件可以直接用className(\"TextView\")的选择器。\n\n常见控件的类名如下：\n\n * android.widget.TextView 文本控件\n * android.widget.ImageView 图片控件\n * android.widget.Button 按钮控件\n * android.widget.EditText 输入框控件\n * android.widget.AbsListView 列表控件\n * android.widget.LinearLayout 线性布局\n * android.widget.FrameLayout 帧布局\n * android.widget.RelativeLayout 相对布局\n * android.widget.RelativeLayout 相对布局\n * android.support.v7.widget.RecyclerView 通常也是列表控件\n\n\nUiSelector.classNameContains(str)#\n\n * str {string} 要包含的字符串\n\n为当前选择器附加控件\"className 需要包含字符串 str\"的筛选条件。\n\n\nUiSelector.classNameStartsWith(prefix)#\n\n * prefix {string} 前缀\n\n为当前选择器附加控件\"className 需要以 prefix 开头\"的筛选条件。\n\n\nUiSelector.classNameEndsWith(suffix)#\n\n * suffix {string} 后缀\n\n为当前选择器附加控件\"className 需要以 suffix 结束\"的筛选条件。\n\n\nUiSelector.classNameMatches(reg)#\n\n * reg {string} | {Regex} 要满足的正则表达式。\n\n为当前选择器附加控件\"className 需要满足正则表达式 reg\"的条件。\n\n有关正则表达式，可以查看正则表达式 - 菜鸟教程。\n\n需要注意的是，如果正则表达式是字符串，则需要使用\\\\来表达\\(也即 Java\n正则表达式的形式)，例如textMatches(\"\\\\d+\")匹配多位数字；但如果使用 JavaScript\n语法的正则表达式则不需要，例如textMatches(/\\d+/)。但如果使用字符串的正则表达式则该字符串不能以\"/\"同时以\"/\"结束，也即不能写诸如textM\natches(\"/\\\\d+/\")的表达式，否则会被开头的\"/\"和结尾的\"/\"会被忽略。\n\n\nUiSelector.packageName(str)#\n\n * str {string} 控件文本\n * 返回 {UiSelector} 返回选择器自身以便链式调用\n\n为当前选择器附加控件\"packageName 等于字符串 str\"的筛选条件。\n\n控件的 packageName 表示控件所属界面的应用包名。例如微信的包名为\"com.tencent.mm\", 那么微信界面的控件的 packageName\n为\"com.tencent.mm\"。\n\n要查看一个应用的包名，可以用函数app.getPackageName()获取，例如toast(app.getPackageName(\"微信\"))。\n\n\nUiSelector.packageNameContains(str)#\n\n * str {string} 要包含的字符串\n\n为当前选择器附加控件\"packageName 需要包含字符串 str\"的筛选条件。\n\n\nUiSelector.packageNameStartsWith(prefix)#\n\n * prefix {string} 前缀\n\n为当前选择器附加控件\"packageName 需要以 prefix 开头\"的筛选条件。\n\n\nUiSelector.packageNameEndsWith(suffix)#\n\n * suffix {string} 后缀\n\n为当前选择器附加控件\"packageName 需要以 suffix 结束\"的筛选条件。\n\n\nUiSelector.packageNameMatches(reg)#\n\n * reg {string} | {Regex} 要满足的正则表达式。\n\n为当前选择器附加控件\"packageName 需要满足正则表达式 reg\"的条件。\n\n有关正则表达式，可以查看正则表达式 - 菜鸟教程。\n\n\nUiSelector.bounds(left, top, right, buttom)#\n\n * left {number} 控件左边缘与屏幕左边的距离\n * top {number} 控件上边缘与屏幕上边的距离\n * right {number} 控件右边缘与屏幕左边的距离\n * bottom {number} 控件下边缘与屏幕上边的距离\n\n一个控件的 bounds\n属性为这个控件在屏幕上显示的范围。我们可以用这个范围来定位这个控件。尽管用这个方法定位控件对于静态页面十分准确，却无法兼容不同分辨率的设备；同时对于列表页面等动\n态页面无法达到效果，因此使用不推荐该选择器。\n\n注意参数的这四个数字不能随意填写，必须精确的填写控件的四个边界才能找到该控件。例如，要点击 QQ 主界面的右上角加号，我们用布局分析查看该控件的属性，如下图：\n\n可以看到 bounds 属性为(951, 67, 1080, 196)，此时使用代码bounds(951, 67, 1080,\n196).clickable().click()即可点击该控件。\n\n\nUiSelector.boundsInside(left, top, right, buttom)#\n\n * left {number} 范围左边缘与屏幕左边的距离\n * top {number} 范围上边缘与屏幕上边的距离\n * right {number} 范围右边缘与屏幕左边的距离\n * bottom {number} 范围下边缘与屏幕上边的距离\n\n为当前选择器附加控件\"bounds 需要在 left, top, right, buttom 构成的范围里面\"的条件。\n\n这个条件用于限制选择器在某一个区域选择控件。例如要在屏幕上半部分寻找文本控件 TextView，代码为:\n\n\n\n其中我们使用了device.width来获取屏幕宽度，device.height来获取屏幕高度。\n\n\nUiSelector.boundsContains(left, top, right, buttom)#\n\n * left {number} 范围左边缘与屏幕左边的距离\n * top {number} 范围上边缘与屏幕上边的距离\n * right {number} 范围右边缘与屏幕左边的距离\n * bottom {number} 范围下边缘与屏幕上边的距离\n\n为当前选择器附加控件\"bounds 需要包含 left, top, right, buttom 构成的范围\"的条件。\n\n这个条件用于限制控件的范围必须包含所给定的范围。例如给定一个点(500, 300), 寻找在这个点上的可点击控件的代码为:\n\n\n\n\nUiSelector.drawingOrder(order)#\n\n * order {number} 控件在父视图中的绘制顺序\n\n为当前选择器附加控件\"drawingOrder 等于 order\"的条件。\n\ndrawingOrder 为一个控件在父控件中的绘制顺序，通常可以用于区分同一层次的控件。\n\n但该属性在 Android 7.0 以上才能使用。\n\n\nUiSelector.clickable([b = true])#\n\n * b {Boolean} 表示控件是否可点击\n\n为当前选择器附加控件是否可点击的条件。但并非所有 clickable 为 false 的控件都真的不能点击，这取决于控件的实现。对于自定义控件(例如显示类名为\nandroid.view.View 的控件)很多的 clickable 属性都为 false 都却能点击。\n\n需要注意的是，可以省略参数b而表示选择那些可以点击的控件，例如className(\"ImageView\").clickable()表示可以点击的图片控件的条件，\nclassName(\"ImageView\").clickable(false)表示不可点击的图片控件的条件。\n\n\nUiSelector.longClickable([b = true])#\n\n * b {Boolean} 表示控件是否可长按\n\n为当前选择器附加控件是否可长按的条件。\n\n\nUiSelector.checkable([b = true])#\n\n * b {Boolean} 表示控件是否可勾选\n\n为当前选择器附加控件是否可勾选的条件。勾选通常是对于勾选框而言的，例如图片多选时左上角通常有一个勾选框。\n\n\nUiSelector.selected([b = true])#\n\n * b {Boolean} 表示控件是否被选\n\n为当前选择器附加控件是否已选中的条件。被选中指的是，例如 QQ 聊天界面点击下方的\"表情按钮\"时，会出现自己收藏的表情，这时\"表情按钮\"便处于选中状态，其\nselected 属性为 true。\n\n\nUiSelector.enabled([b = true])#\n\n * b {Boolean} 表示控件是否已启用\n\n为当前选择器附加控件是否已启用的条件。大多数控件都是启用的状态(enabled 为 true)，处于“禁用”状态通常是灰色并且不可点击。\n\n\nUiSelector.scrollable([b = true])#\n\n * b {Boolean} 表示控件是否可滑动\n\n为当前选择器附加控件是否可滑动的条件。滑动包括上下滑动和左右滑动。\n\n可以用这个条件来寻找可滑动控件来滑动界面。例如滑动 Auto.js 的脚本列表的代码为:\n\n\n\n\nUiSelector.editable([b = true])#\n\n * b {Boolean} 表示控件是否可编辑\n\n为当前选择器附加控件是否可编辑的条件。一般来说可编辑的控件为输入框(EditText)，但不是所有的输入框(EditText)都可编辑。\n\n\nUiSelector.multiLine([b = true])#\n\n * b {Boolean} 表示文本或输入框控件是否是多行显示的\n\n为当前选择器附加控件是否文本或输入框控件是否是多行显示的条件。\n\n\nUiSelector.findOne()#\n\n * 返回 UiObject\n\n根据当前的选择器所确定的筛选条件，对屏幕上的控件进行搜索，直到屏幕上出现满足条件的一个控件为止，并返回该控件。如果找不到控件，当屏幕内容发生变化时会重新寻找，直\n至找到。\n\n需要注意的是，如果屏幕上一直没有出现所描述的控件，则该函数会阻塞，直至所描述的控件出现为止。因此此函数不会返回null。\n\n该函数本来应该命名为untilFindOne()，但由于历史遗留原因已经无法修改。如果想要只在屏幕上搜索一次而不是一直搜索，请使用findOnce()。\n\n另外，如果屏幕上有多个满足条件的控件，findOne()采用深度优先搜索(DFS)，会返回该搜索算法找到的第一个控件。注意控件找到的顺序有时会起到作用。\n\n\nUiSelector.findOne(timeout)#\n\n * timeout {number} 搜索的超时时间，单位毫秒\n * 返回 UiObject\n\n根据当前的选择器所确定的筛选条件，对屏幕上的控件进行搜索，直到屏幕上出现满足条件的一个控件为止，并返回该控件；如果在 timeout\n毫秒的时间内没有找到符合条件的控件，则终止搜索并返回null。\n\n该函数类似于不加参数的findOne()，只不过加上了时间限制。\n\n示例：\n\n\n\n\nUiSelector.findOnce()#\n\n * 返回 UiObject\n\n根据当前的选择器所确定的筛选条件，对屏幕上的控件进行搜索，如果找到符合条件的控件则返回该控件；否则返回null。\n\n\nUiSelector.findOnce(i)#\n\n * i {number} 索引\n\n根据当前的选择器所确定的筛选条件，对屏幕上的控件进行搜索，并返回第 i + 1 个符合条件的控件；如果没有找到符合条件的控件，或者符合条件的控件个数 < i,\n则返回null。\n\n注意这里的控件次序，是搜索算法深度优先搜索(DSF)决定的。\n\n\nUiSelector.find()#\n\n * 返回 UiCollection\n\n根据当前的选择器所确定的筛选条件，对屏幕上的控件进行搜索，找到所有满足条件的控件集合并返回。这个搜索只进行一次，并不保证一定会找到，因而会出现返回的控件集合为空\n的情况。\n\n不同于findOne()或者findOnce()只找到一个控件并返回一个控件，find()函数会找出所有满足条件的控件并返回一个控件集合。之后可以对控件集合进行\n操作。\n\n可以通过 empty()函数判断找到的是否为空。例如：\n\n\n\n\nUiSelector.untilFind()#\n\n * 返回 UiCollection\n\n根据当前的选择器所确定的筛选条件，对屏幕上的控件进行搜索，直到找到至少一个满足条件的控件为止，并返回所有满足条件的控件集合。\n\n该函数与find()函数的区别在于，该函数永远不会返回空集合；但是，如果屏幕上一直没有出现满足条件的控件，则该函数会保持阻塞。\n\n\nUiSelector.exists()#\n\n * 返回 {Boolean}\n\n判断屏幕上是否存在控件符合选择器所确定的条件。例如要判断某个文本出现就执行某个动作，可以用：\n\n\n\n\nUiSelector.waitFor()#\n\n等待屏幕上出现符合条件的控件；在满足该条件的控件出现之前，该函数会一直保持阻塞。\n\n例如要等待包含\"哈哈哈\"的文本控件出现的代码为：\n\n\n\n\nUiSelector.filter(f)#\n\n * f {Function} 过滤函数，参数为 UiObject，返回值为 boolean\n\n为当前选择器附加自定义的过滤条件。\n\n例如，要找出屏幕上所有文本长度为 10 的文本控件的代码为：\n\n","routePath":"/v1/基础/widgetsBasedAutomation/uiSelector","lang":"","toc":[{"text":"selector()","id":"selector","depth":2,"charIndex":2596},{"text":"UiSelector.text(str)","id":"uiselectortextstr","depth":2,"charIndex":2813},{"text":"UiSelector.textContains(str)","id":"uiselectortextcontainsstr","depth":2,"charIndex":2970},{"text":"UiSelector.textStartsWith(prefix)","id":"uiselectortextstartswithprefix","depth":2,"charIndex":3147},{"text":"UiSelector.textEndsWith(suffix)","id":"uiselectortextendswithsuffix","depth":2,"charIndex":3323},{"text":"UiSelector.textMatches(reg)","id":"uiselectortextmatchesreg","depth":2,"charIndex":3419},{"text":"UiSelector.desc(str)","id":"uiselectordescstr","depth":2,"charIndex":3771},{"text":"UiSelector.descContains(str)","id":"uiselectordesccontainsstr","depth":2,"charIndex":4001},{"text":"UiSelector.descStartsWith(prefix)","id":"uiselectordescstartswithprefix","depth":2,"charIndex":4094},{"text":"UiSelector.descEndsWith(suffix)","id":"uiselectordescendswithsuffix","depth":2,"charIndex":4192},{"text":"UiSelector.descMatches(reg)","id":"uiselectordescmatchesreg","depth":2,"charIndex":4288},{"text":"UiSelector.id(resId)","id":"uiselectoridresid","depth":2,"charIndex":4640},{"text":"UiSelector.idContains(str)","id":"uiselectoridcontainsstr","depth":2,"charIndex":5136},{"text":"UiSelector.idStartsWith(prefix)","id":"uiselectoridstartswithprefix","depth":2,"charIndex":5231},{"text":"UiSelector.idEndsWith(suffix)","id":"uiselectoridendswithsuffix","depth":2,"charIndex":5331},{"text":"UiSelector.idMatches(reg)","id":"uiselectoridmatchesreg","depth":2,"charIndex":5429},{"text":"UiSelector.className(str)","id":"uiselectorclassnamestr","depth":2,"charIndex":5738},{"text":"UiSelector.classNameContains(str)","id":"uiselectorclassnamecontainsstr","depth":2,"charIndex":6376},{"text":"UiSelector.classNameStartsWith(prefix)","id":"uiselectorclassnamestartswithprefix","depth":2,"charIndex":6479},{"text":"UiSelector.classNameEndsWith(suffix)","id":"uiselectorclassnameendswithsuffix","depth":2,"charIndex":6587},{"text":"UiSelector.classNameMatches(reg)","id":"uiselectorclassnamematchesreg","depth":2,"charIndex":6693},{"text":"UiSelector.packageName(str)","id":"uiselectorpackagenamestr","depth":2,"charIndex":7055},{"text":"UiSelector.packageNameContains(str)","id":"uiselectorpackagenamecontainsstr","depth":2,"charIndex":7356},{"text":"UiSelector.packageNameStartsWith(prefix)","id":"uiselectorpackagenamestartswithprefix","depth":2,"charIndex":7463},{"text":"UiSelector.packageNameEndsWith(suffix)","id":"uiselectorpackagenameendswithsuffix","depth":2,"charIndex":7575},{"text":"UiSelector.packageNameMatches(reg)","id":"uiselectorpackagenamematchesreg","depth":2,"charIndex":7685},{"text":"UiSelector.bounds(left, top, right, buttom)","id":"uiselectorboundsleft-top-right-buttom","depth":2,"charIndex":7831},{"text":"UiSelector.boundsInside(left, top, right, buttom)","id":"uiselectorboundsinsideleft-top-right-buttom","depth":2,"charIndex":8302},{"text":"UiSelector.boundsContains(left, top, right, buttom)","id":"uiselectorboundscontainsleft-top-right-buttom","depth":2,"charIndex":8649},{"text":"UiSelector.drawingOrder(order)","id":"uiselectordrawingorderorder","depth":2,"charIndex":8956},{"text":"UiSelector.clickable([b = true])","id":"uiselectorclickableb--true","depth":2,"charIndex":9135},{"text":"UiSelector.longClickable([b = true])","id":"uiselectorlongclickableb--true","depth":2,"charIndex":9469},{"text":"UiSelector.checkable([b = true])","id":"uiselectorcheckableb--true","depth":2,"charIndex":9556},{"text":"UiSelector.selected([b = true])","id":"uiselectorselectedb--true","depth":2,"charIndex":9672},{"text":"UiSelector.enabled([b = true])","id":"uiselectorenabledb--true","depth":2,"charIndex":9830},{"text":"UiSelector.scrollable([b = true])","id":"uiselectorscrollableb--true","depth":2,"charIndex":9960},{"text":"UiSelector.editable([b = true])","id":"uiselectoreditableb--true","depth":2,"charIndex":10106},{"text":"UiSelector.multiLine([b = true])","id":"uiselectormultilineb--true","depth":2,"charIndex":10237},{"text":"UiSelector.findOne()","id":"uiselectorfindone","depth":2,"charIndex":10341},{"text":"UiSelector.findOne(timeout)","id":"uiselectorfindonetimeout","depth":2,"charIndex":10686},{"text":"UiSelector.findOnce()","id":"uiselectorfindonce","depth":2,"charIndex":10907},{"text":"UiSelector.findOnce(i)","id":"uiselectorfindoncei","depth":2,"charIndex":11006},{"text":"UiSelector.find()","id":"uiselectorfind","depth":2,"charIndex":11172},{"text":"UiSelector.untilFind()","id":"uiselectoruntilfind","depth":2,"charIndex":11417},{"text":"UiSelector.exists()","id":"uiselectorexists","depth":2,"charIndex":11592},{"text":"UiSelector.waitFor()","id":"uiselectorwaitfor","depth":2,"charIndex":11682},{"text":"UiSelector.filter(f)","id":"uiselectorfilterf","depth":2,"charIndex":11776}],"domain":"","frontmatter":{},"version":""},{"id":67,"title":"UiSelector 进阶","content":"#\n\n未完待续。","routePath":"/v1/基础/widgetsBasedAutomation/uiSelector进阶","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":68,"title":"axios","content":"#\n\nv6.3.9 新增\n\n稳定性: 实验\n\n\n注意: 这个模块是异步的，返回的全部都是Promise，如果你的程序有大量阻塞函数，请谨慎使用 这个模块不会自动加载，如需使用，请用\n\n\n\n模块使用方法与 axios 完全一致，请参阅官方网站，以下只介绍一些在 autox 中特有的内容。\n\n这个模块通过模拟浏览器关键对象XMLHttpRequest得以运行，内部使用 okhttp 进行网络请求，行为与浏览器中有些许差异。\n\n不支持的内容:\n\n * ArrayBuffer 不支持处理和解析\n * XMLHttpRequest.overrideMimeType()\n * XMLHttpRequest.timeout 暂不支持设置\n * 上传和下载进度事件\n\n支持的responseType:\n\n * text\n * json\n * blob\n * inputstream java 输入流\n * stream Readable 可读流 *v6.4.0 新增\n\n支持的请求体数据类型:\n\n * RequestBody okhttp3.RequestBody 对象\n * FormData\n * Blob\n * InputStream java 输入流\n * String\n * plain object 会解析成 json\n\n一个简单的示例\n\n\n\n\naxios.browser#\n\n用于模拟浏览器环境的对象，包含XMLHttpRequest、FormData等，除了FormData，其他对象都不建议使用。\n\n\naxios.utils#\n\n包含一些操作 blob 对象方法\n\n\nutils.saveBlobToFile(blob, path)#\n\n * blob {Blob} 要保存的对象\n * path {String} 保存路径\n\n保存 blob 对象到指定路径，返回一个Promise。\n\n\nutils.openFile(path)#\n\n * path {String} 要打开的文件路径\n\n打开一个文件，返回一个 blob 对象\n\n\nutils.copyInputStream(inputstream, outputstream)#\n\n * inputstreamjava 输入流\n * outputstream java 输出流\n\n拷贝输入流到输出流，这个函数是阻塞的，且不会自动关闭流。\n\n\nutils.ThreadPool#\n\n此对象用于将一个同步函数转成异步方法运行，返回一个Promise，例如\n\n","routePath":"/v1/高级/axios","lang":"","toc":[{"text":"axios.browser","id":"axiosbrowser","depth":2,"charIndex":574},{"text":"axios.utils","id":"axiosutils","depth":2,"charIndex":655},{"text":"utils.saveBlobToFile(blob, path)","id":"utilssaveblobtofileblob-path","depth":3,"charIndex":688},{"text":"utils.openFile(path)","id":"utilsopenfilepath","depth":3,"charIndex":799},{"text":"utils.copyInputStream(inputstream, outputstream)","id":"utilscopyinputstreaminputstream-outputstream","depth":3,"charIndex":871},{"text":"utils.ThreadPool","id":"utilsthreadpool","depth":3,"charIndex":1002}],"domain":"","frontmatter":{},"version":""},{"id":69,"title":"$base64.decode(str[, encoding = 'utf-8'])","content":"Base64 编码#\n\n提供基本的 Base64 转换函数。\n\n\n$base64.encode(str[, encoding = 'utf-8'])#\n\n * str {string} 要编码的字符串\n * encoding {string} 可选，字符编码\n\n将字符串 str autox.js 使用 Base64 编码并返回编码后的字符串。\n\n\n\n\n$base64.decode(str[, encoding = 'utf-8'])#\n\n * str {string} 要解码的字符串\n * encoding {string} 可选，字符编码\n\n将字符串 st YXV0b3gunM= r 使用 Base64 解码并返回解码后的字符串。\n\n","routePath":"/v1/高级/base64","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":70,"title":"Canvas","content":"#\n\ncanvas 提供了使用画布进行 2D 画图的支持，可用于简单的小游戏开发或者图片编辑。使用 canvas 可以轻松地在一张图片或一个界面上绘制各种线与图形。\n\ncanvas 的坐标系为平面直角坐标系，以屏幕左上角为原点，屏幕上边为 x 轴正方向，屏幕左边为 y 轴正方向。例如分辨率为 1920*1080\n的屏幕上，画一条从屏幕左上角到屏幕右下角的线段为:\n\n\n\ncanvas 的绘制依赖于画笔 Paint, 通过设置画笔的粗细、颜色、填充等可以改变绘制出来的图形。例如绘制一个红色实心正方形为：\n\n\n\n如果要绘制正方形的边框，则通过设置画笔的 Style 来实现：\n\n\n\n结合画笔 canvas 可以绘制基本图形、图片等。\n\n\ncanvas.drawARGB(a, r, g, b)#\n\n\ncanvas.draw#","routePath":"/v1/高级/canvas","lang":"","toc":[{"text":"canvas.drawARGB(a, r, g, b)","id":"canvasdrawargba-r-g-b","depth":2,"charIndex":318},{"text":"canvas.draw","id":"canvasdraw","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":71,"title":"协程","content":"#\n\n见 App 中 示例代码 / 协程\n\n\nPromise.coroutine()#\n\nv6.3.7 新增 在该版本引入 bluebird 后你可以使用 bluebird 带来的一项协程特性，这个方法接收一个Generator\n函数作为参数，函数内部可以像async 函数一样编写，返回一个返回值为Promise的函数，说起来可能有点难以理解，具体看下方例子\n\n\n\n可以看到只要将 await 关键换成 yield 就能够代替还不支持的 async 函数，下方是一个异步循环的例子\n\n\n\n与 async 函数不同的是 yield 关键字作为表达式使用时必须带上圆括号，否则会有语法错误，在默认情况下 yield 后面只能是 Promise 或带有\nthen 方法的对象，要处理其他类型数据需要使用Promise.coroutine.addYieldHandler()添加处理器\n\n\nPromise.coroutine.addYieldHandler(handler)#\n\n * handler {function} 处理函数\n\n函数的参数为 yield 的导出，反回值为 yield 的反回","routePath":"/v1/高级/continuation","lang":"","toc":[{"text":"Promise.coroutine()","id":"promisecoroutine","depth":2,"charIndex":22},{"text":"Promise.coroutine.addYieldHandler(handler)","id":"promisecoroutineaddyieldhandlerhandler","depth":2,"charIndex":391}],"domain":"","frontmatter":{},"version":""},{"id":72,"title":"crypto","content":"#\n\n$crypto 模块提供了对称加密（例如 AES）、非对称加密（例如 RSA）、消息摘要（例如 MD5, SHA）等支持。\n\n\n\n","routePath":"/v1/高级/crypto","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":73,"title":"Dialog","content":"#\n\ndialogs.build()返回的对话框对象，内置一些事件用于响应用户的交互，也可以获取对话框的状态和信息。\n\n\n事件: show#\n\n * dialog {Dialog} 对话框\n\n对话框显示时会触发的事件。例如：\n\n\n\n\n事件: cancel#\n\n * dialog {Dialog} 对话框\n\n对话框被取消时会触发的事件。一个对话框可能按取消按钮、返回键取消或者点击对话框以外区域取消。例如：\n\n\n\n\n事件: dismiss#\n\n * dialog {Dialog} 对话框\n\n对话框消失时会触发的事件。对话框被取消或者手动调用dialog.dismiss()函数都会触发该事件。例如：\n\n\n\n\n事件: positive#\n\n * dialog {Dialog} 对话框\n\n确定按钮按下时触发的事件。例如：\n\n\n\n\n事件: negative#\n\n * dialog {Dialog} 对话框\n\n取消按钮按下时触发的事件。例如：\n\n\n\n\n事件: neutral#\n\n * dialog {Dialog} 对话框\n\n中性按钮按下时触发的事件。例如：\n\n\n\n\n事件: any#\n\n * dialog {Dialog} 对话框\n * action {string} 被点击的按钮，可能的值为:\n   * positive 确定按钮\n   * negative 取消按钮\n   * neutral 中性按钮\n\n任意按钮按下时触发的事件。例如:\n\n\n\n\n事件: item_select#\n\n * index {number} 被选中的项目索引，从 0 开始\n * item {Object} 被选中的项目\n * dialog {Dialog} 对话框\n\n对话框列表(itemsSelectMode 为\"select\")的项目被点击选中时触发的事件。例如：\n\n\n\n\n事件: single_choice#\n\n * index {number} 被选中的项目索引，从 0 开始\n * item {Object} 被选中的项目\n * dialog {Dialog} 对话框\n\n对话框单选列表(itemsSelectMode 为\"singleChoice\")的项目被选中并点击确定时触发的事件。例如：\n\n\n\n\n事件: multi_choice#\n\n * indices {Array} 被选中的项目的索引的数组\n * items {Array} 被选中的项目的数组\n * dialog {Dialog} 对话框\n\n对话框多选列表(itemsSelectMode 为\"multiChoice\")的项目被选中并点击确定时触发的事件。例如：\n\n\n\n\n事件: input#\n\n * text {string} 输入框的内容\n * dialog {Dialog} 对话框\n\n带有输入框的对话框当点击确定时会触发的事件。例如：\n\n\n\n\n事件: input_change#\n\n * text {string} 输入框的内容\n * dialog {Dialog} 对话框\n\n对话框的输入框的文本发生变化时会触发的事件。例如：\n\n\n\n\ndialog.getProgress()#\n\n * 返回 {number}\n\n获取当前进度条的进度值，是一个整数\n\n\ndialog.getMaxProgress()#\n\n * 返回 {number}\n\n获取当前进度条的最大进度值，是一个整数\n\n\ndialog.getActionButton(action)#\n\n * action {string} 动作，包括:\n   * positive\n   * negative\n   * neutral","routePath":"/v1/高级/dialogs/dialog","lang":"","toc":[{"text":"事件: `show`","id":"事件-show","depth":2,"charIndex":-1},{"text":"事件: `cancel`","id":"事件-cancel","depth":2,"charIndex":-1},{"text":"事件: `dismiss`","id":"事件-dismiss","depth":2,"charIndex":-1},{"text":"事件: `positive`","id":"事件-positive","depth":2,"charIndex":-1},{"text":"事件: `negative`","id":"事件-negative","depth":2,"charIndex":-1},{"text":"事件: `neutral`","id":"事件-neutral","depth":2,"charIndex":-1},{"text":"事件: `any`","id":"事件-any","depth":2,"charIndex":-1},{"text":"事件: `item_select`","id":"事件-item_select","depth":2,"charIndex":-1},{"text":"事件: `single_choice`","id":"事件-single_choice","depth":2,"charIndex":-1},{"text":"事件: `multi_choice`","id":"事件-multi_choice","depth":2,"charIndex":-1},{"text":"事件: `input`","id":"事件-input","depth":2,"charIndex":-1},{"text":"事件: `input_change`","id":"事件-input_change","depth":2,"charIndex":-1},{"text":"dialog.getProgress()","id":"dialoggetprogress","depth":2,"charIndex":1304},{"text":"dialog.getMaxProgress()","id":"dialoggetmaxprogress","depth":2,"charIndex":1363},{"text":"dialog.getActionButton(action)","id":"dialoggetactionbuttonaction","depth":2,"charIndex":1427}],"domain":"","frontmatter":{},"version":""},{"id":74,"title":"Dialogs","content":"#\n\n稳定性: 稳定\n\n\ndialogs 模块提供了简单的对话框支持，可以通过对话框和用户进行交互。最简单的例子如下：\n\n\n\n这段代码会弹出一个消息提示框显示\"您好\"，并在用户点击\"确定\"后继续运行。稍微复杂一点的例子如下：\n\n\n\nconfirm()会弹出一个对话框并让用户选择\"是\"或\"否\"，如果选择\"是\"则返回 true。\n\n需要特别注意的是，对话框在 ui 模式下不能像通常那样使用，应该使用回调函数或者Promise的形式。理解这一点可能稍有困难。举个例子:\n\n\n\n\ndialogs.alert(title[, content, callback])#\n\n * title {string} 对话框的标题。\n * content {string} 可选，对话框的内容。默认为空。\n * callback {Function} 回调函数，可选。当用户点击确定时被调用,一般用于 ui 模式。\n\n显示一个只包含“确定”按钮的提示对话框。直至用户点击确定脚本才继续运行。\n\n该函数也可以作为全局函数使用。\n\n\n\n在 ui 模式下该函数返回一个Promise。例如:\n\n\n\n\ndialogs.confirm(title[, content, callback])#\n\n * title {string} 对话框的标题。\n * content {string} 可选，对话框的内容。默认为空。\n * callback {Function} 回调函数，可选。当用户点击确定时被调用,一般用于 ui 模式。\n\n显示一个包含“确定”和“取消”按钮的提示对话框。如果用户点击“确定”则返回 true ，否则返回 false 。\n\n该函数也可以作为全局函数使用。\n\n在 ui 模式下该函数返回一个Promise。例如:\n\n\n\n\ndialogs.rawInput(title[, prefill, callback])#\n\n * title {string} 对话框的标题。\n * prefill {string} 输入框的初始内容，可选，默认为空。\n * callback {Function} 回调函数，可选。当用户点击确定时被调用,一般用于 ui 模式。\n\n显示一个包含输入框的对话框，等待用户输入内容，并在用户点击确定时将输入的字符串返回。如果用户取消了输入，返回 null。\n\n该函数也可以作为全局函数使用。\n\n\n\n在 ui 模式下该函数返回一个Promise。例如:\n\n\n\n当然也可以使用回调函数，例如:\n\n\n\n\ndialogs.input(title[, prefill, callback])#\n\n等效于 eval(dialogs.rawInput(title, prefill, callback)), 该函数和 rawInput\n的区别在于，会把输入的字符串用 eval 计算一遍再返回，返回的可能不是字符串。\n\n可以用该函数输入数字、数组等。例如：\n\n\n\n在 ui 模式下该函数返回一个Promise。例如:\n\n\n\n\ndialogs.prompt(title[, prefill, callback])#\n\n相当于 dialogs.rawInput();\n\n\ndialogs.select(title, items, callback)#\n\n * title {string} 对话框的标题。\n * items {Array} 对话框的选项列表，是一个字符串数组。\n * callback {Function} 回调函数，可选。当用户点击确定时被调用,一般用于 ui 模式。\n\n显示一个带有选项列表的对话框，等待用户选择，返回用户选择的选项索引(0 ~ item.length - 1)。如果用户取消了选择，返回-1。\n\n\n\n在 ui 模式下该函数返回一个Promise。例如:\n\n\n\n\ndialogs.singleChoice(title, items[, index, callback])#\n\n * title {string} 对话框的标题。\n * items {Array} 对话框的选项列表，是一个字符串数组。\n * index {number} 对话框的初始选项的位置，默认为 0。\n * callback {Function} 回调函数，可选。当用户点击确定时被调用,一般用于 ui 模式。\n\n显示一个单选列表对话框，等待用户选择，返回用户选择的选项索引(0 ~ item.length - 1)。如果用户取消了选择，返回-1。\n\n在 ui 模式下该函数返回一个Promise。\n\n\ndialogs.multiChoice(title, items[, indices, callback])#\n\n * title {string} 对话框的标题。\n * items {Array} 对话框的选项列表，是一个字符串数组。\n * indices {Array} 选项列表中初始选中的项目索引的数组，默认为空数组。\n * callback {Function} 回调函数，可选。当用户点击确定时被调用,一般用于 ui 模式。\n\n显示一个多选列表对话框，等待用户选择，返回用户选择的选项索引的数组。如果用户取消了选择，返回[]。\n\n在 ui 模式下该函数返回一个Promise。\n\n\ndialogs.build(properties)#\n\n * properties {Object} 对话框属性，用于配置对话框。\n * 返回 {Dialog}\n\n创建一个可自定义的对话框，例如：\n\n\n\n选项 properties 可供配置的项目为:\n\n * title {string} 对话框标题\n * titleColor {string} | {number} 对话框标题的颜色\n * buttonRippleColor {string} | {number} 对话框按钮的波纹效果颜色\n * icon {string} | {Image} 对话框的图标，是一个 URL 或者图片对象\n * content {string} 对话框文字内容\n * contentColor{string} | {number} 对话框文字内容的颜色\n * contentLineSpacing{number} 对话框文字内容的行高倍数，1.0 为一倍行高\n * items {Array} 对话框列表的选项\n * itemsColor {string} | {number} 对话框列表的选项的文字颜色\n * itemsSelectMode {string} 对话框列表的选项选择模式，可以为:\n   * select 普通选择模式\n   * single 单选模式\n   * multi 多选模式\n * itemsSelectedIndex {number} | {Array} 对话框列表中预先选中的项目索引，如果是单选模式为一个索引；多选模式则为数组\n * positive {string} 对话框确定按钮的文字内容(最右边按钮)\n * positiveColor {string} | {number} 对话框确定按钮的文字颜色(最右边按钮)\n * neutral {string} 对话框中立按钮的文字内容(最左边按钮)\n * neutralColor {string} | {number} 对话框中立按钮的文字颜色(最左边按钮)\n * negative {string} 对话框取消按钮的文字内容(确定按钮左边的按钮)\n * negativeColor {string} | {number} 对话框取消按钮的文字颜色(确定按钮左边的按钮)\n * checkBoxPrompt {string} 勾选框文字内容\n * checkBoxChecked {boolean} 勾选框是否勾选\n * progress {Object} 配置对话框进度条的对象：\n   * max {number} 进度条的最大值，如果为-1 则为无限循环的进度条\n   * horizontal {boolean} 如果为 true, 则对话框无限循环的进度条为水平进度条\n   * showMinMax {boolean} 是否显示进度条的最大值和最小值\n * cancelable {boolean} 对话框是否可取消，如果为 false，则对话框只能用代码手动取消\n * canceledOnTouchOutside {boolean} 对话框是否在点击对话框以外区域时自动取消，默认为 true\n * inputHint {string} 对话框的输入框的输入提示\n * inputPrefill {string} 对话框输入框的默认输入内容\n\n通过这些选项可以自定义一个对话框，并通过监听返回的 Dialog 对象的按键、输入事件来实现交互。下面是一些例子。\n\n模拟 alert 对话框：\n\n\n\n模拟 confirm 对话框:\n\n\n\n模拟单选框:\n\n\n\n\"处理中\"对话框:\n\n\n\n输入对话框:\n\n\n\n使用这个函数来构造对话框，一个明显的不同是需要使用回调函数而不能像 dialogs 其他函数一样同步地返回结果；但也可以通过 threads\n模块的方法来实现。例如显示一个输入框并获取输入结果为：\n\n","routePath":"/v1/高级/dialogs/dialogs","lang":"","toc":[{"text":"dialogs.alert(title[, content, callback])","id":"dialogsalerttitle-content-callback","depth":2,"charIndex":237},{"text":"dialogs.confirm(title[, content, callback])","id":"dialogsconfirmtitle-content-callback","depth":2,"charIndex":487},{"text":"dialogs.rawInput(title[, prefill, callback])","id":"dialogsrawinputtitle-prefill-callback","depth":2,"charIndex":757},{"text":"dialogs.input(title[, prefill, callback])","id":"dialogsinputtitle-prefill-callback","depth":2,"charIndex":1055},{"text":"dialogs.prompt(title[, prefill, callback])","id":"dialogsprompttitle-prefill-callback","depth":2,"charIndex":1262},{"text":"dialogs.select(title, items, callback)","id":"dialogsselecttitle-items-callback","depth":2,"charIndex":1333},{"text":"dialogs.singleChoice(title, items[, index, callback])","id":"dialogssinglechoicetitle-items-index-callback","depth":2,"charIndex":1597},{"text":"dialogs.multiChoice(title, items[, indices, callback])","id":"dialogsmultichoicetitle-items-indices-callback","depth":2,"charIndex":1903},{"text":"dialogs.build(properties)","id":"dialogsbuildproperties","depth":2,"charIndex":2200}],"domain":"","frontmatter":{},"version":""},{"id":75,"title":"Engines","content":"#\n\n稳定性: 稳定\n\n\nengines 模块包含了一些与脚本环境、脚本运行、脚本引擎有关的函数，包括运行其他脚本，关闭脚本等。\n\n例如，获取脚本所在目录：\n\n\n\n\nEngines#\n\n\nengines.execScript(name, script[, config])#\n\n * name {string} 要运行的脚本名称。这个名称和文件名称无关，只是在任务管理中显示的名称。\n * script {string} 要运行的脚本内容。\n * config {Object} 运行配置项\n   * delay {number} 延迟执行的毫秒数，默认为 0\n   * loopTimes {number} 循环运行次数，默认为 1。0 为无限循环。\n   * interval {number} 循环运行时两次运行之间的时间间隔，默认为 0\n   * path {Array} | {string} 指定脚本运行的目录。这些路径会用于 require 时寻找模块文件。\n\n在新的脚本环境中运行脚本 script。返回一个ScriptExectuion对象。\n\n所谓新的脚本环境，指定是，脚本中的变量和原脚本的变量是不共享的，并且，脚本会在新的线程中运行。\n\n最简单的例子如下：\n\n\n\n如果要循环运行，则：\n\n\n\n用字符串来编写脚本非常不方便，可以结合 Function.toString()的方法来执行特定函数:\n\n\n\n如果要传递变量，则可以把这些封装成一个函数：\n\n\n\n\nengines.execScriptFile(path[, config])#\n\n * path {string} 要运行的脚本路径。\n * config {Object} 运行配置项\n   * delay {number} 延迟执行的毫秒数，默认为 0\n   * loopTimes {number} 循环运行次数，默认为 1。0 为无限循环。\n   * interval {number} 循环运行时两次运行之间的时间间隔，默认为 0\n   * path {Array} | {string} 指定脚本运行的目录。这些路径会用于 require 时寻找模块文件。\n\n在新的脚本环境中运行脚本文件 path。返回一个ScriptExecution对象。\n\n\n\n\nengines.execAutoFile(path[, config])#\n\n * path {string} 要运行的录制文件路径。\n * config {Object} 运行配置项\n   * delay {number} 延迟执行的毫秒数，默认为 0\n   * loopTimes {number} 循环运行次数，默认为 1。0 为无限循环。\n   * interval {number} 循环运行时两次运行之间的时间间隔，默认为 0\n   * path {Array} | {string} 指定脚本运行的目录。这些路径会用于 require 时寻找模块文件。\n\n在新的脚本环境中运行录制文件 path。返回一个ScriptExecution对象。\n\n\n\n\nengines.stopAll()#\n\n停止所有正在运行的脚本。包括当前脚本自身。\n\n\nengines.stopAllAndToast()#\n\n停止所有正在运行的脚本并显示停止的脚本数量。包括当前脚本自身。\n\n\nengines.myEngine()#\n\n返回当前脚本的脚本引擎对象(ScriptEngine)\n\n[v4.1.0 新增] 特别的，该对象可以通过execArgv来获取他的运行参数，包括外部参数、intent 等。例如：\n\n\n\n普通脚本的运行参数通常为空，通过定时任务的广播启动的则可以获取到启动的 intent。\n\n\nengines.all()#\n\n * 返回 {Array}\n\n返回当前所有正在运行的脚本的脚本引擎ScriptEngine的数组。\n\n","routePath":"/v1/高级/engines/engines","lang":"","toc":[{"text":"engines.execScript(name, script[, config])","id":"enginesexecscriptname-script-config","depth":2,"charIndex":93},{"text":"engines.execScriptFile(path[, config])","id":"enginesexecscriptfilepath-config","depth":2,"charIndex":638},{"text":"engines.execAutoFile(path[, config])","id":"enginesexecautofilepath-config","depth":2,"charIndex":970},{"text":"engines.stopAll()","id":"enginesstopall","depth":2,"charIndex":1302},{"text":"engines.stopAllAndToast()","id":"enginesstopallandtoast","depth":2,"charIndex":1346},{"text":"engines.myEngine()","id":"enginesmyengine","depth":2,"charIndex":1408},{"text":"engines.all()","id":"enginesall","depth":2,"charIndex":1568}],"domain":"","frontmatter":{},"version":""},{"id":76,"title":"ScriptConfig","content":"#\n\n脚本执行时的配置。\n\n\ndelay#\n\n * {number}\n\n延迟执行的毫秒数\n\n\ninterval#\n\n * {number}\n\n循环运行时两次运行之间的时间间隔\n\n\nloopTimes#\n\n * {number}\n\n循环运行次数\n\n\ngetPath()#\n\n * 返回 {Array}\n\n返回一个字符串数组表示脚本运行时模块寻找的路径。","routePath":"/v1/高级/engines/scriptConfig","lang":"","toc":[{"text":"delay","id":"delay","depth":2,"charIndex":14},{"text":"interval","id":"interval","depth":2,"charIndex":46},{"text":"loopTimes","id":"looptimes","depth":2,"charIndex":89},{"text":"getPath()","id":"getpath","depth":2,"charIndex":123}],"domain":"","frontmatter":{},"version":""},{"id":77,"title":"ScriptEngine","content":"#\n\n脚本引擎对象。\n\n\nScriptEngine.isDestroyed()#\n\n * 返回 {Boolean}\n\n检测该脚本是否执行结束\n\n\n\n\nScriptEngine.forceStop()#\n\n停止脚本引擎的执行。\n\n\nScriptEngine.cwd()#\n\n * 返回 {string}\n\n返回脚本执行的路径。对于一个脚本文件而言为这个脚本所在的文件夹；对于其他脚本，例如字符串脚本，则为null或者执行时的设置值。\n\n\nScriptEngine.getSource()#\n\n * 返回 ScriptSource\n\n返回当前脚本引擎正在执行的脚本对象。\n\n\n\n\nScriptEngine.emit(eventName[, ...args])#\n\n * eventName {string} 事件名称\n * ...args {any} 事件参数\n\n向该脚本引擎发送一个事件，该事件可以在该脚本引擎对应的脚本的 events 模块监听到并在脚本主线程执行事件处理。\n\n例如脚本 receiver.js 的内容如下：\n\n\n\n同一目录另一脚本可以启动他并发送该事件：\n\n","routePath":"/v1/高级/engines/scriptEngine","lang":"","toc":[{"text":"ScriptEngine.isDestroyed()","id":"scriptengineisdestroyed","depth":2,"charIndex":12},{"text":"ScriptEngine.forceStop()","id":"scriptengineforcestop","depth":2,"charIndex":74},{"text":"ScriptEngine.cwd()","id":"scriptenginecwd","depth":2,"charIndex":114},{"text":"ScriptEngine.getSource()","id":"scriptenginegetsource","depth":2,"charIndex":217},{"text":"ScriptEngine.emit(eventName[, ...args])","id":"scriptengineemiteventname-args","depth":2,"charIndex":287}],"domain":"","frontmatter":{},"version":""},{"id":78,"title":"ScriptExecution","content":"#\n\n执行脚本时返回的对象，可以通过他获取执行的引擎、配置等，也可以停止这个执行。\n\n要停止这个脚本的执行，使用exectuion.getEngine().forceStop().\n\n\nScriptExecution.getEngine()#\n\n返回执行该脚本的脚本引擎对象(ScriptEngine)\n\n\nScriptExecution.getConfig()#\n\n返回该脚本的运行配置(ScriptConfig)","routePath":"/v1/高级/engines/scriptExecution","lang":"","toc":[{"text":"ScriptExecution.getEngine()","id":"scriptexecutiongetengine","depth":2,"charIndex":92},{"text":"ScriptExecution.getConfig()","id":"scriptexecutiongetconfig","depth":2,"charIndex":153}],"domain":"","frontmatter":{},"version":""},{"id":79,"title":"events.broadcast","content":"Events#\n\n稳定性: 稳定\n\n\nevents 模块提供了监听手机通知、按键、触摸的接口。您可以用他配合自动操作函数完成自动化工作。\n\nevents 本身是一个EventEmiiter, 但内置了一些事件、包括按键事件、通知事件、Toast 事件等。\n\n需要注意的是，事件的处理是单线程的，并且仍然在原线程执行，如果脚本主体或者其他事件处理中有耗时操作、轮询等，则事件将无法得到及时处理（会进入事件队列等待脚本主体\n或其他事件处理完成才执行）。例如:\n\n\n\n\nevents.emitter()#\n\n返回一个新的EventEmitter。这个 EventEmitter 没有内置任何事件。\n\n\nevents.observeKey()#\n\n启用按键监听，例如音量键、Home 键。按键监听使用无障碍服务实现，如果无障碍服务未启用会抛出异常并提示开启。\n\n只有这个函数成功执行后, onKeyDown, onKeyUp等按键事件的监听才有效。\n\n该函数在安卓 4.3 以上才能使用。\n\n\nevents.onKeyDown(keyName, listener)#\n\n * keyName {string} 要监听的按键名称\n * listener {Function} 按键监听器。参数为一个KeyEvent。\n\n注册一个按键监听函数，当有 keyName 对应的按键被按下会调用该函数。可用的按键名称参见Keys。\n\n例如:\n\n\n\n\nevents.onKeyUp(keyName, listener)#\n\n * keyName {string} 要监听的按键名称\n * listener {Function} 按键监听器。参数为一个KeyEvent。\n\n注册一个按键监听函数，当有 keyName 对应的按键弹起会调用该函数。可用的按键名称参见Keys。\n\n一次完整的按键动作包括了按键按下和弹起。按下事件会在手指按下一个按键的\"瞬间\"触发, 弹起事件则在手指放开这个按键时触发。\n\n例如:\n\n\n\n\nevents.onceKeyDown(keyName, listener)#\n\n * keyName {string} 要监听的按键名称\n * listener {Function} 按键监听器。参数为一个KeyEvent\n\n注册一个按键监听函数，当有 keyName 对应的按键被按下时会调用该函数，之后会注销该按键监听器。\n\n也就是 listener 只有在 onceKeyDown 调用后的第一次按键事件被调用一次。\n\n\nevents.onceKeyUp(keyName, listener)#\n\n * keyName {string} 要监听的按键名称\n * listener {Function} 按键监听器。参数为一个KeyEvent\n\n注册一个按键监听函数，当有 keyName 对应的按键弹起时会调用该函数，之后会注销该按键监听器。\n\n也就是 listener 只有在 onceKeyUp 调用后的第一次按键事件被调用一次。\n\n\nevents.removeAllKeyDownListeners(keyName)#\n\n * keyName {string} 按键名称\n\n删除该按键的 KeyDown(按下)事件的所有监听。\n\n\nevents.removeAllKeyUpListeners(keyName)#\n\n * keyName {string} 按键名称\n\n删除该按键的 KeyUp(弹起)事件的所有监听。\n\n\nevents.setKeyInterceptionEnabled([key, ]enabled)#\n\n * enabled {boolean}\n * key {string} 要屏蔽的按键\n\n设置按键屏蔽是否启用。所谓按键屏蔽指的是，屏蔽原有按键的功能，例如使得音量键不再能调节音量，但此时仍然能通过按键事件监听按键。\n\n如果不加参数 key 则会屏蔽所有按键。\n\n例如，调用events.setKeyInterceptionEnabled(true)会使系统的音量、Home、返回等键不再具有调节音量、回到主页、返回的作用，\n但此时仍然能通过按键事件监听按键。\n\n该函数通常于按键监听结合，例如想监听音量键并使音量键按下时不弹出音量调节框则为：\n\n\n\n只要有一个脚本屏蔽了某个按键，该按键便会被屏蔽；当脚本退出时，会自动解除所有按键屏蔽。\n\n\nevents.observeTouch()#\n\n启用屏幕触摸监听。（需要 root 权限）\n\n只有这个函数被成功执行后, 触摸事件的监听才有效。\n\n没有 root 权限调用该函数则什么也不会发生。\n\n\nevents.setTouchEventTimeout(timeout)#\n\n * timeout {number} 两个触摸事件的最小间隔。单位毫秒。默认为 10 毫秒。如果 number 小于 0，视为 0 处理。\n\n设置两个触摸事件分发的最小时间间隔。\n\n例如间隔为 10 毫秒的话，前一个触摸事件发生并被注册的监听器处理后，至少要过 10 毫秒才能分发和处理下一个触摸事件，这 10 毫秒之间的触摸将会被忽略。\n\n建议在满足需要的情况下尽量提高这个间隔。一个简单滑动动作可能会连续触发上百个触摸事件，如果 timeout 设置过低可能造成事件拥堵。强烈建议不要设置\ntimeout 为 0。\n\n\nevents.getTouchEventTimeout()#\n\n返回触摸事件的最小时间间隔。\n\n\nevents.onTouch(listener)#\n\n * listener {Function} 参数为Point的函数\n\n注册一个触摸监听函数。相当于on(\"touch\", listener)。\n\n例如:\n\n\n\n\nevents.removeAllTouchListeners()#\n\n删除所有事件监听函数。\n\n\n事件: 'key'#\n\n * keyCode {number} 键值\n * event {KeyEvent} 事件\n\n当有按键被按下或弹起时会触发该事件。 例如：\n\n\n\n其中监听器的参数 KeyCode 包括：\n\n * keys.home 主页键\n * keys.back 返回键\n * keys.menu 菜单键\n * keys.volume_up 音量上键\n * keys.volume_down 音量下键\n\n例如：\n\n\n\n\n事件: 'key_down'#\n\n * keyCode {number} 键值\n * event {KeyEvent} 事件\n\n当有按键被按下时会触发该事件。\n\n\n\n\n事件: 'key_up'#\n\n * keyCode {number} 键值\n * event {KeyEvent} 事件\n\n当有按键弹起时会触发该事件。\n\n\n\n\n事件: 'exit`#\n\n当脚本正常或者异常退出时会触发该事件。事件处理中如果有异常抛出，则立即中止 exit 事件的处理（即使 exit\n事件有多个处理函数）并在控制台和日志中打印该异常。\n\n一个脚本停止运行时，会关闭该脚本的所有悬浮窗，触发 exit 事件，之后再回收资源。如果 exit 事件的处理中有死循环，则后续资源无法得到及时回收。\n此时脚本会停留在任务列表，如果在任务列表中关闭，则会强制结束 exit 事件的处理并回收后续资源。\n\n\n\n\nevents.observeNotification()#\n\n开启通知监听。例如 QQ 消息、微信消息、推送等通知。\n\n通知监听依赖于通知服务，如果通知服务没有运行，会抛出异常并跳转到通知权限开启界面。（有时即使通知权限已经开启通知服务也没有运行，这时需要关闭权限再重新开启一次）\n\n例如：\n\n\n\n\nevents.observeToast()#\n\n开启 Toast 监听。\n\nToast 监听依赖于无障碍服务，因此此函数会确保无障碍服务运行。\n\n\n事件: 'toast'#\n\n * toast {Object}\n   * getText() 获取 Toast 的文本内容\n   * getPackageName() 获取发出 Toast 的应用包名\n\n当有应用发出 toast(气泡消息)时会触发该事件。但 Auto.js 软件本身的 toast 除外。\n\n例如，要记录发出所有 toast 的应用：\n\n\n\n\n事件: 'notification'#\n\n * notification Notification 通知对象\n\n当有应用发出通知时会触发该事件，参数为Notification。\n\n例如：\n\n\n\n\nNotification#\n\n通知对象，可以获取通知详情，包括通知标题、内容、发出通知的包名、时间等，也可以对通知进行操作，比如点击、删除。\n\n\nNotification.number#\n\n * {number}\n\n通知数量。例如 QQ 连续收到两条消息时 number 为 2。\n\n\nNotification.when#\n\n * {number}\n\n通知发出时间的时间戳，可以用于构造Date对象。例如：\n\n\n\n\nNotification.getPackageName()#\n\n * 返回 {string}\n\n获取发出通知的应用包名。\n\n\nNotification.getTitle()#\n\n * 返回 {string}\n\n获取通知的标题。\n\n\nNotification.getText()#\n\n * 返回 {string}\n\n获取通知的内容。\n\n\nNotification.click()#\n\n点击该通知。例如对于一条 QQ 消息，点击会进入具体的聊天界面。\n\n\nNotification.delete()#\n\n删除该通知。该通知将从通知栏中消失。\n\n\nKeyEvent#\n\n稳定性: 稳定\n\n\n\nKeyEvent.getAction()#\n\n返回事件的动作。包括：\n\n * KeyEvent.ACTION_DOWN 按下事件\n * KeyEvent.ACTION_UP 弹起事件\n\n\nKeyEvent.getKeyCode()#\n\n返回按键的键值。包括：\n\n * KeyEvent.KEYCODE_HOME 主页键\n * KeyEvent.KEYCODE_BACK 返回键\n * KeyEvent.KEYCODE_MENU 菜单键\n * KeyEvent.KEYCODE_VOLUME_UP 音量上键\n * KeyEvent.KEYCODE_VOLUME_DOWN 音量下键\n\n\nKeyEvent.getEventTime()#\n\n * 返回 {number}\n\n返回事件发生的时间戳。\n\n\nKeyEvent.getDownTime()#\n\n返回最近一次按下事件的时间戳。如果本身是按下事件，则与getEventTime()相同。\n\n\nKeyEvent.keyCodeToString(keyCode)#\n\n把键值转换为字符串。例如 KEYCODE_HOME 转换为\"KEYCODE_HOME\"。\n\n\nkeys#\n\n稳定性: 稳定\n\n\n按键事件中所有可用的按键名称为：\n\n * volume_up 音量上键\n * volume_down 音量下键\n * home 主屏幕键\n * back 返回键\n * menu 菜单键\n\n\nEventEmitter#\n\n稳定性: 稳定\n\n\n\nEventEmitter.defaultMaxListeners#\n\n每个事件默认可以注册最多 10 个监听器。 单个 EventEmitter 实例的限制可以使用 emitter.setMaxListeners(n) 方法改变。\n所有 EventEmitter 实例的默认值可以使用 EventEmitter.defaultMaxListeners 属性改变。\n\n设置 EventEmitter.defaultMaxListeners 要谨慎，因为会影响所有 EventEmitter 实例，包括之前创建的。 因而，调用\nemitter.setMaxListeners(n) 优先于 EventEmitter.defaultMaxListeners。\n\n注意，与 Node.js 不同，这是一个硬性限制。 EventEmitter 实例不允许添加更多的监听器，监听器超过最大数量时会抛出\nTooManyListenersException。\n\n\n\n\nEventEmitter.addListener(eventName, listener)#\n\n * eventName {any}\n * listener {Function}\n\nemitter.on(eventName, listener) 的别名。\n\n\nEventEmitter.emit(eventName[, ...args])#\n\n * eventName {any}\n * args {any}\n\n按监听器的注册顺序，同步地调用每个注册到名为 eventName 事件的监听器，并传入提供的参数。\n\n如果事件有监听器，则返回 true ，否则返回 false。\n\n\nEventEmitter.eventNames()#\n\n返回一个列出触发器已注册监听器的事件的数组。 数组中的值为字符串或符号。\n\n\n\n\nEventEmitter.getMaxListeners()#\n\n返回 EventEmitter 当前的最大监听器限制值，该值可以通过 emitter.setMaxListeners(n) 设置或默认为\nEventEmitter.defaultMaxListeners。\n\n\nEventEmitter.listenerCount(eventName)#\n\n * eventName {string} 正在被监听的事件名\n\n返回正在监听名为 eventName 的事件的监听器的数量。\n\n\nEventEmitter.listeners(eventName)#\n\n * eventName {string}\n\n返回名为 eventName 的事件的监听器数组的副本。\n\n\n\n\nEventEmitter.on(eventName, listener)#\n\n * eventName {any} 事件名\n * listener {Function} 回调函数\n\n添加 listener 函数到名为 eventName 的事件的监听器数组的末尾。 不会检查 listener 是否已被添加。 多次调用并传入相同的\neventName 和 listener 会导致 listener 被添加与调用多次。\n\n\n\n返回一个 EventEmitter 引用，可以链式调用。\n\n默认情况下，事件监听器会按照添加的顺序依次调用。 emitter.prependListener() 方法可用于将事件监听器添加到监听器数组的开头。\n\n\n\n\nEventEmitter.once(eventName, listener)#\n\n * eventName {any} 事件名\n * listener {Function} 回调函数\n\n添加一个单次 listener 函数到名为 eventName 的事件。 下次触发 eventName 事件时，监听器会被移除，然后调用。\n\n\n\n返回一个 EventEmitter 引用，可以链式调用。\n\n默认情况下，事件监听器会按照添加的顺序依次调用。 emitter.prependOnceListener() 方法可用于将事件监听器添加到监听器数组的开头。\n\n\n\n\nEventEmitter.prependListener(eventName, listener)#\n\n * eventName {any} 事件名\n * listener {Function} 回调函数\n\n添加 listener 函数到名为 eventName 的事件的监听器数组的开头。 不会检查 listener 是否已被添加。 多次调用并传入相同的\neventName 和 listener 会导致 listener 被添加与调用多次。\n\n\n\n返回一个 EventEmitter 引用，可以链式调用。\n\n\nEventEmitter.prependOnceListener(eventName, listener)#\n\n * eventName {any} 事件名\n * listener {Function} 回调函数\n\n添加一个单次 listener 函数到名为 eventName 的事件的监听器数组的开头。 下次触发 eventName 事件时，监听器会被移除，然后调用。\n\n\n\n返回一个 EventEmitter 引用，可以链式调用。\n\n\nEventEmitter.removeAllListeners([eventName])#\n\n * eventName {any}\n\n移除全部或指定 eventName 的监听器。\n\n注意，在代码中移除其他地方添加的监听器是一个不好的做法，尤其是当 EventEmitter 实例是其他组件或模块创建的。\n\n返回一个 EventEmitter 引用，可以链式调用。\n\n\nEventEmitter.removeListener(eventName, listener)#\n\n * eventName {any}\n * listener {Function}\n\n从名为 eventName 的事件的监听器数组中移除指定的 listener。\n\n\n\nremoveListener 最多只会从监听器数组里移除一个监听器实例。 如果任何单一的监听器被多次添加到指定 eventName\n的监听器数组中，则必须多次调用 removeListener 才能移除每个实例。\n\n注意，一旦一个事件被触发，所有绑定到它的监听器都会按顺序依次触发。 这意味着，在事件触发后、最后一个监听器完成执行前，任何 removeListener() 或\nremoveAllListeners() 调用都不会从 emit() 中移除它们。 随后的事件会像预期的那样发生。\n\n\n\n因为监听器是使用内部数组进行管理的，所以调用它会改变在监听器被移除后注册的任何监听器的位置索引。 虽然这不会影响监听器的调用顺序，但意味着由\nemitter.listeners() 方法返回的监听器数组副本需要被重新创建。\n\n返回一个 EventEmitter 引用，可以链式调用。\n\n\nEventEmitter.setMaxListeners(n)#\n\n * n {number}\n\n默认情况下，如果为特定事件添加了超过 10 个监听器，则 EventEmitter 会打印一个警告。 此限制有助于寻找内存泄露。\n但是，并不是所有的事件都要被限为 10 个。 emitter.setMaxListeners() 方法允许修改指定的 EventEmitter 实例的限制。\n值设为 Infinity（或 0）表明不限制监听器的数量。\n\n返回一个 EventEmitter 引用，可以链式调用。\n\n\nevents.broadcast#\n\n脚本间广播\n\n脚本间通信除了使用 engines 模块提供的ScriptEngine.emit()方法以外，也可以使用 events 模块提供的 broadcast 广播。\n\nevents.broadcast 本身是一个\nEventEmitter，但它的事件是在脚本间共享的，所有脚本都能发送和监听这些事件；事件处理会在脚本主线程执行（后续可能加入函数onThisThread(ev\nentName, ...args)来提供在其他线程执行的能力）。\n\n例如在一个脚本发送一个广播 hello:\n\n\n\n在其他脚本中监听并处理：\n\n","routePath":"/v1/高级/events","lang":"","toc":[{"text":"events.emitter()","id":"eventsemitter","depth":2,"charIndex":231},{"text":"events.observeKey()","id":"eventsobservekey","depth":2,"charIndex":297},{"text":"events.onKeyDown(keyName, listener)","id":"eventsonkeydownkeyname-listener","depth":2,"charIndex":442},{"text":"events.onKeyUp(keyName, listener)","id":"eventsonkeyupkeyname-listener","depth":2,"charIndex":615},{"text":"events.onceKeyDown(keyName, listener)","id":"eventsoncekeydownkeyname-listener","depth":2,"charIndex":848},{"text":"events.onceKeyUp(keyName, listener)","id":"eventsoncekeyupkeyname-listener","depth":2,"charIndex":1062},{"text":"events.removeAllKeyDownListeners(keyName)","id":"eventsremoveallkeydownlistenerskeyname","depth":2,"charIndex":1271},{"text":"events.removeAllKeyUpListeners(keyName)","id":"eventsremoveallkeyuplistenerskeyname","depth":2,"charIndex":1370},{"text":"events.setKeyInterceptionEnabled([key, ]enabled)","id":"eventssetkeyinterceptionenabledkey-enabled","depth":2,"charIndex":1465},{"text":"events.observeTouch()","id":"eventsobservetouch","depth":2,"charIndex":1838},{"text":"events.setTouchEventTimeout(timeout)","id":"eventssettoucheventtimeouttimeout","depth":2,"charIndex":1939},{"text":"events.getTouchEventTimeout()","id":"eventsgettoucheventtimeout","depth":2,"charIndex":2241},{"text":"events.onTouch(listener)","id":"eventsontouchlistener","depth":2,"charIndex":2290},{"text":"events.removeAllTouchListeners()","id":"eventsremovealltouchlisteners","depth":2,"charIndex":2399},{"text":"事件: 'key'","id":"事件-key","depth":2,"charIndex":2448},{"text":"事件: 'key_down'","id":"事件-key_down","depth":2,"charIndex":2663},{"text":"事件: 'key_up'","id":"事件-key_up","depth":2,"charIndex":2747},{"text":"事件: 'exit`","id":"事件-exit","depth":2,"charIndex":2828},{"text":"events.observeNotification()","id":"eventsobservenotification","depth":2,"charIndex":3055},{"text":"events.observeToast()","id":"eventsobservetoast","depth":2,"charIndex":3205},{"text":"事件: 'toast'","id":"事件-toast","depth":2,"charIndex":3279},{"text":"事件: 'notification'","id":"事件-notification","depth":2,"charIndex":3460},{"text":"Notification.number","id":"notificationnumber","depth":2,"charIndex":3631},{"text":"Notification.when","id":"notificationwhen","depth":2,"charIndex":3701},{"text":"Notification.getPackageName()","id":"notificationgetpackagename","depth":2,"charIndex":3766},{"text":"Notification.getTitle()","id":"notificationgettitle","depth":2,"charIndex":3829},{"text":"Notification.getText()","id":"notificationgettext","depth":2,"charIndex":3882},{"text":"Notification.click()","id":"notificationclick","depth":2,"charIndex":3934},{"text":"Notification.delete()","id":"notificationdelete","depth":2,"charIndex":3992},{"text":"KeyEvent.getAction()","id":"keyeventgetaction","depth":2,"charIndex":4059},{"text":"KeyEvent.getKeyCode()","id":"keyeventgetkeycode","depth":2,"charIndex":4153},{"text":"KeyEvent.getEventTime()","id":"keyeventgeteventtime","depth":2,"charIndex":4351},{"text":"KeyEvent.getDownTime()","id":"keyeventgetdowntime","depth":2,"charIndex":4407},{"text":"KeyEvent.keyCodeToString(keyCode)","id":"keyeventkeycodetostringkeycode","depth":2,"charIndex":4479},{"text":"EventEmitter.defaultMaxListeners","id":"eventemitterdefaultmaxlisteners","depth":2,"charIndex":4700},{"text":"EventEmitter.addListener(eventName, listener)","id":"eventemitteraddlistenereventname-listener","depth":2,"charIndex":5126},{"text":"EventEmitter.emit(eventName[, ...args])","id":"eventemitteremiteventname-args","depth":2,"charIndex":5256},{"text":"EventEmitter.eventNames()","id":"eventemittereventnames","depth":2,"charIndex":5416},{"text":"EventEmitter.getMaxListeners()","id":"eventemittergetmaxlisteners","depth":2,"charIndex":5485},{"text":"EventEmitter.listenerCount(eventName)","id":"eventemitterlistenercounteventname","depth":2,"charIndex":5623},{"text":"EventEmitter.listeners(eventName)","id":"eventemitterlistenerseventname","depth":2,"charIndex":5729},{"text":"EventEmitter.on(eventName, listener)","id":"eventemitteroneventname-listener","depth":2,"charIndex":5821},{"text":"EventEmitter.once(eventName, listener)","id":"eventemitteronceeventname-listener","depth":2,"charIndex":6143},{"text":"EventEmitter.prependListener(eventName, listener)","id":"eventemitterprependlistenereventname-listener","depth":2,"charIndex":6422},{"text":"EventEmitter.prependOnceListener(eventName, listener)","id":"eventemitterprependoncelistenereventname-listener","depth":2,"charIndex":6679},{"text":"EventEmitter.removeAllListeners([eventName])","id":"eventemitterremovealllistenerseventname","depth":2,"charIndex":6900},{"text":"EventEmitter.removeListener(eventName, listener)","id":"eventemitterremovelistenereventname-listener","depth":2,"charIndex":7085},{"text":"EventEmitter.setMaxListeners(n)","id":"eventemittersetmaxlistenersn","depth":2,"charIndex":7616}],"domain":"","frontmatter":{},"version":""},{"id":80,"title":"Floaty","content":"#\n\nfloaty 模块提供了悬浮窗的相关函数，可以在屏幕上显示自定义悬浮窗，控制悬浮窗大小、位置等。\n\n悬浮窗在脚本停止运行时会自动关闭，因此，要保持悬浮窗不被关闭，可以用一个空的 setInterval 来实现，例如：\n\n\n\n\nFloaty#\n\n\nfloaty.checkPermission()#\n\n[4.2.17 新增]\n\n * 返回 {boolean}\n\n返回当前应用是否有悬浮窗权限。（不会触发请求权限操作）\n\n\nfloaty.requestPermission()#\n\n[4.2.17 新增]\n\n跳转到系统的悬浮窗权限请求界面。\n\n\n\n\nfloaty.window(layout)#\n\n * layout {xml} | {View} 悬浮窗界面的 XML 或者 View\n\n指定悬浮窗的布局，创建并显示一个悬浮窗，返回一个FloatyWindow对象。\n\n该悬浮窗自带关闭、调整大小、调整位置按键，可根据需要调用setAdjustEnabled()函数来显示或隐藏。\n\n其中 layout 参数可以是 xml 布局或者一个 View，更多信息参见 ui 模块的说明。\n\n例子：\n\n\n\n这段代码运行后将会在屏幕上显示悬浮文字，并在两秒后消失。\n\n另外，因为脚本运行的线程不是 UI 线程，而所有对控件的修改操作需要在 UI 线程执行，此时需要用ui.run，例如:\n\n\n\n有关返回的FloatyWindow对象的说明，参见下面的FloatyWindow章节。\n\n\nfloaty.rawWindow(layout)#\n\n * layout {xml} | {View} 悬浮窗界面的 XML 或者 View\n\n指定悬浮窗的布局，创建并显示一个原始悬浮窗，返回一个FloatyRawWindow对象。\n\n与floaty.window()函数不同的是，该悬浮窗不会增加任何额外设施（例如调整大小、位置按钮），您可以根据自己需要编写任何布局。\n\n而且，该悬浮窗支持完全全屏，可以覆盖状态栏，因此可以做护眼模式之类的应用。\n\n\n\n这段代码运行后将会在屏幕上显示悬浮文字，并在两秒后消失。\n\n有关返回的FloatyRawWindow对象的说明，参见下面的FloatyRawWindow章节。\n\n\nfloaty.closeAll()#\n\n关闭所有本脚本的悬浮窗。","routePath":"/v1/高级/floaty/floaty","lang":"","toc":[{"text":"floaty.checkPermission()","id":"floatycheckpermission","depth":2,"charIndex":125},{"text":"floaty.requestPermission()","id":"floatyrequestpermission","depth":2,"charIndex":212},{"text":"floaty.window(layout)","id":"floatywindowlayout","depth":2,"charIndex":275},{"text":"floaty.rawWindow(layout)","id":"floatyrawwindowlayout","depth":2,"charIndex":638},{"text":"floaty.closeAll()","id":"floatycloseall","depth":2,"charIndex":948}],"domain":"","frontmatter":{},"version":""},{"id":81,"title":"FloatyRawWindow","content":"#\n\n原始悬浮窗对象，可通过window.{id}获取悬浮窗界面上的元素。例如, 悬浮窗 window 上一个控件的 id 为 aaa,\n那么window.aaa即可获取到该控件，类似于 ui。\n\n\nwindow.setTouchable(touchable)#\n\n * touchable {Boolean} 是否可触摸\n\n设置悬浮窗是否可触摸，如果为 true, 则悬浮窗将接收到触摸、点击等事件并且无法继续传递到悬浮窗下面；如果为 false,\n悬浮窗上的触摸、点击等事件将被直接传递到悬浮窗下面。处于安全考虑，被悬浮窗接收的触摸事情无法再继续传递到下层。\n\n可以用此特性来制作护眼模式脚本。\n\n\n\n\nwindow.setPosition(x, y)#\n\n * x {number} x\n * x {number} y\n\n设置悬浮窗位置。\n\n\nwindow.getX()#\n\n返回悬浮窗位置的 X 坐标。\n\n\nwindow.getY()#\n\n返回悬浮窗位置的 Y 坐标。\n\n\nwindow.setSize(width, height)#\n\n * width {number} 宽度\n * height {number} 高度\n\n设置悬浮窗宽高。\n\n特别地，如果设置为-1，则为占满全屏；设置为-2 则为根据悬浮窗内容大小而定。例如：\n\n\n\n\nwindow.getWidht()#\n\n返回悬浮窗宽度。\n\n\nwindow.getHeight()#\n\n返回悬浮窗高度。\n\n\nwindow.close()#\n\n关闭悬浮窗。如果悬浮窗已经是关闭状态，则此函数将不执行任何操作。\n\n被关闭后的悬浮窗不能再显示。\n\n\nwindow.exitOnClose()#\n\n使悬浮窗被关闭时自动结束脚本运行。","routePath":"/v1/高级/floaty/floatyRawWindow","lang":"","toc":[{"text":"window.setTouchable(touchable)","id":"windowsettouchabletouchable","depth":2,"charIndex":99},{"text":"window.setPosition(x, y)","id":"windowsetpositionx-y","depth":2,"charIndex":303},{"text":"window.getX()","id":"windowgetx","depth":2,"charIndex":374},{"text":"window.getY()","id":"windowgety","depth":2,"charIndex":407},{"text":"window.setSize(width, height)","id":"windowsetsizewidth-height","depth":2,"charIndex":440},{"text":"window.getWidht()","id":"windowgetwidht","depth":2,"charIndex":573},{"text":"window.getHeight()","id":"windowgetheight","depth":2,"charIndex":604},{"text":"window.close()","id":"windowclose","depth":2,"charIndex":636},{"text":"window.exitOnClose()","id":"windowexitonclose","depth":2,"charIndex":704}],"domain":"","frontmatter":{},"version":""},{"id":82,"title":"FloatyWindow","content":"#\n\n悬浮窗对象，可通过FloatyWindow.{id}获取悬浮窗界面上的元素。例如, 悬浮窗 window 上一个控件的 id 为 aaa,\n那么window.aaa即可获取到该控件，类似于 ui。\n\n\nwindow.setAdjustEnabled(enabled)#\n\n * enabled {boolean} 是否启用悬浮窗调整(大小、位置)\n\n如果 enabled 为 true，则在悬浮窗左上角、右上角显示可供位置、大小调整的标示，就像控制台一样； 如果 enabled 为\nfalse，则隐藏上述标示。\n\n\nwindow.setPosition(x, y)#\n\n * x {number} x\n * x {number} y\n\n设置悬浮窗位置。\n\n\nwindow.getX()#\n\n返回悬浮窗位置的 X 坐标。\n\n\nwindow.getY()#\n\n返回悬浮窗位置的 Y 坐标。\n\n\nwindow.setSize(width, height)#\n\n * width {number} 宽度\n * height {number} 高度\n\n设置悬浮窗宽高。\n\n\nwindow.getWidht()#\n\n返回悬浮窗宽度。\n\n\nwindow.getHeight()#\n\n返回悬浮窗高度。\n\n\nwindow.close()#\n\n关闭悬浮窗。如果悬浮窗已经是关闭状态，则此函数将不执行任何操作。\n\n被关闭后的悬浮窗不能再显示。\n\n\nwindow.exitOnClose()#\n\n使悬浮窗被关闭时自动结束脚本运行。","routePath":"/v1/高级/floaty/floatyWindow","lang":"","toc":[{"text":"window.setAdjustEnabled(enabled)","id":"windowsetadjustenabledenabled","depth":2,"charIndex":103},{"text":"window.setPosition(x, y)","id":"windowsetpositionx-y","depth":2,"charIndex":261},{"text":"window.getX()","id":"windowgetx","depth":2,"charIndex":332},{"text":"window.getY()","id":"windowgety","depth":2,"charIndex":365},{"text":"window.setSize(width, height)","id":"windowsetsizewidth-height","depth":2,"charIndex":398},{"text":"window.getWidht()","id":"windowgetwidht","depth":2,"charIndex":485},{"text":"window.getHeight()","id":"windowgetheight","depth":2,"charIndex":516},{"text":"window.close()","id":"windowclose","depth":2,"charIndex":548},{"text":"window.exitOnClose()","id":"windowexitonclose","depth":2,"charIndex":616}],"domain":"","frontmatter":{},"version":""},{"id":83,"title":"colors","content":"#\n\n:::\n\n:::tip 稳定性: 稳定\n\n::: 在 Auto.js 有两种方式表示一个颜色。\n\n一种是使用一个字符串\"#AARRGGBB\"或\"#RRGGBB\"，其中 AA 是 Alpha 通道(透明度)的值，RR 是 R 通道(红色)的值，GG 是 G\n通道(绿色)的值，BB 是 B 通道(蓝色)的值。例如\"#ffffff\"表示白色, \"#7F000000\"表示半透明的黑色。\n\n另一种是使用一个 16 进制的\"32 位整数\" 0xAARRGGBB 来表示一个颜色，例如 0xFF112233表示颜色\"#112233\",\n0x11223344表示颜色\"#11223344\"。\n\n可以通过colors.toString()把颜色整数转换为字符串，通过colors.parseColor()把颜色字符串解析为颜色整数。\n\n\ncolors#\n\n\ncolors.toString(color)#\n\n * color {number} 整数 RGB 颜色值\n * 返回 {string}\n\n返回颜色值的字符串，格式为 \"#AARRGGBB\"。\n\n\ncolors.red(color)#\n\n * color {number} | {string} 颜色值\n * 返回 {number}\n\n返回颜色 color 的 R 通道的值，范围 0~255.\n\n\ncolors.green(color)#\n\n * color {number} | {string} 颜色值\n * 返回 {number}\n\n返回颜色 color 的 G 通道的值，范围 0~255.\n\n\ncolors.blue(color)#\n\n * color {number} | {string} 颜色值\n * 返回 {number}\n\n返回颜色 color 的 B 通道的值，范围 0~255.\n\n\ncolors.alpha(color)#\n\n * color {number} | {string} 颜色值\n * 返回 {number}\n\n返回颜色 color 的 Alpha 通道的值，范围 0~255.\n\n\ncolors.rgb(red, green, blue)#\n\n * red {number} 颜色的 R 通道的值\n * blue {number} 颜色的 G 通道的值\n * green {number} 颜色的 B 通道的值\n * 返回 {number}\n\n返回这些颜色通道构成的整数颜色值。Alpha 通道将是 255（不透明）。\n\n\ncolors.argb(alpha, red, green, blue)#\n\n * alpha {number} 颜色的 Alpha 通道的值\n * red {number} 颜色的 R 通道的值\n * green {number} 颜色的 G 通道的值\n * blue {number} 颜色的 B 通道的值\n * 返回 {number}\n\n返回这些颜色通道构成的整数颜色值。\n\n\ncolors.parseColor(colorStr)#\n\n * colorStr {string} 表示颜色的字符串，例如\"#112233\"\n * 返回 {number}\n\n返回颜色的整数值。\n\n\ncolors.isSimilar(color2, color2[, threshold, algorithm])#\n\n * color1 {number} | {string} 颜色值 1\n * color1 {number} | {string} 颜色值 2\n * threshold {number} 颜色相似度临界值，默认为 4。取值范围为 0~255。这个值越大表示允许的相似程度越小，如果这个值为\n   0，则两个颜色相等时该函数才会返回 true。\n * algorithm {string} 颜色匹配算法，默认为\"diff\", 包括:\n   * \"diff\": 差值匹配。与给定颜色的 R、G、B 差的绝对值之和小于 threshold 时匹配。\n   * \"rgb\": rgb 欧拉距离相似度。与给定颜色 color 的 rgb 欧拉距离小于等于 threshold 时匹配。\n   * \"rgb+\": 加权 rgb 欧拉距离匹配(LAB Delta E)。\n   * \"hs\": hs 欧拉距离匹配。hs 为 HSV 空间的色调值。\n * 返回 {Boolean}\n\n返回两个颜色是否相似。\n\n\ncolors.equals(color1, color2)#\n\n * color1 {number} | {string} 颜色值 1\n * color1 {number} | {string} 颜色值 2\n * 返回 {Boolean}\n\n返回两个颜色是否相等。*注意该函数会忽略 Alpha 通道的值进行比较。\n\n\n\n\ncolors.BLACK#\n\n黑色，颜色值 #FF000000\n\n\ncolors.DKGRAY#\n\n深灰色，颜色值 #FF444444\n\n\ncolors.GRAY#\n\n灰色，颜色值 #FF888888\n\n\ncolors.LTGRAY#\n\n亮灰色，颜色值 #FFCCCCCC\n\n\ncolors.WHITE#\n\n白色，颜色值 #FFFFFFFF\n\n\ncolors.RED#\n\n红色，颜色值 #FFFF0000\n\n\ncolors.GREEN#\n\n绿色，颜色值 #FF00FF00\n\n\ncolors.BLUE#\n\n蓝色，颜色值 #FF0000FF\n\n\ncolors.YELLOW#\n\n黄色，颜色值 #FFFFFF00\n\n\ncolors.CYAN#\n\n青色，颜色值 #FF00FFFF\n\n\ncolors.MAGENTA#\n\n品红色，颜色值 #FFFF00FF\n\n\ncolors.TRANSPARENT#\n\n透明，颜色值 #00000000","routePath":"/v1/高级/images/colors","lang":"","toc":[{"text":"colors.toString(color)","id":"colorstostringcolor","depth":2,"charIndex":374},{"text":"colors.red(color)","id":"colorsredcolor","depth":2,"charIndex":473},{"text":"colors.green(color)","id":"colorsgreencolor","depth":2,"charIndex":574},{"text":"colors.blue(color)","id":"colorsbluecolor","depth":2,"charIndex":677},{"text":"colors.alpha(color)","id":"colorsalphacolor","depth":2,"charIndex":779},{"text":"colors.rgb(red, green, blue)","id":"colorsrgbred-green-blue","depth":2,"charIndex":886},{"text":"colors.argb(alpha, red, green, blue)","id":"colorsargbalpha-red-green-blue","depth":2,"charIndex":1057},{"text":"colors.parseColor(colorStr)","id":"colorsparsecolorcolorstr","depth":2,"charIndex":1249},{"text":"colors.isSimilar(color2, color2[, threshold, algorithm])","id":"colorsissimilarcolor2-color2-threshold-algorithm","depth":2,"charIndex":1349},{"text":"colors.equals(color1, color2)","id":"colorsequalscolor1-color2","depth":2,"charIndex":1856},{"text":"colors.BLACK","id":"colorsblack","depth":2,"charIndex":2018},{"text":"colors.DKGRAY","id":"colorsdkgray","depth":2,"charIndex":2052},{"text":"colors.GRAY","id":"colorsgray","depth":2,"charIndex":2088},{"text":"colors.LTGRAY","id":"colorsltgray","depth":2,"charIndex":2121},{"text":"colors.WHITE","id":"colorswhite","depth":2,"charIndex":2157},{"text":"colors.RED","id":"colorsred","depth":2,"charIndex":2191},{"text":"colors.GREEN","id":"colorsgreen","depth":2,"charIndex":2223},{"text":"colors.BLUE","id":"colorsblue","depth":2,"charIndex":2257},{"text":"colors.YELLOW","id":"colorsyellow","depth":2,"charIndex":2290},{"text":"colors.CYAN","id":"colorscyan","depth":2,"charIndex":2325},{"text":"colors.MAGENTA","id":"colorsmagenta","depth":2,"charIndex":2358},{"text":"colors.TRANSPARENT","id":"colorstransparent","depth":2,"charIndex":2395}],"domain":"","frontmatter":{},"version":""},{"id":84,"title":"找图找色","content":"#\n\n\nimages.requestScreenCapture([landscape])#\n\n * landscape {boolean} 截屏方向\n   * true 横屏截图\n   * false 竖屏截图\n   * 不指定值，由当前设备屏幕方向决定截图方向\n * return {boolean}\n\n向系统申请屏幕截图权限，返回是否请求成功,仅需执行一次\n\n建议在本软件界面运行该函数，在其他软件界面运行时容易出现一闪而过的黑屏现象。\n\n示例:\n\n\n\n\n\n该函数也可以作为全局函数使用。\n\n\nimages.captureScreen()#\n\n * return {Image}\n\n截取当前屏幕并返回一个 Image 对象。\n\n没有截图权限时执行该函数会抛出 SecurityException。\n\n该函数不会返回 null，两次调用可能返回相同的 Image 对象。这是因为设备截图的更新需要一定的时间，短时间内（一般来说是\n16ms）连续调用则会返回同一张截图。\n\n截图需要转换为 Bitmap 格式，从而该函数执行需要一定的时间(0~20ms)。\n\n另外在 requestScreenCapture()执行成功后需要一定时间后才有截图可用，因此如果立即调用\ncaptureScreen()，会等待一定时间后(一般为几百 ms)才返回截图。\n\n例子:\n\n\n\n该函数也可以作为全局函数使用。\n\n\nimages.captureScreen(path)#\n\n * path {string} 截图保存路径\n\n截取当前屏幕并以 PNG 格式保存到 path 中。如果文件不存在会被创建；文件存在会被覆盖。\n\n该函数不会返回任何值。该函数也可以作为全局函数使用。\n\n\nimages.pixel(image, x, y)#\n\n * image {Image} 图片\n * x {number} 要获取的像素的横坐标。\n * y {number} 要获取的像素的纵坐标。\n\n返回图片 image 在点(x, y)处的像素的 ARGB 值。\n\n该值的格式为 0xAARRGGBB，是一个\"32 位整数\"(虽然 JavaScript 中并不区分整数类型和其他数值类型)。\n\n坐标系以图片左上角为原点。以图片左侧边为 y 轴，上侧边为 x 轴。\n\n\nimages.readPixels(path)#\n\n * path {string} 图片的地址\n * return {Object} 包括图片的像素数据和宽高，{data,width,height}\n\n读取图片的像素数据和宽高。\n\n\nimages.findColor(image, color, options)#\n\n * image {Image} 图片\n * color {number} | {string} 要寻找的颜色的 RGB 值。如果是一个整数，则以 0xRRGGBB 的形式代表 RGB 值（A\n   通道会被忽略）；如果是字符串，则以\"#RRGGBB\"代表其 RGB 值。\n * options {Object} 选项包括：\n   * region {Array} 找色区域。是一个两个或四个元素的数组。(region[0],\n     region[1])表示找色区域的左上角；region[2]*region[3]表示找色区域的宽高。如果只有 region\n     只有两个元素，则找色区域为(region[0], region[1])到屏幕右下角。如果不指定 region 选项，则找色区域为整张图片。\n   * threshold {number} 找色时颜色相似度的临界值，范围为 0~255（越小越相似，0 为颜色相等，255 为任何颜色都能匹配）。默认为\n     4。threshold 和浮点数相似度(0.0~1.0)的换算为 similarity = (255 - threshold) / 255.\n\n在图片中寻找颜色 color。找到时返回找到的点 Point，找不到时返回 null。\n\n该函数也可以作为全局函数使用。\n\n一个循环找色的例子如下：\n\n\n\n一个区域找色的例子如下：\n\n\n\n\nimages.findColorInRegion(img, color, x, y[, width, height, threshold])#\n\n区域找色的简便方法。\n\n相当于\n\n\n\n该函数也可以作为全局函数使用。\n\n\nimages.findColorEquals(img, color[, x, y, width, height])#\n\n * img {Image} 图片\n * color {number} | {string} 要寻找的颜色\n * x {number} 找色区域的左上角横坐标\n * y {number} 找色区域的左上角纵坐标\n * width {number} 找色区域的宽度\n * height {number} 找色区域的高度\n * 返回 {Point}\n\n在图片 img 指定区域中找到颜色和 color 完全相等的某个点，并返回该点的左边；如果没有找到，则返回null。\n\n找色区域通过x, y, width, height指定，如果不指定找色区域，则在整张图片中寻找。\n\n该函数也可以作为全局函数使用。\n\n示例： (通过找 QQ 红点的颜色来判断是否有未读消息)\n\n\n\n\nimages.findAllPointsForColor(img, color, options)#\n\n * img {Image} 图片\n * color {number | string} 要检测的颜色\n * options {Object} 选项包括：\n   * region {Array} 找色区域。是一个两个或四个元素的数组。(region[0],\n     region[1])表示找色区域的左上角；region[2]*region[3]表示找色区域的宽高。如果\n     region只有两个元素，则找色区域为(region[0], region[1])到图片右下角。如果不指定region选项，则找色区域为整张图片。\n   * similarity {number} 找色时颜色相似度，范围为 0~1（越大越相似，1 为颜色相等，0 为任何颜色都能匹配）。\n   * threshold {number} 找色时颜色相似度的临界值，范围为 0 ~ 255（越小越相似，0 为颜色相等，255\n     为任何颜色都能匹配）。默认为 4。\n   * similarity与threshold的换算为similarity = (255 - threshold) / 255\n     。二选一，同时存在则以similarity为准。\n * return {Array}\n\n在图片中寻找所有颜色为color的点。找到时返回找到的点 Point 的数组，找不到时返回null。\n\n例如找出所有白色的点：\n\n\n\n\nimages.findMultiColors(img, firstColor, colors[, options])#\n\n * img {Image} 要找色的图片\n * firstColor {number} | {string} 第一个点的颜色\n * colors {Array} 表示剩下的点相对于第一个点的位置和颜色的数组，数组的每个元素为[x, y, color]\n * options {Object} 选项，包括：\n   * region {Array} 找色区域。是一个两个或四个元素的数组。(region[0],\n     region[1])表示找色区域的左上角；region[2]*region[3]表示找色区域的宽高。如果只有 region\n     只有两个元素，则找色区域为(region[0], region[1])到屏幕右下角。如果不指定 region 选项，则找色区域为整张图片。\n   * threshold {number} 找色时颜色相似度的临界值，范围为 0~255（越小越相似，0 为颜色相等，255 为任何颜色都能匹配）。默认为\n     4。threshold 和浮点数相似度(0.0~1.0)的换算为 similarity = (255 - threshold) / 255.\n\n多点找色，类似于按键精灵的多点找色，其过程如下：\n\n 1. 在图片 img 中找到颜色 firstColor 的位置(x0, y0)\n 2. 对于数组 colors 的每个元素[x, y, color]，检查图片 img 在位置(x + x0, y + y0)上的像素是否是颜色\n    color，是的话返回(x0, y0)，否则继续寻找 firstColor 的位置，重新执行第 1 步\n 3. 整张图片都找不到时返回null\n\n例如，对于代码images.findMultiColors(img, \"#123456\", [[10, 20, \"#ffffff\"], [30, 40,\n\"#000000\"]])，假设图片在(100, 200)的位置的颜色为#123456, 这时如果(110, 220)的位置的颜色为#fffff 且(130,\n240)的位置的颜色为#000000，则函数返回点(100, 200)。\n\n如果要指定找色区域，则在 options 中指定，例如:\n\n\n\n\nimages.detectsColor(image, color, x, y[, threshold = 16, algorithm = \"diff\"])#\n\n * image {Image} 图片\n\n * color {number} | {string} 要检测的颜色\n\n * x {number} 要检测的位置横坐标\n\n * y {number} 要检测的位置纵坐标\n\n * threshold {number} 颜色相似度临界值，默认为 16。取值范围为 0~255。\n\n * algorithm {string} 颜色匹配算法，包括:\n   \n   * \"equal\": 相等匹配，只有与给定颜色 color 完全相等时才匹配。\n   \n   * \"diff\": 差值匹配。与给定颜色的 R、G、B 差的绝对值之和小于 threshold 时匹配。\n   \n   * \"rgb\": rgb 欧拉距离相似度。与给定颜色 color 的 rgb 欧拉距离小于等于 threshold 时匹配。\n   \n   * \"rgb+\": 加权 rgb 欧拉距离匹配(LAB Delta E)。\n   \n   * \"hs\": hs 欧拉距离匹配。hs 为 HSV 空间的色调值。\n\n返回图片 image 在位置(x, y)处是否匹配到颜色 color。用于检测图片中某个位置是否是特定颜色。\n\n一个判断微博客户端的某个微博是否被点赞过的例子：\n\n\n\n\nimages.findImage(img, template[, options])#\n\n * img {Image} 大图片\n * template {Image} 小图片（模板）\n * options {Object} 选项包括：\n   * threshold {number} 图片相似度。取值范围为 0~1 的浮点数。默认值为 0.9。\n   * region {Array} 找图区域。参见 findColor 函数关于 region 的说明。\n   * level {number} 一般而言不必修改此参数。不加此参数时该参数会根据图片大小自动调整。找图算法是采用图像金字塔进行的, level\n     参数表示金字塔的层次, level\n     越大可能带来越高的找图效率，但也可能造成找图失败（图片因过度缩小而无法分辨）或返回错误位置。因此，除非您清楚该参数的意义并需要进行性能调优，否则不需要\n     用到该参数。\n\n找图。在大图片 img 中查找小图片 template 的位置（模块匹配），找到时返回位置坐标(Point)，找不到时返回 null。\n\n该函数也可以作为全局函数使用。\n\n一个最简单的找图例子如下：\n\n\n\n稍微复杂点的区域找图例子如下：\n\n\n\n\nimages.findImageInRegion(img, template, x, y[, width, height, threshold])#\n\n区域找图的简便方法。相当于：\n\n\n\n该函数也可以作为全局函数使用。\n\n\nimages.matchTemplate(img, template, options)#\n\n[v4.1.0 新增]\n\n * img {Image} 大图片\n * template {Image} 小图片（模板）\n * options {Object} 找图选项：\n   * threshold {number} 图片相似度。取值范围为 0~1 的浮点数。默认值为 0.9。\n   * region {Array} 找图区域。参见 findColor 函数关于 region 的说明。\n   * max {number} 找图结果最大数量，默认为 5\n   * level {number} 一般而言不必修改此参数。不加此参数时该参数会根据图片大小自动调整。找图算法是采用图像金字塔进行的, level\n     参数表示金字塔的层次, level\n     越大可能带来越高的找图效率，但也可能造成找图失败（图片因过度缩小而无法分辨）或返回错误位置。因此，除非您清楚该参数的意义并需要进行性能调优，否则不需要\n     用到该参数。\n * 返回 {MatchingResult}\n\n在大图片中搜索小图片，并返回搜索结果 MatchingResult。该函数可以用于找图时找出多个位置，可以通过 max\n参数控制最大的结果数量。也可以对匹配结果进行排序、求最值等操作。\n\n\nimages.findCircles(gray, options)#\n\n * gray {Image} 灰度图片\n * options {Object} 选项包括：\n   * region {Array} 找圆区域。是一个两个或四个元素的数组。(region[0],\n     region[1])表示找圆区域的左上角；region[2]*region[3]表示找圆区域的宽高。如果只有 region\n     只有两个元素，则找圆区域为(region[0], region[1])到图片右下角。如果不指定region选项，则找圆区域为整张图片。\n   * dp {number} dp 是累加面与原始图像相比的分辨率的反比参数，dp=2 时累计面分辨率是元素图像的一半，宽高都缩减为原来的一半，dp=1\n     时，两者相同。默认为 1。\n   * minDst {number} minDist 定义了两个圆心之间的最小距离。默认为图片高度的八分之一。\n   * param1 {number} param1 是 Canny 边缘检测的高阈值，低阈值被自动置为高阈值的一半。默认为 100，范围为 0-255。\n   * param2 {number} param2 是累加平面对是否是圆的判定阈值，默认为 100。\n   * minRadius {number} 定义了检测到的圆的半径的最小值，默认为 0。\n   * maxRadius {number} 定义了检测到的圆的半径的最大值，0 为不限制最大值，默认为 0。\n * return {Array}\n\n在图片中寻找圆（做霍夫圆变换）。找到时返回找到的所有圆{x,y,radius}的数组，找不到时返回 null。\n\n一个寻找圆的例子：\n\n","routePath":"/v1/高级/images/findColorOrImage","lang":"","toc":[{"text":"images.requestScreenCapture([landscape])","id":"imagesrequestscreencapturelandscape","depth":2,"charIndex":3},{"text":"images.captureScreen()","id":"imagescapturescreen","depth":2,"charIndex":248},{"text":"images.captureScreen(path)","id":"imagescapturescreenpath","depth":2,"charIndex":600},{"text":"images.pixel(image, x, y)","id":"imagespixelimage-x-y","depth":2,"charIndex":732},{"text":"images.readPixels(path)","id":"imagesreadpixelspath","depth":2,"charIndex":968},{"text":"images.findColor(image, color, options)","id":"imagesfindcolorimage-color-options","depth":2,"charIndex":1086},{"text":"images.findColorInRegion(img, color, x, y[, width, height, threshold])","id":"imagesfindcolorinregionimg-color-x-y-width-height-threshold","depth":2,"charIndex":1736},{"text":"images.findColorEquals(img, color[, x, y, width, height])","id":"imagesfindcolorequalsimg-color-x-y-width-height","depth":2,"charIndex":1846},{"text":"images.findAllPointsForColor(img, color, options)","id":"imagesfindallpointsforcolorimg-color-options","depth":2,"charIndex":2240},{"text":"images.findMultiColors(img, firstColor, colors[, options])","id":"imagesfindmulticolorsimg-firstcolor-colors-options","depth":2,"charIndex":2901},{"text":"images.detectsColor(image, color, x, y[, threshold = 16, algorithm = \"diff\"])","id":"imagesdetectscolorimage-color-x-y-threshold--16-algorithm--diff","depth":2,"charIndex":3910},{"text":"images.findImage(img, template[, options])","id":"imagesfindimageimg-template-options","depth":2,"charIndex":4533},{"text":"images.findImageInRegion(img, template, x, y[, width, height, threshold])","id":"imagesfindimageinregionimg-template-x-y-width-height-threshold","depth":2,"charIndex":5077},{"text":"images.matchTemplate(img, template, options)","id":"imagesmatchtemplateimg-template-options","depth":2,"charIndex":5189},{"text":"images.findCircles(gray, options)","id":"imagesfindcirclesgray-options","depth":2,"charIndex":5776}],"domain":"","frontmatter":{},"version":""},{"id":85,"title":"Image","content":"#\n\n表示一张图片，可以是截图的图片，或者本地读取的图片，或者从网络获取的图片。\n\n\nImage.getWidth()#\n\n返回以像素为单位图片宽度。\n\n\nImage.getHeight()#\n\n返回以像素为单位的图片高度。\n\n\nImage.saveTo(path)#\n\n * path {string} 路径\n\n把图片保存到路径 path。（如果文件存在则覆盖）\n\n\nImage.pixel(x, y)#\n\n * x {number} 横坐标\n * y {number} 纵坐标\n\n返回图片 image 在点(x, y)处的像素的 ARGB 值。\n\n该值的格式为 0xAARRGGBB，是一个\"32 位整数\"(虽然 JavaScript 中并不区分整数类型和其他数值类型)。\n\n坐标系以图片左上角为原点。以图片左侧边为 y 轴，上侧边为 x 轴。","routePath":"/v1/高级/images/image","lang":"","toc":[{"text":"Image.getWidth()","id":"imagegetwidth","depth":2,"charIndex":42},{"text":"Image.getHeight()","id":"imagegetheight","depth":2,"charIndex":77},{"text":"Image.saveTo(path)","id":"imagesavetopath","depth":2,"charIndex":114},{"text":"Image.pixel(x, y)","id":"imagepixelx-y","depth":2,"charIndex":184}],"domain":"","frontmatter":{},"version":""},{"id":86,"title":"Images","content":"#\n\n稳定性: 稳定\n\n\nimages 模块提供了一些手机设备中常见的图片处理函数，包括截图、读写图片、图片剪裁、旋转、二值化、找色找图等。\n\n该模块分为两个部分，找图找色部分和图片处理部分。\n\n需要注意的是，image 对象创建后尽量在不使用时进行回收，同时避免循环创建大量图片。因为图片是一种占用内存比较大的资源，尽管 Auto.js\n通过各种方式（比如图片缓存机制、垃圾回收时回收图片、脚本结束时回收所有图片）尽量降低图片资源的泄漏和内存占用，但是糟糕的代码仍然可以占用大量内存。\n\nImage 对象通过调用recycle()函数来回收。例如：\n\n\n\n例外的是，caputerScreen()返回的图片不需要回收。\n\n\n图片处理#\n\n\nimages.read(path)#\n\n * path {string} 图片路径\n\n读取在路径 path 的图片文件并返回一个 Image 对象。如果文件不存在或者文件无法解码则返回 null。\n\n\nimages.load(url)#\n\n * url {string} 图片 URL 地址\n\n加载在地址 URL 的网络图片并返回一个 Image 对象。如果地址不存在或者图片无法解码则返回 null。\n\n\nimages.copy(img)#\n\n * img {Image} 图片\n * 返回 {Image}\n\n复制一张图片并返回新的副本。该函数会完全复制 img 对象的数据。\n\n\nimages.save(image, path[, format = \"png\", quality = 100])#\n\n * image {Image} 图片\n * path {string} 路径\n * format {string} 图片格式，可选的值为:\n   * png\n   * jpeg/jpg\n   * webp\n * quality {number} 图片质量，为 0~100 的整数值\n\n把图片 image 以 PNG 格式保存到 path 中。如果文件不存在会被创建；文件存在会被覆盖。\n\n\n\n\nimages.fromBase64(base64)#\n\n * base64 {string} 图片的 Base64 数据\n * 返回 {Image}\n\n解码 Base64 数据并返回解码后的图片 Image 对象。如果 base64 无法解码则返回null。\n\n\nimages.toBase64(img[, format = \"png\", quality = 100])#\n\n * image {image} 图片\n * format {string} 图片格式，可选的值为:\n   * png\n   * jpeg/jpg\n   * webp\n * quality {number} 图片质量，为 0~100 的整数值\n * 返回 {string}\n\n把图片编码为 base64 数据并返回。\n\n\nimages.fromBytes(bytes)#\n\n * bytes {byte[]} 字节数组\n\n解码字节数组 bytes 并返回解码后的图片 Image 对象。如果 bytes 无法解码则返回null。\n\n\nimages.toBytes(img[, format = \"png\", quality = 100])#\n\n * image {image} 图片\n * format {string} 图片格式，可选的值为:\n   * png\n   * jpeg/jpg\n   * webp\n * quality {number} 图片质量，为 0~100 的整数值\n * 返回 {byte[]}\n\n把图片编码为字节数组并返回。\n\n\nimages.clip(img, x, y, w, h)#\n\n * img {Image} 图片\n * x {number} 剪切区域的左上角横坐标\n * y {number} 剪切区域的左上角纵坐标\n * w {number} 剪切区域的宽度\n * h {number} 剪切区域的高度\n * 返回 {Image}\n\n从图片 img 的位置(x, y)处剪切大小为 w * h 的区域，并返回该剪切区域的新图片。\n\n\n\n\nimages.resize(img, size[, interpolation])#\n\n[v4.1.0 新增]\n\n * img {Image} 图片\n\n * size {Array} 两个元素的数组[w, h]，分别表示宽度和高度；如果只有一个元素，则宽度和高度相等\n\n * interpolation {string} 插值方法，可选，默认为\"LINEAR\"（线性插值），可选的值有：\n   \n   * NEAREST 最近邻插值\n   * LINEAR 线性插值（默认）\n   * AREA 区域插值\n   * CUBIC 三次样条插值\n   * LANCZOS4 Lanczos 插值 参见InterpolationFlags\n\n * 返回 {Image}\n\n调整图片大小，并返回调整后的图片。例如把图片放缩为 200*300：images.resize(img, [200, 300])。\n\n参见Imgproc.resize。\n\n\nimages.scale(img, fx, fy[, interpolation])#\n\n[v4.1.0 新增]\n\n * img {Image} 图片\n\n * fx {number} 宽度放缩倍数\n\n * fy {number} 高度放缩倍数\n\n * interpolation {string} 插值方法，可选，默认为\"LINEAR\"（线性插值），可选的值有：\n   \n   * NEAREST 最近邻插值\n   * LINEAR 线性插值（默认）\n   * AREA 区域插值\n   * CUBIC 三次样条插值\n   * LANCZOS4 Lanczos 插值 参见InterpolationFlags\n\n * 返回 {Image}\n\n放缩图片，并返回放缩后的图片。例如把图片变成原来的一半：images.scale(img, 0.5, 0.5)。\n\n参见Imgproc.resize。\n\n\nimages.rotate(img, degress[, x, y])#\n\n[v4.1.0 新增]\n\n * img {Image} 图片\n * degress {number} 旋转角度。\n * x {number} 旋转中心 x 坐标，默认为图片中点\n * y {number} 旋转中心 y 坐标，默认为图片中点\n * 返回 {Image}\n\n将图片逆时针旋转 degress 度，返回旋转后的图片对象。\n\n例如逆时针旋转 90 度为images.rotate(img, 90)。\n\n\nimages.concat(img1, image2[, direction])#\n\n[v4.1.0 新增]\n\n * img1 {Image} 图片 1\n * img2 {Image} 图片 2\n * direction {string} 连接方向，默认为\"RIGHT\"，可选的值有：\n   * LEFT 将图片 2 接到图片 1 左边\n   * RIGHT 将图片 2 接到图片 1 右边\n   * TOP 将图片 2 接到图片 1 上边\n   * BOTTOM 将图片 2 接到图片 1 下边\n * 返回 {Image}\n\n连接两张图片，并返回连接后的图像。如果两张图片大小不一致，小的那张将适当居中。\n\n\nimages.grayscale(img)#\n\n[v4.1.0 新增]\n\n * img {Image} 图片\n * 返回 {Image}\n\n灰度化图片，并返回灰度化后的图片。\n\n\nimage.threshold(img, threshold, maxVal[, type])#\n\n[v4.1.0 新增]\n\n * img {Image} 图片\n * threshold {number} 阈值\n * maxVal {number} 最大值\n * type {string} 阈值化类型，默认为\"BINARY\"，参见ThresholdTypes, 可选的值:\n   * BINARY\n   * BINARY_INV\n   * TRUNC\n   * TOZERO\n   * TOZERO_INV\n   * OTSU\n   * TRIANGLE\n * 返回 {Image}\n\n将图片阈值化，并返回处理后的图像。可以用这个函数进行图片二值化。例如：images.threshold(img, 100, 255,\n\"BINARY\")，这个代码将图片中大于 100 的值全部变成 255，其余变成 0，从而达到二值化的效果。如果 img\n是一张灰度化图片，这个代码将会得到一张黑白图片。\n\n可以参考有关博客（比如threshold 函数的使用）或者 OpenCV 文档threshold。\n\n\nimages.adaptiveThreshold(img, maxValue, adaptiveMethod, thresholdType,\nblockSize, C)#\n\n[v4.1.0 新增]\n\n * img {Image} 图片\n * maxValue {number} 最大值\n * adaptiveMethod {string} 在一个邻域内计算阈值所采用的算法，可选的值有：\n   * MEAN_C 计算出领域的平均值再减去参数 C 的值\n   * GAUSSIAN_C 计算出领域的高斯均值再减去参数 C 的值\n * thresholdType {string} 阈值化类型，可选的值有：\n   * BINARY\n   * BINARY_INV\n * blockSize {number} 邻域块大小\n * C {number} 偏移值调整量\n * 返回 {Image}\n\n对图片进行自适应阈值化处理，并返回处理后的图像。\n\n可以参考有关博客（比如threshold 与 adaptiveThreshold）或者 OpenCV 文档adaptiveThreshold。\n\n\nimages.cvtColor(img, code[, dstCn])#\n\n[v4.1.0 新增]\n\n * img {Image} 图片\n * code {string} 颜色空间转换的类型，可选的值有一共有 205 个（参见ColorConversionCodes），这里只列出几个：\n   * BGR2GRAY BGR 转换为灰度\n   * BGR2HSV BGR 转换为 HSV\n   * ``\n * dstCn {number} 目标图像的颜色通道数量，如果不填写则根据其他参数自动决定。\n * 返回 {Image}\n\n对图像进行颜色空间转换，并返回转换后的图像。\n\n可以参考有关博客（比如颜色空间转换）或者 OpenCV 文档cvtColor。\n\n\nimages.inRange(img, lowerBound, upperBound)#\n\n[v4.1.0 新增]\n\n * img {Image} 图片\n * lowerBound {string} | {number} 颜色下界\n * upperBound {string} | {number} 颜色下界\n * 返回 {Image}\n\n将图片二值化，在 lowerBound~upperBound 范围以外的颜色都变成 0，在范围以内的颜色都变成 255。\n\n例如images.inRange(img, \"#000000\", \"#222222\")。\n\n\nimages.interval(img, color, interval)#\n\n[v4.1.0 新增]\n\n * img {Image} 图片\n * color {string} | {number} 颜色值\n * interval {number} 每个通道的范围间隔\n * 返回 {Image}\n\n将图片二值化，在 color-interval ~ color+interval 范围以外的颜色都变成 0，在范围以内的颜色都变成 255。这里对 color\n的加减是对每个通道而言的。\n\n例如images.interval(img, \"#888888\", 16)，每个通道的颜色值均为 0x88，加减 16 后的范围是[0x78,\n0x98]，因此这个代码将把#787878~#989898 的颜色变成#FFFFFF，而把这个范围以外的变成#000000。\n\n\nimages.blur(img, size[, anchor, type])#\n\n[v4.1.0 新增]\n\n * img {Image} 图片\n * size {Array} 定义滤波器的大小，如[3, 3]\n * anchor {Array} 指定锚点位置(被平滑点)，默认为图像中心\n * type {string} 推断边缘像素类型，默认为\"DEFAULT\"，可选的值有：\n   * CONSTANT iiiiii|abcdefgh|iiiiiii with some specified i\n   * REPLICATE aaaaaa|abcdefgh|hhhhhhh\n   * REFLECT fedcba|abcdefgh|hgfedcb\n   * WRAP cdefgh|abcdefgh|abcdefg\n   * REFLECT_101 gfedcb|abcdefgh|gfedcba\n   * TRANSPARENT uvwxyz|abcdefgh|ijklmno\n   * REFLECT101 same as BORDER_REFLECT_101\n   * DEFAULT same as BORDER_REFLECT_101\n   * ISOLATED do not look outside of ROI\n * 返回 {Image}\n\n对图像进行模糊（平滑处理），返回处理后的图像。\n\n可以参考有关博客（比如实现图像平滑处理）或者 OpenCV 文档blur。\n\n\nimages.medianBlur(img, size)#\n\n[v4.1.0 新增]\n\n * img {Image} 图片\n * size {Array} 定义滤波器的大小，如[3, 3]\n * 返回 {Image}\n\n对图像进行中值滤波，返回处理后的图像。\n\n可以参考有关博客（比如实现图像平滑处理）或者 OpenCV 文档blur。\n\n\nimages.gaussianBlur(img, size[, sigmaX, sigmaY, type])#\n\n[v4.1.0 新增]\n\n * img {Image} 图片\n * size {Array} 定义滤波器的大小，如[3, 3]\n * sigmaX {number} x 方向的标准方差，不填写则自动计算\n * sigmaY {number} y 方向的标准方差，不填写则自动计算\n * type {string} 推断边缘像素类型，默认为\"DEFAULT\"，参见images.blur\n * 返回 {Image}\n\n对图像进行高斯模糊，返回处理后的图像。\n\n可以参考有关博客（比如实现图像平滑处理）或者 OpenCV 文档GaussianBlur。\n\n\nimages.matToImage(mat)#\n\n[v4.1.0 新增]\n\n * mat {Mat} OpenCV 的 Mat 对象\n * 返回 {Image}\n\n把 Mat 对象转换为 Image 对象。","routePath":"/v1/高级/images/images","lang":"","toc":[{"text":"图片处理","id":"图片处理","depth":2,"charIndex":312},{"text":"images.read(path)","id":"imagesreadpath","depth":2,"charIndex":320},{"text":"images.load(url)","id":"imagesloadurl","depth":2,"charIndex":421},{"text":"images.copy(img)","id":"imagescopyimg","depth":2,"charIndex":524},{"text":"images.save(image, path[, format = \"png\", quality = 100])","id":"imagessaveimage-path-format--png-quality--100","depth":2,"charIndex":612},{"text":"images.fromBase64(base64)","id":"imagesfrombase64base64","depth":2,"charIndex":870},{"text":"images.toBase64(img[, format = \"png\", quality = 100])","id":"imagestobase64img-format--png-quality--100","depth":2,"charIndex":1002},{"text":"images.fromBytes(bytes)","id":"imagesfrombytesbytes","depth":2,"charIndex":1219},{"text":"images.toBytes(img[, format = \"png\", quality = 100])","id":"imagestobytesimg-format--png-quality--100","depth":2,"charIndex":1325},{"text":"images.clip(img, x, y, w, h)","id":"imagesclipimg-x-y-w-h","depth":2,"charIndex":1535},{"text":"images.resize(img, size[, interpolation])","id":"imagesresizeimg-size-interpolation","depth":2,"charIndex":1747},{"text":"images.scale(img, fx, fy[, interpolation])","id":"imagesscaleimg-fx-fy-interpolation","depth":2,"charIndex":2167},{"text":"images.rotate(img, degress[, x, y])","id":"imagesrotateimg-degress-x-y","depth":2,"charIndex":2566},{"text":"images.concat(img1, image2[, direction])","id":"imagesconcatimg1-image2-direction","depth":2,"charIndex":2811},{"text":"images.grayscale(img)","id":"imagesgrayscaleimg","depth":2,"charIndex":3117},{"text":"image.threshold(img, threshold, maxVal[, type])","id":"imagethresholdimg-threshold-maxval-type","depth":2,"charIndex":3207},{"text":"images.adaptiveThreshold(img, maxValue, adaptiveMethod, thresholdType, blockSize, C)","id":"imagesadaptivethresholdimg-maxvalue-adaptivemethod-thresholdtype-blocksize-c","depth":2,"charIndex":-1},{"text":"images.cvtColor(img, code[, dstCn])","id":"imagescvtcolorimg-code-dstcn","depth":2,"charIndex":4201},{"text":"images.inRange(img, lowerBound, upperBound)","id":"imagesinrangeimg-lowerbound-upperbound","depth":2,"charIndex":4531},{"text":"images.interval(img, color, interval)","id":"imagesintervalimg-color-interval","depth":2,"charIndex":4810},{"text":"images.blur(img, size[, anchor, type])","id":"imagesblurimg-size-anchor-type","depth":2,"charIndex":5192},{"text":"images.medianBlur(img, size)","id":"imagesmedianblurimg-size","depth":2,"charIndex":5838},{"text":"images.gaussianBlur(img, size[, sigmaX, sigmaY, type])","id":"imagesgaussianblurimg-size-sigmax-sigmay-type","depth":2,"charIndex":6009},{"text":"images.matToImage(mat)","id":"imagesmattoimagemat","depth":2,"charIndex":6343}],"domain":"","frontmatter":{},"version":""},{"id":87,"title":"MatchingResult","content":"#\n\n[v4.1.0 新增]\n\n\nmatches#\n\n * {Array} 匹配结果的数组。\n\n数组的元素是一个 Match 对象：\n\n * point {Point} 匹配位置\n * similarity {number} 相似度\n\n例如:\n\n\n\n\npoints#\n\n * {Array} 匹配位置的数组。\n\n\nfirst()#\n\n * 返回 {Match}\n\n第一个匹配结果。如果没有任何匹配，则返回null。\n\n\nlast()#\n\n * 返回 {Match}\n\n最后一个匹配结果。如果没有任何匹配，则返回null。\n\n\nleftmost()#\n\n * 返回 {Match}\n\n位于大图片最左边的匹配结果。如果没有任何匹配，则返回null。\n\n\ntopmost()#\n\n * 返回 {Match}\n\n位于大图片最上边的匹配结果。如果没有任何匹配，则返回null。\n\n\nrightmost()#\n\n * 返回 {Match}\n\n位于大图片最右边的匹配结果。如果没有任何匹配，则返回null。\n\n\nbottommost()#\n\n * 返回 {Match}\n\n位于大图片最下边的匹配结果。如果没有任何匹配，则返回null。\n\n\nbest()#\n\n * 返回 {Match}\n\n相似度最高的匹配结果。如果没有任何匹配，则返回null。\n\n\nworst()#\n\n * 返回 {Match}\n\n相似度最低的匹配结果。如果没有任何匹配，则返回null。\n\n\nsortBy(cmp)#\n\n * cmp {Function}|{string}\n   比较函数，或者是一个字符串表示排序方向。例如\"left\"表示将匹配结果按匹配位置从左往右排序、\"top\"表示将匹配结果按匹配位置从上往下排序，\"left-\n   top\"表示将匹配结果按匹配位置从左往右、从上往下排序。方向包括left（左）, top （上）, right （右）, bottom（下）。\n * {MatchingResult}\n\n对匹配结果进行排序，并返回排序后的结果。\n\n","routePath":"/v1/高级/images/matchingResult","lang":"","toc":[{"text":"matches","id":"matches","depth":2,"charIndex":16},{"text":"points","id":"points","depth":2,"charIndex":125},{"text":"first()","id":"first","depth":2,"charIndex":156},{"text":"last()","id":"last","depth":2,"charIndex":209},{"text":"leftmost()","id":"leftmost","depth":2,"charIndex":262},{"text":"topmost()","id":"topmost","depth":2,"charIndex":324},{"text":"rightmost()","id":"rightmost","depth":2,"charIndex":385},{"text":"bottommost()","id":"bottommost","depth":2,"charIndex":448},{"text":"best()","id":"best","depth":2,"charIndex":512},{"text":"worst()","id":"worst","depth":2,"charIndex":567},{"text":"sortBy(cmp)","id":"sortbycmp","depth":2,"charIndex":623}],"domain":"","frontmatter":{},"version":""},{"id":88,"title":"Point","content":"#\n\nfindColor, findImage 返回的对象。表示一个点（坐标）。\n\n\nPoint.x#\n\n横坐标。\n\n\nPoint.y#\n\n纵坐标。","routePath":"/v1/高级/images/point","lang":"","toc":[{"text":"Point.x","id":"pointx","depth":2,"charIndex":42},{"text":"Point.y","id":"pointy","depth":2,"charIndex":59}],"domain":"","frontmatter":{},"version":""},{"id":89,"title":"Media","content":"#\n\n稳定性: 稳定\n\n\nmedia 模块提供多媒体编程的支持。目前仅支持音乐播放和媒体文件扫描。后续会结合 UI 加入视频播放等功能。\n\n需要注意是，使用该模块播放音乐时是在后台异步播放的，在脚本结束后会自动结束播放，因此可能需要插入诸如sleep()的语句来使脚本保持运行。例如：\n\n\n\n\nmedia.scanFile(path)#\n\n * path {string} 媒体文件路径\n\n扫描路径 path 的媒体文件，将它加入媒体库中；或者如果该文件以及被删除，则通知媒体库移除该文件。\n\n媒体库包括相册、音乐库等，因此该函数可以用于把某个图片文件加入相册。\n\n\n\n\nmedia.playMusic(path[, volume, looping])#\n\n * path {string} 音乐文件路径\n * volume {number} 播放音量，为 0~1 的浮点数，默认为 1\n * looping {boolean} 是否循环播放，如果 looping 为true则循环播放，默认为false\n\n播放音乐文件 path。该函数不会显示任何音乐播放界面。如果文件不存在或者文件不是受支持的音乐格式，则抛出UncheckedIOException异常。\n\n\n\n如果要循环播放音乐，则使用 looping 参数：\n\n\n\n如果要使用音乐播放器播放音乐，调用app.viewFile(path)函数。\n\n\nmedia.musicSeekTo(msec)#\n\n * msec {number} 毫秒数，表示音乐进度\n\n把当前播放进度调整到时间 msec 的位置。如果当前没有在播放音乐，则调用函数没有任何效果。\n\n例如，要把音乐调到 1 分钟的位置，为media.musicSeekTo(60 * 1000)。\n\n\n\n\nmedia.pauseMusic()#\n\n暂停音乐播放。如果当前没有在播放音乐，则调用函数没有任何效果。\n\n\nmedia.resumeMusic()#\n\n继续音乐播放。如果当前没有播放过音乐，则调用该函数没有任何效果。\n\n\nmedia.stopMusic()#\n\n停止音乐播放。如果当前没有在播放音乐，则调用函数没有任何效果。\n\n\nmedia.isMusicPlaying()#\n\n * 返回 {boolean}\n\n返回当前是否正在播放音乐。\n\n\nmedia.getMusicDuration()#\n\n * 返回 {number}\n\n返回当前音乐的时长。单位毫秒。\n\n\nmedia.getMusicCurrentPosition()#\n\n * 返回 {number}\n\n返回当前音乐的播放进度(已经播放的时间)，单位毫秒。","routePath":"/v1/高级/media","lang":"","toc":[{"text":"media.scanFile(path)","id":"mediascanfilepath","depth":2,"charIndex":146},{"text":"media.playMusic(path[, volume, looping])","id":"mediaplaymusicpath-volume-looping","depth":2,"charIndex":285},{"text":"media.musicSeekTo(msec)","id":"mediamusicseektomsec","depth":2,"charIndex":603},{"text":"media.pauseMusic()","id":"mediapausemusic","depth":2,"charIndex":759},{"text":"media.resumeMusic()","id":"mediaresumemusic","depth":2,"charIndex":814},{"text":"media.stopMusic()","id":"mediastopmusic","depth":2,"charIndex":871},{"text":"media.isMusicPlaying()","id":"mediaismusicplaying","depth":2,"charIndex":925},{"text":"media.getMusicDuration()","id":"mediagetmusicduration","depth":2,"charIndex":983},{"text":"media.getMusicCurrentPosition()","id":"mediagetmusiccurrentposition","depth":2,"charIndex":1044}],"domain":"","frontmatter":{},"version":""},{"id":90,"title":"module (模块)","content":"#\n\n稳定性: 稳定\n\n\nAuto.js 有一个简单的模块加载系统。 在 Auto.js 中，文件和模块是一一对应的（每个文件被视为一个独立的模块）。\n\n例子，假设有一个名为 foo.js 的文件：\n\n\n\n在第一行中，foo.js 加载了同一目录下的 circle.js 模块。\n\ncircle.js 文件的内容为：\n\n\n\ncircle.js 模块导出了 area() 和 circumference() 两个函数。 通过在特殊的 exports\n对象上指定额外的属性，函数和对象可以被添加到模块的根部。\n\n模块内的本地变量是私有的。 在这个例子中，变量 PI 是 circle.js 私有的，不会影响到加载他的脚本的变量环境。\n\nmodule.exports 属性可以被赋予一个新的值（例如函数或对象）。\n\n如下，bar.js 会用到 square 模块，square 导出一个构造函数：\n\n\n\nsquare 模块定义在 square.js 中：\n\n\n\n\nrequire函数#\n\nrequire函数用于加载模块，返回模块中module.exports的值。\n\n该函数有一个参数用于查找模块位置，可以是相对路径(以'./'或'../'开头)，也可以是绝对路径(以'/'开头)，\n还可以是以'http://'或'https://'开头的 uri 地址，用于加载网络模块，出于安全和加载速度考虑，此方式不建议使用。\n\n当没有以这些开头时，将会视为内置模块，从内置模块目录依次查找，由于历史原因，在脚本主文件中仍然会先尝试解析成相对路径解析，若解析成功则会忽略内置模块直接加载，强\n烈不建议使用此方式加载相对路径的模块，该方式在模块中不可用并且被弃用，在未来版本可能会被移除。\n\n和 nodejs 类似，当传入的是一个目录，则会尝试加载该目录下的 index.js 文件，若存在 package.json 文件则会先解析该文件中的 main\n字段，若 main 字段指向一个有效的模块将直接加载该模块。\n\n\n模块变量#\n\n这些变量只存在于模块中，并非全局变量\n\n * module 储存当前模块一些信息的对象，其中最重要的是module.exports表示该模块导出的对象\n\n * exports 相当于预先运行了var exports = module.exports\n\n * __dirname 当前模块的目录名\n\n * __filename 当前模块的文件名。 这是当前模块文件的已解析符号链接的绝对路径。","routePath":"/v1/高级/modules","lang":"","toc":[{"text":"`require`函数","id":"require函数","depth":3,"charIndex":-1},{"text":"模块变量","id":"模块变量","depth":3,"charIndex":850}],"domain":"","frontmatter":{},"version":""},{"id":91,"title":"Google ML kIT OCR","content":"OCR 文档#\n\n稳定性: 实验\n\n\n\nPaddle OCR#\n\n5.6.1 新增 基于百度飞桨的 OCR\n\n\npaddle.ocr(img, path)#\n\n * img {Image} 图片\n * path {String} 自定义模型路径,必须是绝对路径\n * return {Array}\n\n使用自定义模型进行文字识别\n\n\n\n\npaddle.ocr(img[, cpuThreadNum=4, useSlim=true])#\n\n * img {Image} 图片\n * cpuThreadNum {Number} 识别使用的 CPU 核心数量\n * useSlim {Boolean} 加载的模型,可选值:\n   * true ocr_v2_for_cpu(slim) :快速模型,默认\n   * false ocr_v2_for_cpu : 精准模型\n * return {Array}\n\n高精度识别，返回值包含坐标，置信度\n\n\n\n返回值示例\n\n\n\n\npaddle.ocrText(img[, cpuThreadNum=4, useSlim=true])#\n\n * img {Image} 图片\n * cpuThreadNum {Number} 识别使用的 CPU 核心数量\n * useSlim {Boolean} 加载的模型,可选值:\n   * true ocr_v2_for_cpu(slim) :快速模型,默认\n   * false ocr_v2_for_cpu : 精准模型\n * return {Array} 字符串数组\n\n只返回文本识别信息\n\n\n\n\npaddle.release()#\n\n释放 native 内存，非必要，供万一出现内存泄露时使用\n\n\nTessract OCR#\n\n6.2.9 新增 前往 github 下载完整例子：TessractOCR\n\n\nGoogle ML kIT OCR#\n\n6.3.4 新增\n\n\ngmlkit.ocr(img,Language)#\n\n * img {Image} 图片\n * Language {String} 识别语言，可选值为：\n   * la 拉丁\n   * zh 中文\n   * sa 梵文\n   * ja 日语\n   * ko 韩语\n   * 更多语言\n * retrun {Object} Json\n\n","routePath":"/v1/高级/ocr","lang":"","toc":[{"text":"paddle.ocr(img, path)","id":"paddleocrimg-path","depth":2,"charIndex":55},{"text":"paddle.ocr(img[, cpuThreadNum=4, useSlim=true])","id":"paddleocrimg-cputhreadnum4-useslimtrue","depth":2,"charIndex":167},{"text":"paddle.ocrText(img[, cpuThreadNum=4, useSlim=true])","id":"paddleocrtextimg-cputhreadnum4-useslimtrue","depth":2,"charIndex":430},{"text":"paddle.release()","id":"paddlerelease","depth":2,"charIndex":686},{"text":"gmlkit.ocr(img,Language)","id":"gmlkitocrimglanguage","depth":2,"charIndex":823}],"domain":"","frontmatter":{},"version":""},{"id":92,"title":"SensorEventEmitter","content":"Sensors#\n\n稳定性: 稳定\n\n\nsensors\n模块提供了获取手机上的传感器的信息的支持，这些传感器包括距离传感器、光线光感器、重力传感器、方向传感器等。需要指出的是，脚本只能获取传感器的数据，不能模拟或伪造\n传感器的数据和事件，因此诸如模拟摇一摇的功能是无法实现的。\n\n要监听一个传感器时，需要使用sensors.register()注册监听器，之后才能开始监听；不需要监听时则调用sensors.unregister()注销监听\n器。在脚本结束时会自动注销所有的监听器。同时，这种监听会使脚本保持运行状态，如果不注销监听器，脚本会一直保持运行状态。\n\n例如，监听光线传感器的代码为：\n\n\n\n要注意的是，每个传感器的数据并不相同，所以对他们调用on()监听事件时的回调函数参数也不是相同，例如光线传感器参数为(event,\nlight)，加速度传感器参数为(event, ax, ay,\naz)。甚至在某些设备上的传感器参数有所增加，例如华为手机的距离传感器为三个参数，一般手机只有一个参数。\n\n常用的传感器及其事件参数如下表：\n\n * accelerometer 加速度传感器，参数(event, ax, ay, az):\n   \n   * event SensorEvent 传感器事件，用于获取传感器数据变化时的所有信息\n   * ax {number} x 轴上的加速度，单位 m/s^2\n   * ay {number} y 轴上的加速度，单位 m/s^2\n   * az {number} z 轴上的加速度，单位 m/s^2 这里的 x 轴，y 轴，z 轴所属的坐标系统如下图(其中 z 轴垂直于设备屏幕表面):\n   \n   !\n\n * orientation 方向传感器，参数(event, azimuth, pitch, roll):\n   \n   * event SensorEvent 传感器事件，用于获取传感器数据变化时的所有信息\n   * azimuth {number} 方位角，从地磁指北方向线起，依顺时针方向到 y 轴之间的水平夹角，单位角度，范围 0~359\n   * pitch {number} 绕 x 轴旋转的角度，当设备水平放置时该值为\n     0，当设备顶部翘起时该值为正数，当设备尾部翘起时该值为负数，单位角度，范围-180~180\n   * roll {number} 绕 y 轴顺时针旋转的角度，单位角度，范围-90~90\n\n * gyroscope 陀螺仪传感器，参数(event, wx, wy, wz):\n   \n   * event SensorEvent 传感器事件，用于获取传感器数据变化时的所有信息\n   * wx {number} 绕 x 轴的角速度，单位弧度/s\n   * wy {number} 绕 y 轴的角速度，单位弧度/s\n   * wz {number} 绕 z 轴的角速度，单位弧度/s\n\n * magnetic_field 磁场传感器，参数(event, bx, by, bz):\n   \n   * event SensorEvent 传感器事件，用于获取传感器数据变化时的所有信息\n   * bx {number} x 轴上的磁场强度，单位 uT\n   * by {number} y 轴上的磁场强度，单位 uT\n   * bz {number} z 轴上的磁场强度，单位 uT\n\n * gravity 重力传感器，参数(event, gx, gy, gz):\n   \n   * event SensorEvent 传感器事件，用于获取传感器数据变化时的所有信息\n   * gx {number} x 轴上的重力加速度，单位 m/s^2\n   * gy {number} y 轴上的重力加速度，单位 m/s^2\n   * gz {number} z 轴上的重力加速度，单位 m/s^2\n\n * linear_acceleration 线性加速度传感器，参数(event, ax, ay, az):\n   \n   * event SensorEvent 传感器事件，用于获取传感器数据变化时的所有信息\n   * ax {number} x 轴上的线性加速度，单位 m/s^2\n   * ay {number} y 轴上的线性加速度，单位 m/s^2\n   * az {number} z 轴上的线性加速度，单位 m/s^2\n\n * ambient_temperature 环境温度传感器，大部分设备并不支持，参数(event, t):\n   \n   * event SensorEvent 传感器事件，用于获取传感器数据变化时的所有信息\n   * t {number} 环境温度，单位摄氏度。\n\n * light 光线传感器，参数(event, light):\n   \n   * event SensorEvent 传感器事件，用于获取传感器数据变化时的所有信息\n   * light {number} 环境光强度，单位 lux\n\n * pressure 压力传感器，参数(event, p):\n   \n   * event SensorEvent 传感器事件，用于获取传感器数据变化时的所有信息\n   * p {number} 大气压，单位 hPa\n\n * proximity 距离传感器，参数(event, distance):\n   \n   * event SensorEvent 传感器事件，用于获取传感器数据变化时的所有信息\n   * distance {number} 一般指设备前置摄像头旁边的距离传感器到前方障碍物的距离，并且很多设备上这个值只有两种情况：当障碍物较近时该值为\n     0，当障碍物较远或在范围内没有障碍物时该值为 5\n\n * relative_humidity 湿度传感器，大部分设备并不支持，参数(event, rh):\n   \n   * event SensorEvent 传感器事件，用于获取传感器数据变化时的所有信息\n   * rh {number} 相对湿度，范围为 0~100（百分比）\n\n\nsensors.register(sensorName[, delay])#\n\n * sensorName {string} 传感器名称，常用的传感器名称如上面所述\n * delay {number} 传感器数据更新频率，可选，默认为sensors.delay.normal。可用的值如下：\n   * sensors.delay.normal 正常频率\n   * sensors.delay.ui 适合于用户界面的更新频率\n   * sensors.delay.game 适合于游戏的更新频率\n   * sensors.delay.fastest 最快的更新频率】\n * 返回 SensorEventEmiiter\n\n注册一个传感器监听并返回SensorEventEmitter。\n\n例如:\n\n\n\n可以通过 delay 参数来指定传感器数据的更新频率，例如：\n\n\n\n另外，如果不支持sensorName所指定的传感器，那么该函数将返回null；但如果sensors.ignoresUnsupportedSensor的值被设置为\ntrue, 则该函数会返回一个不会分发任何传感器事件的SensorEventEmitter。\n\n例如:\n\n\n\n更多信息，参见SensorEventEmitter和sensors.ignoresUnsupportedSensor。\n\n\nsensors.unregister(emitter)#\n\n * emiiter SensorEventEmitter\n\n注销该传感器监听器。被注销的监听器将不再能监听传感器数据。\n\n\n\n\nsensors.unregisterAll()#\n\n注销所有传感器监听器。\n\n\nsensors.ignoresUnsupportedSensor#\n\n * {boolean}\n\n表示是否忽略不支持的传感器。如果该值被设置为true，则函数sensors.register()即使对不支持的传感器也会返回一个无任何数据的虚拟传感器监听，也就\n是sensors.register()不会返回null从而避免非空判断，并且此时会触发sensors的\"unsupported_sensor\"事件。\n\n\n\n\n事件: 'unsupported_sensor'#\n\n * sensorName {string} 不支持的传感器名称\n\n当sensors.ignoresUnsupportedSensor被设置为true并且有不支持的传感器被注册时触发该事件。事件参数的传感器名称。\n\n\nSensorEventEmitter#\n\n注册传感器返回的对象，其本身是一个 EventEmmiter，用于监听传感器事件。\n\n\n事件: 'change'#\n\n * ..args {Any} 传感器参数\n\n当传感器数据改变时触发该事件；该事件触发的最高频繁由sensors.register()指定的 delay 参数决定。\n\n事件参数根据传感器类型不同而不同，具体参见本章最前面的列表。\n\n一个监听光线传感器和加速度传感器并且每 0.5 秒获取一个数据并最终写入一个 csv 表格文件的例子如下：\n\n\n\n\n事件: 'accuracy_change'#\n\n * accuracy {number} 表示传感器精度。为以下值之一:\n   * -1 传感器未连接\n   * 0 传感器不可读\n   * 1 低精度\n   * 2 中精度\n   * 3 高精度\n\n当传感器精度改变时会触发的事件。比较少用。","routePath":"/v1/高级/sensors","lang":"","toc":[{"text":"sensors.register(sensorName[, delay])","id":"sensorsregistersensorname-delay","depth":2,"charIndex":2566},{"text":"sensors.unregister(emitter)","id":"sensorsunregisteremitter","depth":2,"charIndex":3147},{"text":"sensors.unregisterAll()","id":"sensorsunregisterall","depth":2,"charIndex":3242},{"text":"sensors.ignoresUnsupportedSensor","id":"sensorsignoresunsupportedsensor","depth":2,"charIndex":3282},{"text":"事件: 'unsupported_sensor'","id":"事件-unsupported_sensor","depth":2,"charIndex":3491},{"text":"事件: 'change'","id":"事件-change","depth":2,"charIndex":3692},{"text":"事件: 'accuracy_change'","id":"事件-accuracy_change","depth":2,"charIndex":3881}],"domain":"","frontmatter":{},"version":""},{"id":93,"title":"","content":"am 命令#\n\nam 命令即 Activity Manager 命令，用于管理应用程序活动、服务等。\n\n以下命令均以\"am \"开头，例如shell('am start -p com.tencent.mm');(启动微信)\n\n\nstart [options] intent#\n\n启动 intent 指定的 Activity(应用程序活动)。\n\n请参阅 intent 参数的规范。\n\n选项包括：\n\n * -D：启用调试。\n * -W：等待启动完成。\n * --start-profiler file：启动分析器并将结果发送到 file。\n * -P file：类似于 --start-profiler，但当应用进入空闲状态时分析停止。\n * -R count：重复 Activity 启动 count 次数。在每次重复前，将完成顶部 Activity。\n * -S：启动 Activity 前强行停止目标应用。\n * --opengl-trace：启用 OpenGL 函数的跟踪。\n * --user user_id | current：指定要作为哪个用户运行；如果未指定，则作为当前用户运行。\n\n\nstartservice [options] intent#\n\n启动 intent 指定的 Service(服务)。\n\n请参阅 intent 参数的规范。\n\n选项包括：\n\n * --user user_id | current：指定要作为哪个用户运行；如果未指定，则作为当前用户运行。\n\n\nforce-stop package#\n\n强行停止与 package（应用包名）关联的所有应用。\n\n\nkill [options] package#\n\n终止与 package（应用包名）关联的所有进程。此命令仅终止可安全终止且不会影响用户体验的进程。\n\n选项包括：\n\n * --user user_id | all | current：指定将终止其进程的用户；如果未指定，则终止所有用户的进程。\n\n\nkill-all#\n\n终止所有后台进程。\n\n\nbroadcast [options] intent#\n\n发出广播 intent。 请参阅 intent 参数的规范。\n\n选项包括：\n\n * [--user user_id | all | current]：指定要发送到的用户；如果未指定，则发送到所有用户。\n\n\ninstrument [options] component#\n\n使用 Instrumentation 实例启动监控。通常，目标 component 是表单 test_package/runner_class。\n\n选项包括：\n\n * -r：输出原始结果（否则对 report_key_streamresult 进行解码）。与 [-e perf true]\n   结合使用以生成性能测量的原始输出。\n * -e name value：将参数 name 设为 value。对于测试运行器，通用表单为 -e testrunner_flag\n   value[,value...]。\n * -p file：将分析数据写入 file。\n * -w：先等待仪器完成，然后再返回。测试运行器需要使用此选项。\n * --no-window-animation：运行时关闭窗口动画。\n * --user user_id | current：指定仪器在哪个用户中运行；如果未指定，则在当前用户中运行。\n * profile start process file 启动 process 的分析器，将结果写入 file。\n * profile stop process 停止 process 的分析器。\n\n\ndumpheap [options] process file#\n\n转储 process 的堆，写入 file。\n\n选项包括：\n\n * --user [user_id|current]：提供进程名称时，指定要转储的进程用户；如果未指定，则使用当前用户。\n * -n：转储原生堆，而非托管堆。\n * set-debug-app [options] package 将应用 package 设为调试。\n\n选项包括：\n\n * -w：应用启动时等待调试程序。\n * --persistent：保留此值。\n * clear-debug-app 使用 set-debug-app 清除以前针对调试用途设置的软件包。\n\n\nmonitor [options] 启动对崩溃或 ANR 的监控。#\n\n选项包括：\n\n * --gdb：在崩溃/ANR 时在给定端口上启动 gdbserv。\n\n\nscreen-compat {on|off} package#\n\n控制 package 的屏幕兼容性模式。\n\n\ndisplay-size [reset|widthxheight]#\n\n替换模拟器/设备显示尺寸。此命令对于在不同尺寸的屏幕上测试您的应用非常有用，它支持使用大屏设备模仿小屏幕分辨率（反之亦然）。\n\n示例：\n\n\n\n\ndisplay-density dpi#\n\n替换模拟器/设备显示密度。此命令对于在不同密度的屏幕上测试您的应用非常有用，它支持使用低密度屏幕在高密度环境环境上进行测试（反之亦然）。\n\n示例：\n\n\n\n\nto-uri intent#\n\n将给定的 intent 规范以 URI 的形式输出。 请参阅 intent 参数的规范。\n\n\nto-intent-uri intent#\n\n将给定的 intent 规范以 intent:URI 的形式输出。 请参阅 intent 参数的规范。\n\n\nintent 参数的规范#\n\n对于采用 intent 参数的 am 命令，您可以使用以下选项指定 intent：\n\n * -a action\n   \n   指定 intent 操作，如“android.intent.action.VIEW”。此指定只能声明一次。\n * -d data_uri\n   \n   指定 intent 数据 URI，如“content://contacts/people/1”。此指定只能声明一次。\n * -t mime_type\n   \n   指定 intent MIME 类型，如“image/png”。此指定只能声明一次。\n * -c category\n   \n   指定 intent 类别，如“android.intent.category.APP_CONTACTS”。\n * -n component\n   \n   指定带有软件包名称前缀的组件名称以创建显式 intent，如“com.example.app/.ExampleActivity”。\n * -f flags\n   \n   将标志添加到 setFlags() 支持的 intent。\n * --esn extra_key\n   \n   添加一个 null extra。URI intent 不支持此选项。\n * -e|--es extra_key extra_string_value\n   \n   添加字符串数据作为键值对。\n * --ez extra_key extra_boolean_value\n   \n   添加布尔型数据作为键值对。\n * --ei extra_key extra_int_value\n   \n   添加整数型数据作为键值对。\n * --el extra_key extra_long_value\n   \n   添加长整型数据作为键值对。\n * --ef extra_key extra_float_value\n   \n   添加浮点型数据作为键值对。\n * --eu extra_key extra_uri_value\n   \n   添加 URI 数据作为键值对。\n * --ecn extra_key extra_component_name_value\n   \n   添加组件名称，将其作为 ComponentName 对象进行转换和传递。\n * --eia extra_key extra_int_value[,extra_int_value...]\n   \n   添加整数数组。\n * --ela extra_key extra_long_value[,extra_long_value...]\n   \n   添加长整型数组。\n * --efa extra_key extra_float_value[,extra_float_value...]\n   \n   添加浮点型数组。\n * --grant-read-uri-permission\n   \n   包含标志 FLAG_GRANT_READ_URI_PERMISSION。\n * --grant-write-uri-permission\n   \n   包含标志 FLAG_GRANT_WRITE_URI_PERMISSION。\n * --debug-log-resolution\n   \n   包含标志 FLAG_DEBUG_LOG_RESOLUTION。\n * --exclude-stopped-packages\n   \n   包含标志 FLAG_EXCLUDE_STOPPED_PACKAGES。\n * --include-stopped-packages\n   \n   包含标志 FLAG_INCLUDE_STOPPED_PACKAGES。\n * --activity-brought-to-front\n   \n   包含标志 FLAG_ACTIVITY_BROUGHT_TO_FRONT。\n * --activity-clear-top\n   \n   包含标志 FLAG_ACTIVITY_CLEAR_TOP。\n * --activity-clear-when-task-reset\n   \n   包含标志 FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET。\n * --activity-exclude-from-recents\n   \n   包含标志 FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS。\n * --activity-launched-from-history\n   \n   包含标志 FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY。\n * --activity-multiple-task\n   \n   包含标志 FLAG_ACTIVITY_MULTIPLE_TASK。\n * --activity-no-animation\n   \n   包含标志 FLAG_ACTIVITY_NO_ANIMATION。\n * --activity-no-history\n   \n   包含标志 FLAG_ACTIVITY_NO_HISTORY。\n * --activity-no-user-action\n   \n   包含标志 FLAG_ACTIVITY_NO_USER_ACTION。\n * --activity-previous-is-top\n   \n   包含标志 FLAG_ACTIVITY_PREVIOUS_IS_TOP。\n * --activity-reorder-to-front\n   \n   包含标志 FLAG_ACTIVITY_REORDER_TO_FRONT。\n * --activity-reset-task-if-needed\n   \n   包含标志 FLAG_ACTIVITY_RESET_TASK_IF_NEEDED。\n * --activity-single-top\n   \n   包含标志 FLAG_ACTIVITY_SINGLE_TOP。\n * --activity-clear-task\n   \n   包含标志 FLAG_ACTIVITY_CLEAR_TASK。\n * --activity-task-on-home\n   \n   包含标志 FLAG_ACTIVITY_TASK_ON_HOME。\n * --receiver-registered-only\n   \n   包含标志 FLAG_RECEIVER_REGISTERED_ONLY。\n * --receiver-replace-pending\n   \n   包含标志 FLAG_RECEIVER_REPLACE_PENDING。\n * --selector\n   \n   需要使用 -d 和 -t 选项以设置 intent 数据和类型。\n\nURI component package#\n\n如果不受上述某一选项的限制，您可以直接指定 URI、软件包名称和组件名称。当参数不受限制时，如果参数包含一个“:”（冒号），则此工具假定参数是一个\nURI；如果参数包含一个“/”（正斜杠），则此工具假定参数是一个组件名称；否则，此工具假定参数是一个软件包名称。","routePath":"/v1/高级/shell/amCommand","lang":"","toc":[{"text":"am 命令","id":"am-命令","depth":2,"charIndex":-1},{"text":"start [options] intent","id":"start-options-intent","depth":3,"charIndex":112},{"text":"startservice [options] intent","id":"startservice-options-intent","depth":3,"charIndex":497},{"text":"force-stop package","id":"force-stop-package","depth":3,"charIndex":642},{"text":"kill [options] package","id":"kill-options-package","depth":3,"charIndex":693},{"text":"kill-all","id":"kill-all","depth":3,"charIndex":842},{"text":"broadcast [options] intent","id":"broadcast-options-intent","depth":3,"charIndex":865},{"text":"instrument [options] component","id":"instrument-options-component","depth":3,"charIndex":997},{"text":"dumpheap [options] process file","id":"dumpheap-options-process-file","depth":3,"charIndex":1539},{"text":"monitor [options] 启动对崩溃或 ANR 的监控。","id":"monitor-options-启动对崩溃或-anr-的监控","depth":3,"charIndex":1843},{"text":"screen-compat {on|off} package","id":"screen-compat-onoff-package","depth":3,"charIndex":1924},{"text":"display-size [reset|widthxheight]","id":"display-size-resetwidthxheight","depth":3,"charIndex":1980},{"text":"display-density dpi","id":"display-density-dpi","depth":3,"charIndex":2088},{"text":"to-uri intent","id":"to-uri-intent","depth":3,"charIndex":2188},{"text":"to-intent-uri intent","id":"to-intent-uri-intent","depth":3,"charIndex":2251},{"text":"intent 参数的规范","id":"intent-参数的规范","depth":3,"charIndex":2328},{"text":"URI component package","id":"uri-component-package","depth":4,"charIndex":5184}],"domain":"","frontmatter":{},"version":""},{"id":94,"title":"","content":"其他命令#\n\n\n进行屏幕截图#\n\nscreencap 命令是一个用于对设备显示屏进行屏幕截图的 shell 实用程序。在 shell 中，此语法为：\n\n\n\n例如：\n\n\n\n\n列表文件#\n\n\n\n例如:\n\n","routePath":"/v1/高级/shell/otherCommand","lang":"","toc":[{"text":"其他命令","id":"其他命令","depth":2,"charIndex":-1},{"text":"进行屏幕截图","id":"进行屏幕截图","depth":3,"charIndex":7},{"text":"列表文件","id":"列表文件","depth":3,"charIndex":85}],"domain":"","frontmatter":{},"version":""},{"id":95,"title":"","content":"应用包名#\n\n所谓应用包名，是唯一确定应用的标识。例如微信的包名是\"com.tencent.mm\", QQ 的包名是\"com.tencent.mobileqq\"。\n\n要获取一个应用的包名，可以通过函数getPackageName(appName)获取。参见帮助->其他一般函数。\n\n\npm 命令#\n\npm 命令用于管理应用程序，例如卸载应用、冻结应用等。\n\n以下命令均以\"pm \"开头，例如\"shell(\"pm disable com.tencent.mm\");\"(冻结微信)\n\n\nlist packages [options] filter#\n\n输出所有软件包，或者，仅输出包名称包含 filter 中的文本的软件包。\n\n选项：\n\n * -f：查看它们的关联文件。\n * -d：进行过滤以仅显示已停用的软件包。\n * -e：进行过滤以仅显示已启用的软件包。\n * -s：进行过滤以仅显示系统软件包。\n * -3：进行过滤以仅显示第三方软件包。\n * -i：查看软件包的安装程序。\n * -u：也包括卸载的软件包。\n * --user user_id：要查询的用户空间。\n\n\nlist permission-groups#\n\n输出所有已知的权限组。\n\n\nlist permissions [options] group#\n\n输出所有已知权限，或者，仅输出 group 中的权限。\n\n选项：\n\n * -g：按组加以组织。\n * -f：输出所有信息。\n * -s：简短摘要。\n * -d：仅列出危险权限。\n * -u：仅列出用户将看到的权限。\n\n\nlist instrumentation [options]#\n\n列出所有测试软件包。\n\n选项：\n\n * -f：列出用于测试软件包的 APK 文件。\n * target_package：列出仅用于此应用的测试软件包。\n\n\nlist features#\n\n输出系统的所有功能。\n\n\nlist libraries#\n\n输出当前设备支持的所有库。\n\n\nlist users#\n\n输出系统上的所有用户。\n\n\npath package#\n\n输出给定 package 的 APK 的路径。\n\n\ninstall [options] path#\n\n将软件包（通过 path 指定）安装到系统。\n\n选项：\n\n * -l：安装具有转发锁定功能的软件包。\n * -r：重新安装现有应用，保留其数据。\n * -t：允许安装测试 APK。\n * -i installer_package_name：指定安装程序软件包名称。\n * -s：在共享的大容量存储（如 sdcard）上安装软件包。\n * -f：在内部系统内存上安装软件包。\n * -d：允许版本代码降级。\n * -g：授予应用清单文件中列出的所有权限。\n\n\nuninstall [options] package#\n\n从系统中卸载软件包。\n\n选项：\n\n * -k：移除软件包后保留数据和缓存目录。\n\n\nclear package#\n\n删除与软件包关联的所有数据。\n\n\nenable package_or_component#\n\n启用给定软件包或组件（作为“package/class”写入）。\n\n\ndisable package_or_component#\n\n停用给定软件包或组件（作为“package/class”写入）。\n\n\ndisable-user [options] package_or_component#\n\n选项：\n\n * --user user_id：要停用的用户。\n\n\ngrant package_name permission#\n\n向应用授予权限。在运行 Android 6.0（API 级别 23）及更高版本的设备上，可以是应用清单中声明的任何权限。在运行 Android 5.1（API\n级别 22）和更低版本的设备上，必须是应用定义的可选权限。\n\n\nrevoke package_name permission#\n\n从应用中撤销权限。在运行 Android 6.0（API 级别 23）及更高版本的设备上，可以是应用清单中声明的任何权限。在运行 Android 5.1（API\n级别 22）和更低版本的设备上，必须是应用定义的可选权限。\n\n\nset-install-location location#\n\n更改默认安装位置。位置值：\n\n * 0：自动—让系统决定最佳位置。\n * 1：内部—安装在内部设备存储上。\n * 2：外部—安装在外部介质上。\n\n> 注：此命令仅用于调试目的；使用此命令会导致应用中断和其他意外行为。\n\n\nget-install-location#\n\n返回当前安装位置。返回值：\n\n * 0 [auto]：让系统决定最佳位置。\n * 1 [internal]：安装在内部设备存储上\n * 2 [external]：安装在外部介质上\n\n\nset-permission-enforced permission [true|false]#\n\n指定是否应强制执行给定的权限。\n\n\ntrim-caches desired_free_space#\n\n减少缓存文件以达到给定的可用空间。\n\n\ncreate-user user_name#\n\n使用给定的 user_name 创建新用户，输出新用户的标识符。\n\n\nremove-user user_id#\n\n移除具有给定的 user_id 的用户，删除与该用户关联的所有数据。\n\n\nget-max-users#\n\n输出设备支持的最大用户数。","routePath":"/v1/高级/shell/pmCommand","lang":"","toc":[{"text":"应用包名","id":"应用包名","depth":2,"charIndex":-1},{"text":"pm 命令","id":"pm-命令","depth":2,"charIndex":141},{"text":"list packages [options] filter","id":"list-packages-options-filter","depth":3,"charIndex":240},{"text":"list permission-groups","id":"list-permission-groups","depth":3,"charIndex":487},{"text":"list permissions [options] group","id":"list-permissions-options-group","depth":3,"charIndex":526},{"text":"list instrumentation [options]","id":"list-instrumentation-options","depth":3,"charIndex":671},{"text":"list features","id":"list-features","depth":3,"charIndex":782},{"text":"list libraries","id":"list-libraries","depth":3,"charIndex":811},{"text":"list users","id":"list-users","depth":3,"charIndex":844},{"text":"path package","id":"path-package","depth":3,"charIndex":871},{"text":"install [options] path","id":"install-options-path","depth":3,"charIndex":912},{"text":"uninstall [options] package","id":"uninstall-options-package","depth":3,"charIndex":1166},{"text":"clear package","id":"clear-package","depth":3,"charIndex":1238},{"text":"enable package_or_component","id":"enable-package_or_component","depth":3,"charIndex":1271},{"text":"disable package_or_component","id":"disable-package_or_component","depth":3,"charIndex":1336},{"text":"disable-user [options] package_or_component","id":"disable-user-options-package_or_component","depth":3,"charIndex":1402},{"text":"grant package_name permission","id":"grant-package_name-permission","depth":3,"charIndex":1481},{"text":"revoke package_name permission","id":"revoke-package_name-permission","depth":3,"charIndex":1625},{"text":"set-install-location location","id":"set-install-location-location","depth":3,"charIndex":1771},{"text":"get-install-location","id":"get-install-location","depth":3,"charIndex":1914},{"text":"set-permission-enforced permission [true|false]","id":"set-permission-enforced-permission-truefalse","depth":3,"charIndex":2029},{"text":"trim-caches desired_free_space","id":"trim-caches-desired_free_space","depth":3,"charIndex":2097},{"text":"create-user user_name","id":"create-user-user_name","depth":3,"charIndex":2150},{"text":"remove-user user_id","id":"remove-user-user_id","depth":3,"charIndex":2209},{"text":"get-max-users","id":"get-max-users","depth":3,"charIndex":2268}],"domain":"","frontmatter":{},"version":""},{"id":96,"title":"附录: shell 命令简介","content":"shell 即 Unix Shell，在类 Unix 系统提供与操作系统交互的一系列命令。\n\n很多程序可以用来执行 shell 命令，例如终端模拟器。\n\n在 Auto.js 大致等同于用 adb 执行命令 \"adb shell\"。\n\n其实现包括两种方式：\n\n * 通过java.lang.Runtime.exec执行(shell, Tap, Home 等函数)\n * 通过内嵌终端模拟器执行(RootAutomator, Shell 等对象)\n\n\nshell 函数#\n\n稳定性: 稳定\n\n\n\nshell(cmd[, root])#\n\n * cmd {string} 要执行的命令\n * root {Boolean} 是否以 root 权限运行，默认为 false。\n\n一次性执行命令 cmd, 并返回命令的执行结果。返回对象的其属性如下:\n\n * code {number} 返回码。执行成功时为 0，失败时为非 0 的数字。\n * result {string} 运行结果(stdout 输出结果)\n * error {string} 运行的错误信息(stderr 输出结果)。例如执行需要 root 权限的命令但没有授予 root\n   权限会返回错误信息\"Permission denied\"。\n\n示例（强制停止微信）：\n\n\n\n\nShell#\n\nshell 函数通过用来一次性执行单条命令并获取结果。如果有多条命令需要执行，用 Shell 对象的效率更高。这是因为，每次运行 shell\n函数都会打开一个单独的 shell 进程并在运行结束后关闭他，这个过程需要一定的时间；而 Shell 对象自始至终使用同一个 shell 进程。\n\n\nnew Shell(root)#\n\n * root {Boolean} 是否以 root 权限运行一个 shell 进程，默认为 false。这将会影响其后使用该 Shell 对象执行的命令的权限\n\nShell 对象的\"构造函数\"。\n\n\n\n\nShell.exec(cmd)#\n\n * cmd {string} 要执行的命令\n\n执行命令 cmd。该函数不会返回任何值。\n\n注意，命令执行是\"异步\"的、非阻塞的。也就是不会等待命令完成后才继续向下执行。\n\n尽管这样的设计使用起来有很多不便之处，但受限于终端模拟器，暂时没有解决方式；如果后续能找到解决方案，则将提供Shell.execAndWaitFor函数。\n\n\nShell.exit()#\n\n直接退出 shell。正在执行的命令会被强制退出。\n\n\nShell.exitAndWaitFor()#\n\n执行\"exit\"命令并等待执行命令执行完成、退出 shell。\n\n此函数会执行 exit 命令来正常退出 shell。\n\n\nShell.setCallback(callback)#\n\n * callback {Object} 回调函数\n\n设置该 Shell 的回调函数，以便监听 Shell 的输出。可以包括以下属性：\n\n * onOutput {Function} 每当 shell 有新的输出时便会调用该函数。其参数是一个字符串。\n * onNewLine {Function} 每当 shell 有新的一行输出时便会调用该函数。其参数是一个字符串(不包括最后的换行符)。\n\n例如:\n\n\n\n\n附录: shell 命令简介#\n\n以下关于 shell 命令的资料来自AndroidStudio 用户指南：Shell 命令。","routePath":"/v1/高级/shell/shell","lang":"","toc":[{"text":"shell(cmd[, root])","id":"shellcmd-root","depth":2,"charIndex":245},{"text":"new Shell(root)","id":"new-shellroot","depth":2,"charIndex":721},{"text":"Shell.exec(cmd)","id":"shellexeccmd","depth":2,"charIndex":842},{"text":"Shell.exit()","id":"shellexit","depth":2,"charIndex":1027},{"text":"Shell.exitAndWaitFor()","id":"shellexitandwaitfor","depth":2,"charIndex":1070},{"text":"Shell.setCallback(callback)","id":"shellsetcallbackcallback","depth":2,"charIndex":1157}],"domain":"","frontmatter":{},"version":""},{"id":97,"title":"Thread","content":"#\n\n线程对象，threads.start()返回的对象，用于获取和控制线程的状态，与其他线程交互等。\n\nThread 对象提供了和 timers 模块一样的 API，例如setTimeout(),\nsetInterval()等，用于在该线程执行相应的定时回调，从而使线程之间可以直接交互。例如：\n\n\n\n\nThread.interrupt()#\n\n中断线程运行。\n\n\nThread.join([timeout])#\n\n * timeout {number} 等待时间，单位毫秒\n\n等待线程执行完成。如果 timeout 为 0，则会一直等待直至该线程执行完成；否则最多等待 timeout 毫秒的时间。\n\n例如:\n\n\n\n\nThread.isAlive()#\n\n * 返回 {boolean}\n\n返回线程是否存活。如果线程仍未开始或已经结束，返回false; 如果线程已经开始或者正在运行中，返回true。\n\n\nThread.waitFor()#\n\n等待线程开始执行。调用threads.start()以后线程仍然需要一定时间才能开始执行，因此调用此函数会等待线程开始执行；如果线程已经处于执行状态则立即返回。\n\n\n\n\nThread.setTimeout(callback, delay[, ...args])#\n\n参见timers.setTimeout。\n\n区别在于, 该定时器会在该线程执行。如果当前线程仍未开始执行或已经执行结束，则抛出IllegalStateException。\n\n\n\n\nThread.setInterval(callback, delay[, ...args])#\n\n参见timers.setInterval()。\n\n区别在于, 该定时器会在该线程执行。如果当前线程仍未开始执行或已经执行结束，则抛出IllegalStateException。\n\n\nThread.setImmediate(callback[, ...args])#\n\n参见timers.setImmediate。\n\n区别在于, 该定时器会在该线程执行。如果当前线程仍未开始执行或已经执行结束，则抛出IllegalStateException。\n\n\nThread.clearInterval(id)#\n\n参见timers.clearInterval()。\n\n区别在于, 该定时器会在该线程执行。如果当前线程仍未开始执行或已经执行结束，则抛出IllegalStateException。\n\n\nThread.clearTimeout(id)#\n\n参见timers.clearTimeout()。\n\n区别在于, 该定时器会在该线程执行。如果当前线程仍未开始执行或已经执行结束，则抛出IllegalStateException。\n\n\nThread.clearImmediate(id)#\n\n参见timers.clearImmediate()。\n\n区别在于, 该定时器会在该线程执行。如果当前线程仍未开始执行或已经执行结束，则抛出IllegalStateException。","routePath":"/v1/高级/threads/thread","lang":"","toc":[{"text":"Thread.interrupt()","id":"threadinterrupt","depth":2,"charIndex":152},{"text":"Thread.join([timeout])","id":"threadjointimeout","depth":2,"charIndex":183},{"text":"Thread.isAlive()","id":"threadisalive","depth":2,"charIndex":310},{"text":"Thread.waitFor()","id":"threadwaitfor","depth":2,"charIndex":404},{"text":"Thread.setTimeout(callback, delay[, ...args])","id":"threadsettimeoutcallback-delay-args","depth":2,"charIndex":508},{"text":"Thread.setInterval(callback, delay[, ...args])","id":"threadsetintervalcallback-delay-args","depth":2,"charIndex":646},{"text":"Thread.setImmediate(callback[, ...args])","id":"threadsetimmediatecallback-args","depth":2,"charIndex":786},{"text":"Thread.clearInterval(id)","id":"threadclearintervalid","depth":2,"charIndex":919},{"text":"Thread.clearTimeout(id)","id":"threadcleartimeoutid","depth":2,"charIndex":1039},{"text":"Thread.clearImmediate(id)","id":"threadclearimmediateid","depth":2,"charIndex":1157}],"domain":"","frontmatter":{},"version":""},{"id":98,"title":"threads","content":"Threads#\n\n稳定性: 实验\n\n\nThreads 模块提供了多线程支持，可以启动新线程来运行脚本。\n\n脚本主线程会等待所有子线程执行完成后才停止执行，因此如果子线程中有死循环，请在必要的时候调用exit()来直接停止脚本或threads.shutDownAll(\n)来停止所有子线程。\n\n通过threads.start()启动的所有线程会在脚本被强制停止时自动停止。\n\n由于 JavaScript 自身没有多线程的支持，因此您可能会遇到意料之外的问题。\n\n\nthreads#\n\n\nthreads.start(action)#\n\n * action {Function} 要在新线程执行的函数\n * 返回 Thread\n\n启动一个新线程并执行 action。\n\n例如:\n\n\n\n通过该函数返回的Thread对象可以获取该线程的状态，控制该线程的运行中。例如:\n\n\n\n更多信息参见Thread。\n\n\nthreads.shutDownAll()#\n\n停止所有通过threads.start()启动的子线程。\n\n\nthreads.currentThread()#\n\n * 返回 Thread\n\n返回当前线程。\n\n\nthreads.disposable()#\n\n * 返回 Disposable\n\n新建一个 Disposable 对象，用于等待另一个线程的某个一次性结果。更多信息参见线程通信以及Disposable。\n\n\nthreads.atomic([initialValue])#\n\n * initialValue {number} 初始整数值，默认为 0\n * 返回AtomicLong\n\n新建一个整数原子变量。更多信息参见线程安全以及AtomicLong。\n\n\nthreads.lock()#\n\n * 返回ReentrantLock\n\n新建一个可重入锁。更多信息参见线程安全以及ReentrantLock。","routePath":"/v1/高级/threads/threads","lang":"","toc":[{"text":"threads.start(action)","id":"threadsstartaction","depth":2,"charIndex":242},{"text":"threads.shutDownAll()","id":"threadsshutdownall","depth":2,"charIndex":399},{"text":"threads.currentThread()","id":"threadscurrentthread","depth":2,"charIndex":454},{"text":"threads.disposable()","id":"threadsdisposable","depth":2,"charIndex":504},{"text":"threads.atomic([initialValue])","id":"threadsatomicinitialvalue","depth":2,"charIndex":608},{"text":"threads.lock()","id":"threadslock","depth":2,"charIndex":732}],"domain":"","frontmatter":{},"version":""},{"id":99,"title":"线程安全","content":"#\n\n线程安全问题是一个相对专业的编程问题，本章节只提供给有需要的用户。\n\n引用维基百科的解释：\n\n> 线程安全是编程中的术语，指某个函数、函数库在多线程环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成。\n\n在 Auto.js 中，线程间变量在符合 JavaScript\n变量作用域规则的前提下是共享的，例如全局变量在所有线程都能访问，并且保证他们在所有线程的可见性。但是，不保证任何操作的原子性。例如经典的自增\"i++\"将不是原子\n性操作。\n\nRhino 和 Auto.js 提供了一些简单的设施来解决简单的线程安全问题，如锁threads.lock(), 函数同步锁sync(),\n整数原子变量threads.atomic()等。\n\n例如，对于多线程共享下的整数的自增操作(自增操作会导致问题，是因为自增操作实际上为i = i + 1，也就是先读取 i 的值, 把他加 1, 再赋值给 i,\n如果两个线程同时进行自增操作，可能出现 i 的值只增加了 1\n的情况)，应该使用threads.atomic()函数来新建一个整数原子变量，或者使用锁threads.lock()来保证操作的原子性，或者用sync()来增加\n同步锁。\n\n线程不安全的代码如下：\n\n\n\n此段代码运行后打开日志，可以看到日志中有重复的值出现。\n\n使用threads.atomic()的线程安全的代码如下:\n\n\n\n或者:\n\n\n\n或者:\n\n\n\n另外，数组 Array 不是线程安全的，如果有这种复杂的需求，请用 Android 和 Java 相关 API 来实现。例如CopyOnWriteList,\nVector等都是代替数组的线程安全的类，用于不同的场景。例如:\n\n\n\n但很明显的是，这些类不像数组那样简便易用，也不能使用诸如slice()之类的方便的函数。在未来可能会加入线程安全的数组来解决这个问题。当然您也可以为每个数组的操\n作加锁来解决线程安全问题：\n\n\n\n\nsync(func)#\n\n * func {Function} 函数\n * 返回 {Function}\n\n给函数 func 加上同步锁并作为一个新函数返回。\n\n","routePath":"/v1/高级/threads/线程安全","lang":"","toc":[{"text":"sync(func)","id":"syncfunc","depth":2,"charIndex":832}],"domain":"","frontmatter":{},"version":""},{"id":100,"title":"线程通信","content":"#\n\nAuto.js\n提供了一些简单的设施来支持简单的线程通信。threads.disposable()用于一个线程等待另一个线程的(一次性)结果，同时Lock.newConditi\non()提供了 Condition 对象用于一般的线程通信(await,\nsignal)。另外，events模块也可以用于线程通信，通过指定EventEmiiter的回调执行的线程来实现。\n\n使用threads.disposable()可以简单地等待和获取某个线程的执行结果。例如要等待某个线程计算\"1+.....+10000\":\n\n\n\n如果上述代码用Condition实现：\n\n\n\n如果上诉代码用events模块实现：\n\n\n\n有关线程的其他问题，例如生产者消费者等问题，请用 Java 相关方法解决，例如java.util.concurrent.BlockingQueue。","routePath":"/v1/高级/threads/线程通信","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":101,"title":"WebView 与 HTML","content":"#\n\n\n*JsBridge#\n\nv6.3.9新增\n\nhtml>>\n\n\n\njs代码\n\n\n\n\n纯js实现#\n\n","routePath":"/v1/高级/webViewAndHtml","lang":"","toc":[{"text":"*JsBridge","id":"jsbridge","depth":2,"charIndex":3},{"text":"纯js实现","id":"纯js实现","depth":2,"charIndex":44}],"domain":"","frontmatter":{},"version":""},{"id":102,"title":"WorkWithJava","content":"#\n\n关于调用 java 请查看这里 ，一个由 Rhino 维护者使用 GitHub Pages 部署的 Rhino 文档网站\n\n官方 issues 关于原 Rhino 文档地址404 的讨论","routePath":"/v1/高级/workWithJava","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":103,"title":"压缩与解压","content":"#\n\n\n压缩#\n\n\n\n\n解压#\n\n","routePath":"/v1/高级/zips","lang":"","toc":[{"text":"压缩","id":"压缩","depth":2,"charIndex":3},{"text":"解压","id":"解压","depth":2,"charIndex":11}],"domain":"","frontmatter":{},"version":""}]